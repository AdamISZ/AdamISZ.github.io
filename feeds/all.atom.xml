<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Joinmarket.me archive</title><link href="https://joinmarket.me/" rel="alternate"></link><link href="https://joinmarket.me/feeds/all.atom.xml" rel="self"></link><id>https://joinmarket.me/</id><updated>2020-06-15T00:00:00+02:00</updated><entry><title>The 445BTC gridchain case</title><link href="https://joinmarket.me/blog/blog/the-445-btc-gridchain-case/" rel="alternate"></link><published>2020-06-15T00:00:00+02:00</published><updated>2020-06-15T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2020-06-15:/blog/blog/the-445-btc-gridchain-case/</id><summary type="html">&lt;p&gt;analysis of gridchain blockchain analysis and implications for Joinmarket usage.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;The 445 BTC gridchain case&lt;/h3&gt;
&lt;p&gt;For those time-constrained or non-technical, it may make sense to read
only the &lt;a href="index.html#summary"&gt;Summary&lt;/a&gt; section of this article. It goes
without saying that the details do matter, and reading the other
sections will give you a much better overall picture.&lt;/p&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;p&gt;&lt;a href="index.html#background"&gt;Background - what is the "gridchain case"?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#change-peeling"&gt;Toxic change and peeling chains&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#change-joinmarket"&gt;Change outputs in a Joinmarket context&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#toxic-recall"&gt;The toxic recall attack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#size-factor"&gt;The size factor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#sudoku"&gt;Joinmarket sudoku&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#maker-taker"&gt;Reminder on the maker-taker tradeoff&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#address-reuse"&gt;Address reuse&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#summary"&gt;Summary; lessons learned; advice to users&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#already"&gt;Already implemented improvements&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#still-needed"&gt;Still needed improvements&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#recommendations"&gt;Recommendations for users&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="background"&gt;Background - what is the "gridchain case"?&lt;/h2&gt;
&lt;p&gt;This is a reflection on a case of reported theft as outlined
&lt;a href="https://old.reddit.com/r/Bitcoin/comments/69duq9/50_bounty_for_anybody_recovering_445_btc_stolen/"&gt;here&lt;/a&gt;
on reddit in early 2017 by user 'gridchain'.&lt;/p&gt;
&lt;p&gt;What I won't do here is discuss the practical details of the case;
things like, whether it was a hack or an inside job, nor anything like
network level metadata, all of which is extremely important in an actual
criminal investigation. But here I'm only focusing on the role played
by Joinmarket specifically and blockchain level activity of the coins,
generally.&lt;/p&gt;
&lt;p&gt;The reason for this blog post was
&lt;a href="https://research.oxt.me/the-cold-case-files/1"&gt;this&lt;/a&gt;
recent report by OXT Research - specifically by analyst
&lt;a href="https://bitcoinhackers.org/@ErgoBTC"&gt;ErgoBTC&lt;/a&gt;
(they require an email for signup to read the full report, otherwise you
only see the summary).&lt;/p&gt;
&lt;p&gt;A short note of thanks here to ErgoBTC and LaurentMT and others
involved, since this kind of detailed analysis is badly needed, I hope
will we see more, specifically in public, over time (we cannot hope for
such from the deeply unethical blockchain analysis companies).&lt;/p&gt;
&lt;p&gt;I'm [not]{style="text-decoration: underline;"} going to assume here
that you've read that report in full, but I am going to be referring to
its main set of conclusions, and analyzing them. Obviously if you want
to properly assess my statements, it's rather difficult - you'd need
full knowledge of Joinmarket's operation &lt;em&gt;and&lt;/em&gt; full details of the OXT
Research analysis - and even then, like me, you will still have some
significant uncertainties.&lt;/p&gt;
&lt;p&gt;So the case starts with the claimed theft in 2 parts: 45 BTC in &lt;a href="https://blockstream.info/tx/2f9bfc5f23b609f312faa60902022d6583136cc8e8a0aecf5213b41964963881"&gt;this
txn&lt;/a&gt;
(note I will use blockstream.info for my tx links because I find their
presentation easiest for single txs specifically; note that oxt.me 's
research tool is of course a vastly superior way to see a large network
of txs, which plays a crucial role in this analysis), and a
consolidation of 400BTC in &lt;a href="https://blockstream.info/tx/136d7c862267204c13fec539a89c7b9b44a92538567e1ebbce7fc9dd04c5a7f0"&gt;this other
txn&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;We'll assume that both of these utxos are under the control of a single
actor/thief, henceforth just &lt;em&gt;A&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Setting aside the (in some ways remarkable) timing - that &lt;em&gt;A&lt;/em&gt; did not
move the coins for about 2 years - let's outline roughly what happened,
and what the report tells us:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The 400BTC went into joinmarket as a maker, and did a bunch (11 to
    be precise) of transactions that effectively "peeled down" (more
    on this later) that 400 to perhaps 335 BTC (with the difference
    going into coinjoins).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;A&lt;/em&gt; then switched to a taker role for a while, focusing on higher
    denominations, ranging from \~ 6BTC to as high as \~58BTC. Many of
    these coinjoins had very low counterparty numbers (say 3-5 being
    typical).&lt;/li&gt;
&lt;li&gt;At some point some maker activity is seen again in this same
    "peeling chain"; the report terms this phase as "alternating",
    but it's hard to say for sure whether some particular script is
    running, whether &lt;em&gt;A&lt;/em&gt; is just randomly switching roles, or what.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Be aware that this simplified narrative suggests to the careless reader
that one can easily trace all the coins through all the coinjoins, which
of course is not true at all - each subsequent transaction moves some
portion into a "mixed state", but (a) we'll see later that just
"moved into mixed state" is not the end of the story for some of those
coins and (b) while this narrative is misleading for Joinmarket in
general, it is not &lt;em&gt;as&lt;/em&gt; misleading in this particular case.&lt;/p&gt;
&lt;p&gt;The distinction between the "second" and "third" phase as listed in
those bullet points is pretty much arbitrary, but what is not in doubt
as important is: that second phase marks a clear jump in coinjoin amount
average size (this could be read as impatience on &lt;em&gt;A&lt;/em&gt;'s part - but
that's just speculation), and this resulted in small anonymity sets in
some txs - 4 and 3 in two txs, in particular. Let's continue:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Within the second regime, the OXT analysis narrows in on those small
    anon set, large denomination txs - can they figure out which equal
    sized output belongs to &lt;em&gt;A&lt;/em&gt; here? The "toxic replay attack"
    (explained below) allows them to identify one coinjoin output
    unambiguously  - but that goes into another coinjoin. But in a
    second case it allows them to reduce the anonymity set (of the equal
    sized coinjoin outputs) to 2, and they trace forwards both of those
    outputs.&lt;/li&gt;
&lt;li&gt;One of those 2 coinjoin outputs (&lt;a href="https://blockstream.info/tx/2dc4e88685269795aafe7459087ab613878ce7d857dd35760eefeb9caf21371b"&gt;this
    txn&lt;/a&gt;
    , output index 2) pays, after several hops, into a Poloniex deposit
    address in &lt;a href="https://blockstream.info/tx/ab1e604cd959cc94b89ab02b691fe7d727d30637284e5e82908fb28b8db378f4"&gt;this
    txn&lt;/a&gt;
    ). Although this is several hops, and although it does not deposit
    all of that \~58BTC into Poloniex (only about half of it),
    nevertheless this can be (and is) treated as a significant lead.&lt;/li&gt;
&lt;li&gt;So the next step was to trace back from that specific Poloniex
    deposit address, which it turned out had a bunch of activity on it.
    See
    &lt;a href="https://blockstream.info/address/16vBEuZD54NzqnnSStPYxFF2aktGhhuaf1"&gt;16vBEuZD54NzqnnSStPYxFF2aktGhhuaf1&lt;/a&gt;
    . Indeed several other deposits to that single address are connected
    to the same Joinmarket cluster, and specifically connected to those
    smaller-anon set taker-side coinjoins. In total around 270BTC is
    eventually linked from &lt;em&gt;A&lt;/em&gt;'s joinmarket coinjoins to that deposit
    address. Even though some of those connections are ambiguous, due to
    address reuse the evidence of co-ownership appears very strong.&lt;/li&gt;
&lt;li&gt;Some further evidence is provided (though I am still fuzzy on the
    details, largely just because of the time needed to go through it
    all) linking more of the coins to final destinations, including some
    from the 45BTC original chunk. The claim is that 380BTC is linked at
    final destinations to the original 445BTC set. In the remainder
    I'll focus on what is already seen with this 270BTC set and only
    peripherally mention the rest - there is already a lot to chew on!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="change-peeling"&gt;Toxic change and peeling chains&lt;/h2&gt;
&lt;p&gt;The general idea of a "peeling chain" on the Bitcoin blockchain isn't
too hard to understand. Given 100 BTC in a single utxo, if I have to
make a monthly payment of 1 BTC and never use my wallet otherwise, then
clearly the tx sequence is (using (input1, input2..):(output1,
output2..)) as a rudimentary format): ((100):(1,99), (99):(1, 98),
(98:(1, 97)...). Ignoring fees of course. What matters here is that I
just always have a single utxo and that on the blockchain &lt;em&gt;my&lt;/em&gt; utxos
&lt;em&gt;may&lt;/em&gt; be linked as (100-99-88-97...) based on a &lt;a href="https://en.bitcoin.it/wiki/Privacy#Change_address_detection"&gt;change
heuristic&lt;/a&gt;
such as "round amount for payment". To whatever extent change
heuristics work, then to that extent ownership can be traced through
simple payments (especially and mostly if transactions have exactly two
outputs, so that the very &lt;em&gt;idea&lt;/em&gt; of change, let alone a change
heuristic, applies straightforwardly).&lt;/p&gt;
&lt;p&gt;&lt;img alt="peeling chain simple
example" src="https://web.archive.org/web/20200713230834im_/https://joinmarket.me/static/media/uploads/.thumbnails/PeelingChain1.png/PeelingChain1-418x296.png"&gt;{width="418"
height="296"}&lt;/p&gt;
&lt;p&gt;In peeling chains, sometimes, the primary heuristic is the &lt;strong&gt;size&lt;/strong&gt; of
the output. If you start with 1000 btc and you peel 0.1 btc hundreds of
times, it's obvious from the "size pattern" what the change is (and
indeed it's this case that gives rise to the name &lt;em&gt;peel chain&lt;/em&gt; because
"peel" refers to taking off a &lt;em&gt;small&lt;/em&gt; part of something, usually its
surface). The above diagram is more similar (but not the same, exactly)
as the initial flow in the gridchain case, with one very large utxo
gradually getting peeled off.&lt;/p&gt;
&lt;p&gt;In some cases timing may factor in; sometimes hackers will do hundreds
of such peels off a main originating utxo in a short time.&lt;/p&gt;
&lt;p&gt;You can think of a peeling chain as the lowest effort ownership
obfuscation out there. Notice how literally any, even the simplest,
Bitcoin wallet, has to offer the feature required to carry this out -
just make a vanilla payment, for which there is (almost always, but not
always) a change output, back to your wallet.&lt;/p&gt;
&lt;p&gt;So in Bitcoin's history, this technique has very often been seen used -
by hackers/thieves moving coins "away" from the original site of the
theft (I remember the &lt;a href="http://www.techienews.co.uk/973470/silk-road-like-sheep-marketplace-scams-users-39k-bitcoins-worth-40-million-stolen/"&gt;case of Sheep
Market&lt;/a&gt;
for example). Each "peel" raises additional uncertainty; the
non-change output is going somewhere, but who owns that? But the change
outputs represent a link allowing someone, in theory, to keep tracing
the activity of the original actor. Notice here how we talk about one
branch (our ((100):(1,99), (99):(1, 98), (98:(1, 97)...) example
illustrates it); but one could keep tracing the payment outputs (the
'1's in that flow) and see if they themselves form other peel chains,
leading to a tree.&lt;/p&gt;
&lt;p&gt;We mentioned a 'change heuristic' element to this - which is the
"main branch" if we're not sure which output is the change?&lt;/p&gt;
&lt;h3 id="change-joinmarket"&gt;Change outputs in a Joinmarket context&lt;/h3&gt;
&lt;p&gt;A reader should from this point probably be familiar with the basics of
Joinmarket's design. Apart from the
&lt;a href="https://github.com/Joinmarket-Org/joinmarket-clientserver"&gt;README&lt;/a&gt;
and &lt;a href="hhttps://github.com/JoinMarket-Org/joinmarket-clientserver/blob/master/docs/USAGE.md"&gt;usage
guide&lt;/a&gt;
of the main Joinmarket code repo, the diagrams showing the main
Joinmarket transaction types
&lt;a href="https://github.com/AdamISZ/JMPrivacyAnalysis/blob/master/tumbler_privacy.md#joinmarket-transaction-types"&gt;here&lt;/a&gt;
may be useful as a refresher or a reference point for the following.&lt;/p&gt;
&lt;p&gt;We have: \(N\) equal outputs and \(N\) or \(N-1\) non-equal change
outputs, where \(N-1\) happens when the taker does a "sweep",
emptying the mixdepth (= account; joinmarket wallets have 5 accounts by
default) without a change output. [This last feature is specific to
Joinmarket, and specific to the taker role: there's no other coinjoin
out there that provides the facility to sweep an arbitrary amount of
coins out to an equal-sized output, with no
change.]{style="text-decoration: underline;"} (I am emphasizing this not
for marketing, but because it's crucial to this topic, and not widely
understood I think).&lt;/p&gt;
&lt;p&gt;As an example of why it's important, here is one line from the OXT
Research article:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Fees taken directly in a mix transaction result in deterministic
links ("unmixed change").&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is false as an absolute statement; fees can be paid by a taker,
inside the transaction, with no unmixed change for the taker (this is
the Joinmarket 'sweep'). Deterministic links between inputs and change
outputs &lt;em&gt;do&lt;/em&gt; result from change, and fees &lt;em&gt;do&lt;/em&gt; create an additional flag
that can help make those linkages, in cases where there would be more
ambiguity. But a zero fee coinjoin with change outputs still has
deterministic links, usually.&lt;/p&gt;
&lt;p&gt;Why does the OXT Research article heavily focus on &lt;em&gt;toxic unmixed
change&lt;/em&gt; as a concept and as a key weakness of such protocols as
Joinmarket, and why do I disagree?&lt;/p&gt;
&lt;p&gt;As we discussed peeling chains offer a low quality of obfuscation, and
to unpack that: the problem is that if you have any relatively viable
change heuristic (it doesn't &lt;em&gt;have&lt;/em&gt; to be large amounts as discussed),
it can let you keep knowledge of ownership of a whole chain of
transactions. That basically gives the blockchain analyst (we'll call
&lt;em&gt;B&lt;/em&gt;) a very large attack surface. He can look at &lt;em&gt;all&lt;/em&gt; the information
flowing out of, or associated with, a whole chain of transactions. Any
later recombination of outputs from that "large attack surface" is
either a coinjoin or a "smoking gun" that different outward paths were
actually under the control of one owner (this comes back to that central
heuristic - common input ownership, and all the nuance around that).&lt;/p&gt;
&lt;p&gt;In Joinmarket or any other coinjoin protocol that does allow change
outputs, "change heuristic" doesn't really apply, it kind of morphs
into something else: it's very obvious which outputs are change, but it
is only &lt;em&gt;in some cases&lt;/em&gt; easy to disentangle which change outputs are
associated to which inputs, and that's actually what you need to know
if you want to trace via the change (as per "peeling chains"
description above). In high anonymity sets, it starts to get difficult
to do that disentangling, but more on that ("sudoku") later.&lt;/p&gt;
&lt;p&gt;The analysis done in the OXT Research report smartly combines a long
peeling chain with other specific weaknesses in the way &lt;em&gt;A&lt;/em&gt; acted, which
we will discuss in the next section.. So all this is very valid in my
view.&lt;/p&gt;
&lt;p&gt;[But I think going from the above to the conclusion "coinjoins which
have unmixed change are fundamentally inferior and not viable, compared
to coinjoins without unmixed change" is just flat out
wrong]{style="text-decoration: underline;"}. Consider yourself in the
position of &lt;em&gt;A&lt;/em&gt;. You have let's say 400BTC in a single utxo. If you run
a coinjoin protocol that insists on no change always, and without a
market mechanism, you are forced to use a fixed denomination, say 0.1
BTC (an example that seems common), now across thousands of
transactions. In order to create these fixed denomination utxos you are
faced with the same problem of trying to avoid a trivial peeling chain.
By insisting on no deterministic links within the coinjoin, you simply
move the problem to an earlier step, you do not remove it.&lt;/p&gt;
&lt;p&gt;Fixed denomination does not solve the problem of having an unusually
large amount to mix compared to your peers.&lt;/p&gt;
&lt;p&gt;Having said that, fixed denomination with no change at all, does create
other advantages - I certainly don't mean to disparage that model!
Without going into detail here, consider that a large set or network of
all-equal-in all-equal-out coinjoins can create similar effects to a
single, much larger, coinjoin (but this is a topic for another article).&lt;/p&gt;
&lt;h2 id="toxic-recall"&gt;The toxic recall attack&lt;/h2&gt;
&lt;p&gt;Earlier we explained that one of the steps of the OXT Research analysis
was to identify a low liquidity regime where &lt;em&gt;A&lt;/em&gt; was acting as taker,
and we mentioned the "toxic recall attack" was used to reduce the
anonymity sets of the coinjoin outputs, during this, to a level low
enough that simple enumeration could find good candidates for final
destinations of those coins.&lt;/p&gt;
&lt;p&gt;Embedded in this was a crucial piece of reasoning, and I think this was
a both excellent, and very important idea:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Joinmarket does not allow co-spending of utxos from different
    accounts&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;That means that if a coinjoin output &lt;em&gt;X&lt;/em&gt; is spent along with a utxo
    from the "peeling chain" (i.e. they are both inputs to the same
    tx), then &lt;em&gt;X&lt;/em&gt; is not owned by &lt;em&gt;A&lt;/em&gt; (assuming correct identification
    of &lt;em&gt;A&lt;/em&gt;'s peeling chain)&lt;/li&gt;
&lt;li&gt;Every time such an event occurs, that &lt;em&gt;X&lt;/em&gt; can be crossed off the
    list of coinjoin outputs that &lt;em&gt;A&lt;/em&gt; might own, thus reducing the
    anonymity set of that earlier coinjoin by 1.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The reasoning is not perfectly watertight:&lt;/p&gt;
&lt;p&gt;First, as the report observes: the first assumption behind it is "A
user can only run one mixing client at a time." This is clearly not
literally true, but like many things here, a good-enough guess is fine,
if it eventually leads to outcomes that further strengthen the case. And
that is definitely true here: while a smart operator probably would be
running more than one instance of Joinmarket code, it is not default
behaviour and requires both a little coding and some careful thought.
Most people would not do this.&lt;/p&gt;
&lt;p&gt;(Second, nothing stops a user from making a coinjoin to an address in
the same mixdepth (at least in the current software). It's just that
(a) that is heavily discouraged and (b) it's not easy to see a good
reason why someone would &lt;em&gt;try&lt;/em&gt; to do that. Still it is possible as a
mistake. But I don't think this is a reason to doubt the effectiveness
of the "toxic recall attack", just, it should be noted.)&lt;/p&gt;
&lt;p&gt;So overall the bolded sentence is the most interesting - Joinmarket's
intention is to prevent co-spending outputs which would ruin the effect
of any single coinjoin - i.e. it tries (caveat: above parenthetical) to
prevent you using both a coinjoin output and the change output (or any
other utxo in the same account as the change output and the original
inputs) together. And this small element of 'rigidity' in how coins
are selected for spending is actually another 'bit' of information
that &lt;em&gt;B&lt;/em&gt; can use to make deductions, at least some of the time.&lt;/p&gt;
&lt;p&gt;The following diagram tries to illustrate how these conditions lead to
the possibility of the attack, to reduce the anonymity set of coinjoin
outputs:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Toxic recall attack
illustration" src="https://web.archive.org/web/20200713230834im_/https://joinmarket.me/static/media/uploads/.thumbnails/ToxicRecall1.png/ToxicRecall1-692x490.png"&gt;{width="692"
height="490"}&lt;/p&gt;
&lt;p&gt;So in summary we see 4 really important factors leading to the attack's
viability:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Joinmarket's strict account separation&lt;/li&gt;
&lt;li&gt;Linkability via change - as we'll describe in the next section
    "Joinmarket sudoku", this is &lt;em&gt;usually&lt;/em&gt; but not always possible, so
    while (1) was 99% valid this is more like 75% valid (entirely vague
    figures of course).&lt;/li&gt;
&lt;li&gt;Reusing the same peers in different coinjoin transactions&lt;/li&gt;
&lt;li&gt;Low number of peers&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of course, 3 and 4 are closely tied together; reuse of peers happened a
lot precisely because there were so few peers available for large
coinjoin sizes (to remind you, it was between 6 and 58 BTC, and the
average was around 27, and there are/were few Joinmarket peers actually
offering above say 10BTC).&lt;/p&gt;
&lt;h2 id="size-factor"&gt;The size factor&lt;/h2&gt;
&lt;p&gt;This is a thread that's run through the above, but let's be clear
about it: in practice, typical Joinmarket coinjoins run from 0.1 to 10
BTC, which is unsurprising. There are a fair number of much smaller
transactions, many just functioning as tests, while &lt;em&gt;really&lt;/em&gt; small
amounts are not very viable due to the fees paid by the taker to the
bitcoin network. Larger than 10 BTC are certainly seen, including up to
50 BTC and even beyond, but they appear to be quite rare.&lt;/p&gt;
&lt;p&gt;The actions of &lt;em&gt;A&lt;/em&gt; in this regard were clearly suboptimal. They started
by taking 4 x 100 BTC outputs and consolidating them into 1 output of
400 BTC. This was not helpful, if anything the opposite should have been
done.&lt;/p&gt;
&lt;p&gt;Second, as a consequence, they placed the entirety of this (I'm
ignoring the 45 BTC output for now as it's not that crucial) in one
mixdepth. For smaller amounts where a user is just casually offering
coins for joining, one output is fine, and will rapidly be split up
anyway, but here this very large size [led to most of the large-ish
joining events forming part of one long peeling
chain&lt;em&gt;.&lt;/em&gt;]{style="text-decoration: underline;"} This part probably isn't
clear so let me illustrate. A yield generator/maker usually splits up
its coins into random chunks pretty quickly, and while as a maker they
do &lt;strong&gt;not&lt;/strong&gt; get the crucial "sweep, no change" type of transaction
mentioned above, they nevertheless do get fragmentation:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Initial deposit --&amp;gt; After 1 tx --&amp;gt; After 2 txs --&amp;gt; After many txs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0: 1BTC         --&amp;gt; 0.800 BTC  --&amp;gt; 0.800 BTC   --&amp;gt; 0.236 BTC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1: 0 BTC        --&amp;gt; 0.205 BTC  --&amp;gt; 0.110 BTC   --&amp;gt; 0.001 BTC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2: 0 BTC        --&amp;gt; 0.000 BTC  --&amp;gt; 0.100 BTC   --&amp;gt; 0.555 BTC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3: 0 BTC        --&amp;gt; 0.000 BTC  --&amp;gt; 0.000 BTC   --&amp;gt; 0.129 BTC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;4: 0 BTC        --&amp;gt; 0.000 BTC  --&amp;gt; 0.000 BTC   --&amp;gt; 0.107 BTC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;(Final total is a bit more than 1BTC due to fees; the reason it gets
jumbled, with no ordering, is: each tx moves coinjoin output to &lt;em&gt;next&lt;/em&gt;
mixdepth, mod 5 (ie it wraps), but when a new tx request comes in it
might be for any arbitrary size, so the mixdepth used as &lt;em&gt;source&lt;/em&gt; of
coins for that next transaction, could be any of them. This is
illustrated in the 'after 2 txs' case: the second mixdepth was chosen
as input to the second tx, not the first mixdepth).&lt;/p&gt;
&lt;p&gt;This dynamic does &lt;strong&gt;not&lt;/strong&gt; remove the "peeling chain" or "toxic
change" dynamic emphasized in OXT Research's report - because every tx
done by the maker still has its change, [precisely because as maker you
don't have the privilege of choosing the
amount]{style="text-decoration: underline;"}.&lt;/p&gt;
&lt;p&gt;But it does result in more so to speak "parallelisation" of the mixing
activity, instead of the largest chunk all being in one long chain.&lt;/p&gt;
&lt;p&gt;A question remains, if we imagine that we use much smaller amounts - can
the analyst always follow the "peeling chain of each mixdepth" (to
coin a phrase which at this point hopefully makes sense)?&lt;/p&gt;
&lt;p&gt;I think actually the answer is more 'no' than you might at first
think. The next section will illustrate.&lt;/p&gt;
&lt;h2 id="sudoku"&gt;Joinmarket sudoku.&lt;/h2&gt;
&lt;p&gt;This concept including its origination is covered in some detail in my
earlier article
&lt;a href="https://github.com/AdamISZ/JMPrivacyAnalysis/blob/master/tumbler_privacy.md#jmsudoku-coinjoin-sudoku-for-jmtxs"&gt;here&lt;/a&gt;.
Essentially we are talking about making unambiguous linkages between
change outputs and the corresponding inputs in any given Joinmarket
coinjoin. I reproduce one transaction diagram from that article here to
help the reader keep the right idea in mind:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Coinjoin
canonical" src="https://web.archive.org/web/20200713230834im_/https://joinmarket.me/static/media/uploads/cjmtx.svg"&gt;{width="550"
height="389"}&lt;/p&gt;
&lt;p&gt;So to effect this "sudoku" or disentangling, let's suppose you don't
have any sophistication. You're just going to iterate over every
possible subset of the inputs (they're randomly ordered, of course) and
see if it matches any particular change output (you assume that there is
exactly one change output per participant). In case it wasn't obvious,
"matches" here means "that change output, plus the coinjoin size (3
btc in the diagram above), equals the sum of the subset of inputs".&lt;/p&gt;
&lt;p&gt;Now none of them will &lt;em&gt;actually&lt;/em&gt; match because there are fees of two
types being paid out of (and into) the change - the bitcoin network fees
and the coinjoin fees (which add to most and subtract from one, at least
usually). So since you don't know the exact values of those fees, only
a general range, you have to include a "tolerance" parameter, which
really complicates the issue.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/AdamISZ/15223a5eab940559e5cf55e898354978"&gt;This
gist&lt;/a&gt;
is a quick and dirty (in the sense it's barely a 'program' since i
just hardcoded the values of the transaction) example of doing such a
Joinmarket sudoku for one of the transactions in the OXT Research
analysis of flows for this case. The pythonistas out there might find of
interest particularly this code snippet for finding the "power set"
(the set of all subsets):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;def power_set(l):&lt;/code&gt;\
&lt;code&gt;iil = range(len(l))&lt;/code&gt;\
&lt;code&gt;return list(chain.from_iterable(combinations(iil, r) for r in range(len(iil)+1)))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;As per a very beautiful piece of mathematical reasoning, the power set
of a set of size \(N\) is \(2\^{N}\) (every member of set is either
in, or not in, each subset - think about it!). So this matters because
it illustrates, crudely, how we have here an exponential blowup.&lt;/p&gt;
&lt;p&gt;That particular transaction had 24 inputs, so the power set's
cardinality would be \(2\^{24}\) - but the beginning of the analysis
is to take a subset, of size 4, you already conclude to be linked, thus
reducing the size of the search space by a factor of 16. Now, there's a
lot more to it, but, here's what's interesting: &lt;strong&gt;depending on the
tolerance you choose, you will often find there are multiple sudoku
solutions&lt;/strong&gt; if the size of the set of inputs is reasonably large (let's
say 20 and up, but it isn't possible to fix a specific number of
course). In the first couple of attempts of finding the solution for
that transaction, I found between 3 and 7 different possible ways the
inputs and outputs could connect; some of them involve the pre-grouped 4
inputs acting as taker (i.e. paying fees) and some involve them acting
as maker.&lt;/p&gt;
&lt;p&gt;Now, if this ambiguity isn't enough, there's another significant
source of ambiguity in these sudokus: previous equal-sized coinjoin
outputs. For example take &lt;a href="https://blockstream.info/tx/5f8747a3837a56dd2f422d137b96b1420fd6885be6d1057f3c4dca102a3138b6?output:5"&gt;this
txn&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="un-sudoku-able
tx" src="https://web.archive.org/web/20200713230834im_/https://joinmarket.me/static/media/uploads/.thumbnails/tx5f8747.png/tx5f8747-849x617.png"&gt;{width="849"
height="617"}&lt;/p&gt;
&lt;p&gt;There are 21 inputs, which is already in the "problematic" zone for
sudoku-ing, as discussed, in that it will tend to lead to multiple
possible solutions, with a reasonable tolerance parameter. But in this
case a full sudoku is fundamentally impossible: notice that inputs index
7 and 21 (counting from 0) both have amount 6.1212 . This means that any
subset that includes the first is identical to a subset that includes
the second. Those two outputs are, unsurprisingly, from the same
previous Joinmarket coinjoin (they don't have to be, though).&lt;/p&gt;
&lt;p&gt;In any long "peeling chain" these ambiguities will degrade, perhaps
destroy, the signal over time - unless there is some very strong
watermark effect - such as huge size, which is precisely what we see
with &lt;em&gt;A&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To summarize, we these key points about the Sudoku concept for
identifying chains of ownership:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As long as you don't sweep, a Joinmarket account, thus not emptied,
    will keep creating this chain of ownership via change - though the
    size of that linked amount dwindles over time.&lt;/li&gt;
&lt;li&gt;Thus makers (who cannot sweep) have no guarantee of not having that
    specific ownership trace persist, for each of their 5 accounts (but
    &lt;em&gt;not&lt;/em&gt; across them - the 5 accounts will not be connected on chain,
    at least not in a trivial way).&lt;/li&gt;
&lt;li&gt;If you use a very large size then this acts as a strong enough
    watermark that such tracing is pretty much guaranteed to work (i.e
    the Sudoku works much more reliably if you put in a 400BTC utxo and
    everyone else in the coinjoin only uses 10BTC at max).&lt;/li&gt;
&lt;li&gt;Otherwise, and in general, such tracing is a bit unreliable, and
    over a long series of transactions it becomes very unreliable (but
    again - this is no kind of privacy guarantee! - we just observe that
    there will be increasing uncertainty over a long chain, including
    really fundamental ambiguities like the transaction above).&lt;/li&gt;
&lt;li&gt;Whenever you &lt;em&gt;do&lt;/em&gt; sweep, you create what I called in the previous
    article a &lt;a href="https://github.com/AdamISZ/JMPrivacyAnalysis/blob/master/tumbler_privacy.md#joinmarket-wallet-closures"&gt;"completed mixdepth
    closure"&lt;/a&gt;;
    there is no change for you as taker, and so an end to that
    "chain". This only exists for takers. (you can of course sweep
    &lt;em&gt;without&lt;/em&gt; coinjoin at all, also).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="maker-taker"&gt;Reminder on the maker-taker tradeoff&lt;/h3&gt;
&lt;p&gt;This illustrates another aspect of the more general phenomenon -
Joinmarket almost by definition exists to serve takers. They pay for
these advantages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As coordinator, they do not reveal linkages to their counterparties.
    Makers must accept that the taker in each individual coinjoin &lt;em&gt;does&lt;/em&gt;
    know &lt;em&gt;their&lt;/em&gt; linkages (the maker's), even if they're OK with that
    over a long period because there are many disparate takers; that's
    a weakness.&lt;/li&gt;
&lt;li&gt;They choose the time when the coinjoin happens (within a minute or
    so, it's done, if all goes well)&lt;/li&gt;
&lt;li&gt;They choose the amount of the coinjoin, so can have a payment as a
    coinjoin outpoint.&lt;/li&gt;
&lt;li&gt;Corollary of the above: they can control the size of their change,
    in particular, reducing it to zero via a "sweep"&lt;/li&gt;
&lt;li&gt;Since they run only when they want to coinjoin, they have a smaller
    time footprint for attackers (makers have an "always on hot
    wallet" &lt;em&gt;which responds to requests rather than initiates them&lt;/em&gt; ,
    so it's more like a server than a client, which is by definition
    difficult to keep properly secure).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These 4+ advantages are what the Taker pays for, and it's interesting
that in practice that the &lt;em&gt;coinjoin&lt;/em&gt; fee has fallen to near-zero
&lt;strong&gt;except for larger sizes&lt;/strong&gt; .I will point to my earlier thoughts on low
fees
&lt;a href="https://x0f.org/web/statuses/104123055565241054"&gt;here&lt;/a&gt;
to avoid further sidetrack.&lt;/p&gt;
&lt;p&gt;Therefore the cool sounding idea "oh I have this bunch of bitcoin
sitting around, I'll just passively mix it for a while and actually get
paid to do it!" (I have noticed people &lt;em&gt;mostly&lt;/em&gt; get interested in
Joinmarket from this perspective) is more limited than it seems.&lt;/p&gt;
&lt;h2&gt;Address reuse&lt;/h2&gt;
&lt;p&gt;This will probably be the shortest section because it's so obvious.&lt;/p&gt;
&lt;p&gt;The fact that 270BTC of the 445 BTC going "into" Joinmarket ended up
at &lt;code&gt;16vBEuZD54NzqnnSStPYxFF2aktGhhuaf1&lt;/code&gt;is kind of a big facepalm moment;
I don't think anyone reading this blog would have trouble understanding
that.&lt;/p&gt;
&lt;p&gt;I don't dismiss or ignore that such things happen for a reason, and
that reason is mainly actions of centralized exchanges to deliberately
reduce the privacy of their customers ("KYC/AML"). Sometimes, of
course, sheer incompetence is involved. But it's the exception rather
than the rule, since even the most basic consumer wallets do not
generally reuse addresses nowadays. I'll consider these real world
factors out-of-scope of this article, although they will matter in your
practical real life decisions about keeping your privacy (consider &lt;em&gt;not&lt;/em&gt;
using such exchanges).&lt;/p&gt;
&lt;p&gt;What has to be said though: 270 does not equal 445 (or 400); it is not
impossible to imagine that such a set of deposits to one address may not
be traced/connected to the original deposit of 400 (+) into Joinmarket
(although it would really help if that total wasn't so very large that
there are only a few Joinmarket participants in that range anyway). And
indeed, my own examination of the evidence tells me that the connections
of each individual final deposit to
`16vBEuZD54NzqnnSStPYxFF2aktGhhuaf1```back to that original 445 is &lt;em&gt;not&lt;/em&gt;
unambiguous. The problem is of course the compounding effect of
evidence, as we will discuss in the next, final section.&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary; lessons learned; advice to users&lt;/h2&gt;
&lt;p&gt;So we've looked into details, can we summarize what went wrong for &lt;em&gt;A&lt;/em&gt;?
Albeit we don't actually know with certainty how much of the
attributions in the OXT Research are correct, they appear to be &lt;em&gt;broadly
correct&lt;/em&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;400 BTC is a very large amount to move through a system of perhaps
    at best a couple hundred users (100 makers on the offer at once is
    typical), most of whom are not operating with more than 10 BTC.&lt;/li&gt;
&lt;li&gt;One large chunk of 400 is therefore a way worse idea than say 10
    chunks of 40 across 10 Joinmarket wallets (just common sense really,
    although starting with 400 is not in itself a disaster, it just
    makes it harder, and slower). This would have been more hassle, and
    more fees, but would have helped an awful lot.&lt;/li&gt;
&lt;li&gt;Running passively as a maker proved too slow for &lt;em&gt;A&lt;/em&gt; (this is an
    assumption that the report makes and that I agree with, but not of
    course a 'fact'). This is Joinmarket's failing if anything; there
    are just not enough people using it, which relates to the next
    point:&lt;/li&gt;
&lt;li&gt;When switching to a taker mode (which in itself was a very good
    idea), &lt;em&gt;A&lt;/em&gt; decided to start doing much larger transaction sizes, but
    found themselves unable to get more than a few counterparties in
    some cases. This should have been a sign that the effect they were
    looking for might not be strong enough, but it's very
    understandable that they didn't grok the next point:&lt;/li&gt;
&lt;li&gt;The "toxic replay attack" very heavily compounds the low anonymity
    set problem mentioned above - reuse of the same counterparties in
    successive transactions reduced the anonymity set from "bad" to
    "disastrously low" (even down to 1 in one case).&lt;/li&gt;
&lt;li&gt;Even with the above failings, all needn't really be lost; repeated
    rounds are used and the '1' anonymity set mentioned output was
    sent to another coinjoin anyway. The first chunk of coins identified
    to be sent to Poloniex address (first to be identified, not first in
    time) was in an amount of about 28 BTC via several hops, then part
    of the 76 BTC in &lt;a href="https://web.archive.org/web/20200713230834/https://joinmarket.me/blog/blog/the-445-btc-gridchain-case/%22https://blockstream.info/tx/ab1e604cd959cc94b89ab02b691fe7d727d30637284e5e82908fb28b8db378f4"&gt;this
    txn&lt;/a&gt;,
    and even the first hop only had a 50% likelihood assigned. So it's
    a combination of (a) the address being marked as in the POLONIEX
    cluster, the size of the deposit and then the reuse allowing tracing
    back to other transactions, that caused a "high-likelihood
    assignment of ownership", which leads into ...&lt;/li&gt;
&lt;li&gt;Address reuse as discussed in the previous section is the biggest
    failing here. If all the deposits here were to different exchange
    addresses, these heuristics would not have led to any clear
    outcomes. A few guesses here and there would exist, but they would
    remain guesses, with other possibilities also being reasonable.&lt;/li&gt;
&lt;li&gt;Circling back to the beginning, notice how making educated guesses
    about deposits on exchanges a few hops away from Joinmarket might
    already be enough to get some decent guesses at ownership, if the
    sizes are large enough compared to the rest of the Joinmarket usage.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So overall the post mortem is: &lt;strong&gt;a combination of at least three
different things leads to a bad outcome for &lt;em&gt;A&lt;/em&gt; : large (much bigger
than typical JM volume) size not split up, heavy address reuse (on a
centralized exchange) and a small anonymity set portion of the
sequence.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This issue of "combination of factors" leading to a much worse than
expected privacy loss is explained well on the bitcoin wiki Privacy page
&lt;a href="https://en.bitcoin.it/wiki/Privacy#Method_of_data_fusion"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="already"&gt;Already implemented improvements&lt;/h3&gt;
&lt;p&gt;When running as a taker and using the so-called &lt;a href="https://github.com/JoinMarket-Org/joinmarket-clientserver/blob/master/docs/tumblerguide.md"&gt;tumbler
algorithm&lt;/a&gt;
users should note that in 2019 a fairly meaningful change to the
algorithm was implemented - one part was to start each run with a sweep
transaction out of each mixdepth containing coins as the first step
(with longer randomized waits). This makes a peeling chain direct from a
deposit not possible (you can always try to guess which coinjoin output
to hop to next of course, with the concomitant difficulties).
Additionally average requested anonymity sets are increased, which, as
an important byproduct tends to create larger input sets which are
harder to sudoku (and more likely to have substantial ambiguity). There
are several other minor changes like rounding amounts, see &lt;a href="https://gist.github.com/chris-belcher/7e92810f07328fdfdef2ce444aad0968"&gt;Chris
Belcher's document on
it&lt;/a&gt;
for more details.&lt;/p&gt;
&lt;h3 id="still-needed"&gt;Still needed improvements&lt;/h3&gt;
&lt;p&gt;Clearly the toxic recall attack concept matters - it is going to matter
more, statistically, as the anonymity set (i.e. the number of coinjoin
counterparties) is reduced, but it matters per se in any context -
reusing the same counterparties &lt;strong&gt;&lt;em&gt;in a sequence of coinjoins from the
same mixdepth closure&lt;/em&gt;&lt;/strong&gt; reduces the anonymity set. Notice there are a
couple of ways that situation could be remediated:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reduce the number of coinjoin transactions within the same mixdepth
    closure - but this is not clear. If I do 1 coinjoin transaction with
    10 counterparties and it's a sweep, closing the mixdepth closure,
    is that better than doing 2 coinjoin transactions from it, each of
    which has 6 counterparties, if there is a 10% chance of randomly
    choosing the same counterparty and thus reducing the anonymity set
    of the second coinjoin by 1? That is pretty profoundly unclear and
    seems to just "depend". 1 transaction with 12 counterparties &lt;em&gt;is&lt;/em&gt;
    clearly better, but very large sets like that are very difficult to
    achieve in Joinmarket today (particularly if your coinjoin amount is
    large).&lt;/li&gt;
&lt;li&gt;Actively try to prevent reusing the same counterparty for multiple
    transactions in the same mixdepth closure (obviously this is for
    takers; makers are not choosing, they are offering). Identification
    of bots is problematic, so probably the best way to do this is
    simply for a taker to keep track of its earlier txs (especially
    within a tumbler run, say) and decide to not include makers when
    they provide utxos that are recognized as in that set. This is still
    a bit tricky in practice; makers don't want their utxos queried all
    the time, but takers for optimal outcomes would like full
    transparent vision into those utxo sets - see &lt;a href="https://web.archive.org/web/20200713230834/https://joinmarket.me/blog/blog/poodle/"&gt;earlier discussion of
    PoDLE&lt;/a&gt;
    and
    &lt;a href="https://web.archive.org/web/20200713230834/https://joinmarket.me/blog/blog/racing-against-snoopers-in-joinmarket-02/"&gt;here&lt;/a&gt;
    on this blog for the tricky points around this.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(2) is an example of ideas that were discussed by Joinmarket
developers years ago, but never really went anywhere. Takers probably
&lt;em&gt;should&lt;/em&gt; expand the query power given them by the PoDLE tokens to have a
larger set of options to choose from, to gauge the "quality" of what
their counterparties propose as join inputs, but it's a delicate
balancing act, as mentioned.&lt;/p&gt;
&lt;h3 id="recommendations"&gt;Recommendations for users&lt;/h3&gt;
&lt;p&gt;For the final section, some practical advice. Joinmarket can be a
powerful tool - but it's unfortunately not very easy to understand what
you &lt;em&gt;should&lt;/em&gt; do, precisely because there is a lot of flexibility.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The taker role, and in particular the tumbler role, are designed to
    be used to actively improve your privacy. We explain above that it
    gives certain advantages over the maker role. So: &lt;strong&gt;use it!&lt;/strong&gt; - with
    at least the default settings for counterparty numbers and
    transaction numbers, and long waits - in fact, increase these
    factors above the defaults. Note that tumbles can be safely
    restarted, so do it for a day, shut it down and then restart it a
    few days later - that's fine. See the docs for more on that. Be
    sensitive to bitcoin network fees - these transactions are very
    large so they'll be more palatable at times when the network is
    clearing 1-5 sats/byte. However ...&lt;/li&gt;
&lt;li&gt;... mixing roles definitely has advantages. The more people mix
    roles the more unsafe it is to make deductions about which coinjoin
    output belonged to the taker, after it gets spent (consider what you
    can deduce about a coinjoin output which is then spent via an
    ordinary wallet, say to a t-shirt merchant).&lt;/li&gt;
&lt;li&gt;The maker role isn't useless for privacy, it's rather best to
    think of it as (a) limited and (b) taking a long time to have an
    effect. It's most suitable if your threat model is "I don't want
    a clear history of my coins over the long term". It also costs
    nothing monetarily and brings in some very small income if your size
    is large (if small, it's likely not worth mentioning) - but in that
    case, take your security seriously.&lt;/li&gt;
&lt;li&gt;Consider sizing when acting as a taker. We as a project should
    perhaps create more transparency around this, but you can gauge from
    your success in arranging big size coinjoins: if you can't easily
    find 6+ counterparties to do a coinjoin at a particular size, it may
    not be a good idea to rely on the outcomes, as you may be mixing in
    too small of a crowd (whether that's at 10 BTC or 20 BTC or 50+ BTC
    just depends on market condition).&lt;/li&gt;
&lt;li&gt;Make good use of (a) the accounts (mixdepths) feature, (b) the coin
    freeze feature and (c) the sweep feature (taker only). These three
    things allow you to better isolate coins going to different
    destinations - your cold wallet, your mobile spending wallet, an
    exchange etc etc. Accounts let you have the assurance that coins in
    one aren't linked with coins in another; you can't accidentally
    co-spend them. The freeze feature (see the "Coins" tab on Qt) lets
    you spend individual utxos, where that's important to you for some
    reason, without connection to others. And the sweep feature lets you
    make a coinjoin without any change, breaking a link to future
    transactions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We soon (in 0.7.0; the code is basically already done) hope to have more
helpful features, in particular Payjoin as defined in BIP 78, along with
very basic PSBT support.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="coinjoin"></category><category term="joinmarket"></category><category term="bitcoin"></category></entry><entry><title>Schnorrless Scriptless Scripts</title><link href="https://joinmarket.me/blog/blog/schnorrless-scriptless-scripts/" rel="alternate"></link><published>2020-04-15T00:00:00+02:00</published><updated>2020-04-15T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2020-04-15:/blog/blog/schnorrless-scriptless-scripts/</id><summary type="html">&lt;p&gt;a new ECDSA single-signer adaptor signature construction.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Schnorrless Scriptless Scripts&lt;/h3&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The weekend of April 4th-5th 2020 we had a remote "Lightning
Hacksprint" organized by the ever-excellent Fulmo, one Challenge was
related to "Payment Points" (see
&lt;a href="https://wiki.fulmo.org/index.php?title=Challenges#Point_Time_Locked_Contracts_.28PTLC.29"&gt;here&lt;/a&gt;;
see lots more info about the hacksprint at that wiki) and was based
around a new innovation recently seen in the world of adaptor
signatures. Work was led by Nadav Kohen of Suredbits and Jonas Nick of
Blockstream; the latter's API for the tech described below can be seen
currently as a PR to the secp256k1 project
&lt;a href="https://github.com/jonasnick/secp256k1/pull/14"&gt;here&lt;/a&gt;.
The output from Suredbits was a demo as show
&lt;a href="https://www.youtube.com/watch?v=w9o4v7Idjno&amp;amp;feature=youtu.be"&gt;here&lt;/a&gt;
on their youtube, a PTLC (point time locked contract, see their
&lt;a href="https://suredbits.com/payment-points-part-1/"&gt;blog&lt;/a&gt;
for more details on that).&lt;/p&gt;
&lt;p&gt;I will not focus here on either the proof of concept code, nor the
potential applications of this tech (which are actually many, not only
LN, but also Discreet Log contracts, various design of tumbler and
others), but entirely on the cryptography.&lt;/p&gt;
&lt;h2&gt;What you can do with Schnorr adaptors&lt;/h2&gt;
&lt;p&gt;Previous blog posts have covered in some detail the concept of adaptor
signatures, how they are simply realizable using the Schnorr signature
primitive. Also noted here and elsewhere is that there are techniques to
create the same effect using ECDSA signature, but involving considerable
additional crypto machinery (Paillier homomorphic encryption and certain
zero knowledge (range) proofs). This technique is laid out in
&lt;a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180426/fe978423/attachment-0001.pdf"&gt;this&lt;/a&gt;
brief note, fleshed out fully in
&lt;a href="https://eprint.iacr.org/2017/552"&gt;this&lt;/a&gt;
cryptographic construction from Lindell, paired with
&lt;a href="https://eprint.iacr.org/2018/472"&gt;this&lt;/a&gt;
paper on multihop locks (which represents a very important theoretical
step forward for Lightning channel construction). The problem with that
"tech stack" is the complexity in the Lindell construction, as
mentioned.&lt;/p&gt;
&lt;p&gt;A recent
&lt;a href="https://github.com/LLFourn/one-time-VES/blob/master/main.pdf"&gt;paper&lt;/a&gt;
by Lloyd Fournier represents a very interesting step forward, at least
in a certain direction: it allows "single signer" ECDSA adaptor
signatures. The scare quotes in the previous sentence represent the fact
that the use of such adaptor signatures would not literally be single
signer - it would be in the context of Bitcoin's &lt;code&gt;OP_CHECKMULTISIG&lt;/code&gt;,
most typically 2 of 2 multisig, so the same as the current
implementation of the Lightning network, in which a contract is enforced
by having funds controlled by both parties in the contract. Here, what
is envisaged is not a cooperative process to construct a single
signature (aggregated), but each party can individually create adaptor
signatures with signing keys they completely control. That this is
possible was a big surprise to me, and I think others will be unclear on
it too, hence this blog post after a week or so of study on my part.&lt;/p&gt;
&lt;p&gt;Let's remember that the Schnorr adaptor signature construction is:&lt;/p&gt;
&lt;p&gt;\(\sigma'(T, m, x) = k + H(kG+T||xG||m)x\)&lt;/p&gt;
&lt;p&gt;where \(k\) is the nonce, \(x\) is the private (signing) key and
\(T\) is the 'adaptor point' or just adaptor. The left-hand-side
parentheses are important: notice that &lt;strong&gt;you don't need the discrete
log of the point T to construct the adaptor signature&lt;/strong&gt;. But you &lt;em&gt;do&lt;/em&gt;
need the signing key \(x\). Or wait .. do you?&lt;/p&gt;
&lt;p&gt;As I explained last year
&lt;a href="https://x0f.org/web/statuses/102897691888130818"&gt;here&lt;/a&gt;
it's technically not the case: you can construct an adaptor signature
for signing pubkey \(P\) for which you don't know \(x\) s.t.
\(P=xG\), with a fly in the ointment: you won't be able to predict
the adaptor \(T\) or know its discrete log either (this makes it
un-dangerous, but still an important insight; I was calling this
"forgeability" but more on that later).&lt;/p&gt;
&lt;p&gt;How you ask? To summarize the mastodon post:&lt;/p&gt;
&lt;p&gt;\(\stackrel{\$}{\leftarrow} q, Q=qG, \quad \mathrm{assume}\quad
R+T =Q\)&lt;/p&gt;
&lt;p&gt;\(\Rightarrow \sigma' G= R + H(P,Q,m)P\)&lt;/p&gt;
&lt;p&gt;\(\stackrel{\$}{\leftarrow} \sigma' \quad \implies R = s'G -
H(P,Q,m)P \implies T = Q-R\)&lt;/p&gt;
&lt;p&gt;Thus anyone can publish an adaptor signature \((T, \sigma')\) on any
message \(m\) for any pubkey \(P\) at any time. It &lt;em&gt;really&lt;/em&gt; isn't a
signature.&lt;/p&gt;
&lt;p&gt;And equally obvious is that this does not allow the "forger" to
complete the adaptor into a full signature (\(\sigma = \sigma' +
t\)) - because if he could, this would be a way to forge arbitrary
Schnorr signatures!&lt;/p&gt;
&lt;p&gt;With the caveat in the above little mathematical vignette aside, we note
that the bolded phrase above is the crucial point: adaptors can be
created by non-secret owners, for secret owners to complete.&lt;/p&gt;
&lt;h2&gt;Adaptors in ECDSA with less wizardry&lt;/h2&gt;
&lt;p&gt;I was alerted to this trick via &lt;a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-November/002316.html"&gt;this mailing list
post&lt;/a&gt;
and the work of the Suredbits guys, in particular Nadav Kohen, who blogs
on payment points, DLCs and related topics
&lt;a href="https://suredbits.com/payment-points-part-1/"&gt;here&lt;/a&gt;.
The idea can be summarised as "tweak the nonce multiplicatively instead
of linearly". Take the following notation for the base (complete) ECDSA
signature:&lt;/p&gt;
&lt;p&gt;\(\sigma = k^{-1}\left(\mathbb{H}(m) + R_{\mathrm{x}}x\right)
\)&lt;/p&gt;
&lt;p&gt;Here we're using the most common, if sometimes confusing notation. As
usual \(k\) is the nonce (generated deterministically usually),
\(R=kG\), \(m\) is the message and \(x\) is the private signing
key whose public key by convention is \(P\). Meanwhile
\(R_{\mathrm{x}}\) indicates the x-coordinate of the curve point
\(R\), with the usual caveats about the difference between the curve
order and the order of the finite field from which the coordinates are
drawn (feel free to ignore that last part if it's not your thing!).&lt;/p&gt;
&lt;p&gt;Now clearly you cannot just add a secret value \(t\) to the nonce and
expect the signature \(\sigma\) to be shifted by some simple factor.
Multiplication looks to make more sense, since after all the nonce is a
multiplicative factor on the RHS. But it's not so simple, because the
nonce-&lt;em&gt;point&lt;/em&gt; appears as the term \(R_{\mathrm{x}}\) inside the
multiplied factor. The clever idea is how to get around this problem. We
start by defining a sort-of "pre-tweaked" nonce:&lt;/p&gt;
&lt;p&gt;\(R' = kG\)&lt;/p&gt;
&lt;p&gt;and then the real nonce that will be used will be multiplied by the
adaptor secret \(t\):&lt;/p&gt;
&lt;p&gt;\(R = kT = ktG\)&lt;/p&gt;
&lt;p&gt;Then the adaptor signature will be published as:&lt;/p&gt;
&lt;p&gt;\(\sigma' = k^{-1}\left(\mathbb{H}(m) + R_{\mathrm{x}}x\right)
\)&lt;/p&gt;
&lt;p&gt;... which may look strange as here the RHS is identical to what we
previously had for the &lt;em&gt;complete&lt;/em&gt; signature \(\sigma\). The
difference of course is that here, the terms \(k\) and \(R\) don't
match up; \(R\) has private key \(kt\) not \(k\). And hence we can
easily see that:&lt;/p&gt;
&lt;p&gt;\(\sigma = t^{-1} \sigma'\)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;will&lt;/em&gt; be a valid signature, whose nonce is \(kt\).&lt;/p&gt;
&lt;p&gt;However, we do not operate in a world without adversaries, so to be sure
of the statement "if I get given the discrete log of \(T\), I will be
able to construct a fully valid \(\sigma\)", we need a proof of that
claim. This is the key innovation, because this can be done &lt;em&gt;very&lt;/em&gt;
simply with a proof-of-discrete-log, or a "PoDLE" as was described in
one of the first &lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/poodle/"&gt;blog
posts&lt;/a&gt;
here. To prove that \(R'/G = R/T = k\), where we somewhat abuse / to
mean "elliptic curve discrete log", you just create an AND of two
\(\Sigma\)-protocols, using the same commitment (i.e., nonce), let's
call it \(k_2\) and output a schnorr style response \(s = k_2 +
ek\), where the hash e covers both points \(k_2 G\ ,\ k_2 T\) as
has been explained in the just-mentioned PoDLE blog post and also in a
bit more generality in the &lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/ring-signatures/"&gt;post on ring
signatures&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It's thus intuitive, though not entirely obvious, that an "adaptor
signature" in this context is really a combination of the same idea as
in Schnorr, but with additionally a PoDLE tacked-on:&lt;/p&gt;
&lt;p&gt;Input:&lt;/p&gt;
&lt;p&gt;an adaptor point \(T\), a message \(m\), a signing key \(x\)&lt;/p&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;p&gt;adaptor signature \((\sigma', R, R')\), adaptor signature PoDLE:
\((s, e)\)&lt;/p&gt;
&lt;p&gt;Verification for non-owner of adaptor secret \(T\):&lt;/p&gt;
&lt;p&gt;1. Verify the PoDLE - proves that \(R, R'\) have same (unknown)
discrete log w.r.t. \(T, G\) respectively.&lt;/p&gt;
&lt;p&gt;2. Verify \(\sigma' R' \stackrel{?}{=} \mathbb{H}(m) +
R_{\mathrm{x}} P\)&lt;/p&gt;
&lt;h2&gt;Swapping ECDSA coins with this method&lt;/h2&gt;
&lt;p&gt;Fundamentally, if not exclusively, adaptor signatures as originally
conceived, and still here, allow the swap of a coin for a secret (in
that broadcast of a spending transaction necessarily implies broadcast
of a signature which can be combined with a pre-existing adaptor
signature to reveal a secret), and the crudest example of how that can
be used is the coinswap or atomic swap, see
&lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/coinswaps/"&gt;these&lt;/a&gt;
&lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;previous&lt;/a&gt;
blog posts for a lot of detail on pre-existing schemes to do this, both
with and without the Schnorr signature primitive that was previously
thought to be near-required to do adaptor signatures.&lt;/p&gt;
&lt;p&gt;The ECDSA scheme above can be used in a slightly different way than I
had originally described for Schnorr adaptor signatures, but it appears
that was partly just oversight on my part: the technique described below
&lt;em&gt;can&lt;/em&gt; be used with Schnorr too. So the advantage here is principally
that we can do it right now.&lt;/p&gt;
&lt;p&gt;1. Alice spends into a 2/2 A1 B1 after first negotiating a timelocked
refund transaction with Bob, so she doesn't risk losing funds.&lt;/p&gt;
&lt;p&gt;2. Bob does the same, spending into a 2/2 A2 B2 after negotiating a a
timelocked refund tranasction with Alice, so he also doesn't risk, but
his timelock is closer.&lt;/p&gt;
&lt;p&gt;3. Alice creates an adaptor \(\sigma_{1}^{'}\) spending with key
A1 to Bob's destination and adaptor point \(T\) for which she knows
discrete log \(t\).&lt;/p&gt;
&lt;p&gt;4. Bob verifies \(\sigma_{1}^{'}\) and the associated data
mentioned above, including crucially the PoDLE provided.&lt;/p&gt;
&lt;p&gt;5. Bob creates an adaptor \(\sigma_{2}^{'}\) spending with key B2
to Alice's destination and adaptor point \(T\) for which he does
&lt;strong&gt;not&lt;/strong&gt; know the \(t\).&lt;/p&gt;
&lt;p&gt;6. Alice can now safely complete the adaptor she receives: \(\sigma_2
= t^{-1}\sigma_{2}^{'}\) and co-sign with A2 and broadcast,
receiving her funds.&lt;/p&gt;
&lt;p&gt;7. Bob can see on the blockchain (or communicated directly for
convenience): \(t = \sigma_{2}^{'}\sigma_{2}^{-1}\) and use it
to complete: \(\sigma_{1} = t^{-1}\sigma_{1}^{'}\), and co-sign
with B1 and broadcast, receiving his funds.&lt;/p&gt;
&lt;h3&gt;Comparisons to other coinswaps:&lt;/h3&gt;
&lt;p&gt;This requires 2/2 P1 P2 type scriptPubKeys; these can be p2sh multisig
or p2wsh multisig using, as mentioned, &lt;code&gt;OP_CHECKMULTISIG&lt;/code&gt;. Notice that
in a future Taproot/Schnorr world, this will still be possible, using
the linear style adaptor signatures previously described. However in
that case a musig-style combination of keys will almost certainly be
preferred, as it will create transaction styles that look
indistinguishable from single or any other script types. For now, the
system above does share one very valuable anonymity set: the set of
Lightning channel opens/closes, but doesn't share an anonymity set with
the full set of general single-owner ECDSA coins (which includes both
legacy and segwit).&lt;/p&gt;
&lt;p&gt;For now, this method has the principal advantage that the only failure
mode is the timelocked backout, which can be a transaction that looks
entirely normal - having a non-zero &lt;code&gt;nLockTime&lt;/code&gt; somewhere around the
current block is actually very normal. While the atomic enforcement part
is, just like Schnorr adaptors, entirely invisible. So apart from the
smaller anonymity set (2-2, so mostly LN), it has excellent privacy
properties.&lt;/p&gt;
&lt;h2&gt;Reframing adaptors \(\rightarrow\) otVES&lt;/h2&gt;
&lt;p&gt;The aforementioned
&lt;a href="https://github.com/LLFourn/one-time-VES/blob/master/main.pdf"&gt;paper&lt;/a&gt;
of 2019 by Lloyd Fournier is titled "&lt;em&gt;One Time Verifiably Encrypted
Signatures A.K.A. Adaptor Signatures&lt;/em&gt;" - at first this new name
(henceforth otVES) seemed a bit strange, but after reading the paper I
came away pretty convinced. Both the conceptual framework is very clean,
but also, this links back to earlier work on the general concept of
Verifiably Encrypted Signatures. Most particularly the work of the same
guys that brought us BLS signatures from bilinear pairing crypto, in
&lt;a href="http://crypto.stanford.edu/~dabo/papers/aggreg.pdf"&gt;this
paper&lt;/a&gt;
(namely, Boneh, Lynn, Shacham but also Gentry of FHE fame). The context
considered there was wildly different, as Fournier helpfully explains:
this earlier work imagined that Alice and Bob wanted to fairly exchange
signatures that might be useful as authorization for some purpose. To
achieve that goal, they imagined trusted third party acting between
them, and that an encrypted-to-third-party-adjudicator but still
&lt;em&gt;verifiable&lt;/em&gt; signature could serve as the first step of a fair protocol,
assuming honesty of that third party. However what makes the Bitcoin
use-case special is that signatures &lt;strong&gt;are useable if and only if
broadcast&lt;/strong&gt;&lt;em&gt;. &lt;/em&gt;All of this coinswap/HTLC/second layer stuff relies on
that property. In this scenario, having not only a VES but an otVES is
exactly desirable.&lt;/p&gt;
&lt;p&gt;Why is one-time desirable here? It's a little obtuse. For those
familiar with cryptography 101 it'll make sense to think about the &lt;a href="https://en.wikipedia.org/wiki/One-time_pad"&gt;one
time
pad&lt;/a&gt;.
The absolutely most basic concept of encryption (which also happens to
be perfectly secure, when considered in the most &lt;a href="https://en.wikipedia.org/wiki/Spherical_cow"&gt;spherical
cow&lt;/a&gt;
kind of way): take a plaintext \(p\) and a key \(k\), bitstrings of
the exact same length. Then make the ciphertext \(c\):&lt;/p&gt;
&lt;p&gt;\(c = p \oplus k\)&lt;/p&gt;
&lt;p&gt;and the thing about this that makes it perfect is exactly also something
that can be considered a "bug": the symmetry of the \(\oplus\)
(xor) operation is such that, given both the plaintext and the
ciphertext, the key can be derived: \(k = c \oplus p\). So any
broadcast of \(p\), after an earlier transfer of \(c\) (to Bob,
let's say), means that the secret key is revealed.&lt;/p&gt;
&lt;p&gt;The same is true in our adaptor signature or VES scenario: the adaptor
signature \(\sigma'\) is an "encrypted signature", and is
verifiable using the verification algorithm already discussed, by anyone
who has that encrypted signature and the adaptor "public key" which we
called \(T\). Notice how this is analogous to &lt;em&gt;public&lt;/em&gt; key encryption,
in that you only need a public key to encrypt; but also notice that the
one-time pad is &lt;em&gt;secret key &lt;/em&gt;encryption, which is why the plaintext and
ciphertext are enough to reveal the key (note: more developed secret key
algorithms than OTP handle this problem). This is some kind of hybrid of
those cases. Once the "plaintext" signature \(\sigma\) is revealed,
the holder of the "encrypted" signature \(\sigma'\) can derive the
private key: \(t\).&lt;/p&gt;
&lt;p&gt;So hopefully this makes clear why "one-time-ness" is not so much in
itself desirable, as what is implied by it: that the "private key"
(the &lt;em&gt;encryption&lt;/em&gt; key, not the &lt;em&gt;signing&lt;/em&gt; key, note!) is revealed on one
usage.&lt;/p&gt;
&lt;h2&gt;Security properties - deniability, forgeability, validity, recoverability ...&lt;/h2&gt;
&lt;p&gt;At a high level, what security properties do we want from these
"encrypted signatures''? I think there's a strong argument to focus
on two properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handing over such encrypted signatures should not leak any
    information to any adversary, including the recipient (it may or may
    not be needed to keep the transfer private, that is not considered
    in the model).&lt;/li&gt;
&lt;li&gt;Given an encrypted signature for a message and key, I should be able
    to convince myself that when the plaintext signature is revealed, I
    will get the secret key \(t\), or complementary: when the secret
    key \(t\) is revealed, I should be able to recover the plaintext
    signature.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll deal with both of these points in the following subsections.&lt;/p&gt;
&lt;h3&gt;Deniability&lt;/h3&gt;
&lt;p&gt;The Schnorr version of the otVES is deniable in the specific sense that
given an unencrypted signature, a corresponding encrypted signature for
any chosen key (\(t\)) can be claimed, as was explained
&lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;here&lt;/a&gt;
("Deniability" subsection). For anyone familiar with the basic
construction of zero knowledge proofs, this will be immediately
recognized as being the definition of a "Simulator", and therefore
proves that such an adaptor signature/encrypted signature leaks zero
information to recipients.&lt;/p&gt;
&lt;p&gt;It is interesting to observe that the same trick does &lt;strong&gt;not&lt;/strong&gt; work with
the ECDSA variant explained above:&lt;/p&gt;
&lt;p&gt;Given \(\sigma, R\) satisfying \(\sigma R = \mathbb{H}(m)G +
R_{\mathrm{x}}P\) for the verifying pubkey \(P\), you can try to
assert that \(k = tk_2\) but &lt;strong&gt;you have no way to generate a PoDLE for
\(R, R'\) if you don't know k&lt;/strong&gt; - this means that such a
"retrofitted" encrypted signature (which by definition &lt;em&gt;includes&lt;/em&gt; the
PoDLE) is not possible for a party not knowing the original secret
nonce, and thus the simulator argument (the argument that an external
observer &lt;em&gt;not knowing the secret&lt;/em&gt; can create fake transcripts with a
distribution indistinguishable from the real transcripts) is not
available, hence we cannot claim that such encrypted signatures are
fully zero knowledge. More on this shortly.&lt;/p&gt;
&lt;h3&gt;Forgeability&lt;/h3&gt;
&lt;p&gt;I am abusing terms here, because unforgeability is the central property
of a valid signature scheme, but here let's talk about the forgeability
of an &lt;em&gt;encrypted&lt;/em&gt; signature, so perhaps "adaptor forgeability". Here I
mean the ability to create arbitrary encrypted signatures &lt;em&gt;without&lt;/em&gt; the
signing key. This was demonstrated as possible for Schnorr in the first
section of this blog post (noting the obvious caveat!). For ECDSA, we
hit the same snag as for 'Deniability'. Without possessing the signing
key \(x\), you want to make the verification \(\sigma' R' =
\mathbb{H}(m)G + R_{\mathrm{x}}P\) pass for some \(R, R', T, R =
tR'\) such that you can prove DLOG equivalence w.r.t. \(G, T\). You
can do this by "back-solving" the same way as for Schnorr:&lt;/p&gt;
&lt;p&gt;\(\stackrel{\$}{\leftarrow} k^{*}, R=k^{*}G, \quad Q =
\mathbb{H}(m)G + R_{\mathrm{x}}P\)&lt;/p&gt;
&lt;p&gt;\(\stackrel{\$}{\leftarrow} \sigma', \quad \Rightarrow \sigma'
R' = Q \Rightarrow R' = (\sigma')^{-1}Q\)&lt;/p&gt;
&lt;p&gt;But since this process did &lt;em&gt;not&lt;/em&gt; allow you to deduce the scalar \(q\)
s.t. \(Q = qG\), it did not allow you to deduce the corresponding
scalar for \(R'\). Thus you can output a set \(\sigma', R, R'\)
but you cannot also know, and thus prove equivalence of, the discrete
logs of \(R\) and \(R'\).&lt;/p&gt;
&lt;p&gt;The previous two sections demonstrate clearly that the otVES
construction for ECDSA is fundamentally different from that for Schnorr
in that it requires providing, and proving a relationship between two
nonces, and this also impacts quite significantly the security arguments
that follow.&lt;/p&gt;
&lt;h3&gt;Validity, Recoverability&lt;/h3&gt;
&lt;p&gt;These are aspects of the same thing, so grouped together, and they talk
about the most central and unique property for an otVES scheme, but
fortunately it is almost tautological to see that they hold for these
schemes.&lt;/p&gt;
&lt;p&gt;The concern it addresses: what if Alice gave Bob an encrypted signature
to a key \(T\) but it turned out that when decrypted with the
corresponding key \(t\), a valid signature wasn't actually revealed.
That this is impossible is called &lt;strong&gt;validity&lt;/strong&gt;. The flip side is
&lt;strong&gt;recoverability&lt;/strong&gt;: if Alice gave Bob an encrypted signature and then
published the corresponding decrypted signature ("plaintext"), the
secret key for the encryption (\(t\)) must be revealed.&lt;/p&gt;
&lt;p&gt;The Schnorr case illustrates the point clearly, see Lemma 4.1 in
Fournier's paper; \(\sigma' = \sigma -t\) in our notation and we
can see by the definition of Schnorr signature verification that this
must hold, given there cannot be another \(t' \ne t\) s.t. \(t'G =
T\) (there is a one-one mapping between scalars mod n and group
points). Recoverability is also unconditionally true in the same way.&lt;/p&gt;
&lt;p&gt;For the ECDSA case, it is nearly the same, except: we rely on the PoDLE
between \(R, R'\), which has the same properties itself as a Schnorr
signature, and so the properties hold conditional on the inability to
break ECDLP (because that would allow Schnorr forgery, and thus PoDLE
forgery).&lt;/p&gt;
&lt;p&gt;Note how a ECDLP break can obviously destroy the usefulness of all these
schemes, in particular the underlying signature schemes, but even that
does not alter the fact that the Schnorr encrypted signature is valid
and recoverable (though it becomes a mere technicality in that case).&lt;/p&gt;
&lt;h3&gt;EUF-CMA for otVES using Schnorr&lt;/h3&gt;
&lt;p&gt;EUF-CMA was discussed in the previous blogs on the Schnorr signature and
on ring signatures, in brief it is a technical term for "this signature
scheme is secure in that signatures cannot be forged by
non-secret-key-owners under this specific set of (fairly general)
assumptions".&lt;/p&gt;
&lt;p&gt;Proving this for the Schnorr otVES turns out to be a fairly standard
handle-cranking exercise. This is essentially what I have focused on in
previous work as "proving soundness by running an extractor",
including patching up the random oracle. See the above linked post on
the Schnorr signature for more detail.&lt;/p&gt;
&lt;p&gt;Note that unforgeability referred to here &lt;strong&gt;is not the same as "adaptor
forgeability" discussed above&lt;/strong&gt;. Here we are specifically trying to
prove that access to such encrypted signatures does not help the
adversary in his pre-existing goal of forging &lt;em&gt;real &lt;/em&gt;signatures.&lt;/p&gt;
&lt;p&gt;So the handle-cranking simply involves adding an "encrypted signature
oracle" to the attacker's toolchest. EUF-CMA[VES] basically refers
to the inability to create signatures on new messages even when you have
access to arbitrary encrypted signatures, as well as arbitrary earlier
&lt;em&gt;complete&lt;/em&gt; signatures, again, on different messages.&lt;/p&gt;
&lt;p&gt;As Fournier points out here:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;EUF-CMA[VES] says nothing about the unforgeability of signature
encryptions. In fact, an adversary who can produce valid VES
ciphertexts without the secret signing key is perfectly compatible. Of
course, they will never be able to forge a VES ciphertext under a
particular encryption key. If they could do that, then they could
trivially forge an encrypted signature under a key for which they know
the decryption key and decrypt it.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;... which is the reason for my (I hope not too confusing) earlier
section on "adaptor forgeability". It &lt;em&gt;is&lt;/em&gt; actually possible, for
Schnorr, but not ECDSA, to do what is mentioned in the second sentence
above.&lt;/p&gt;
&lt;h3&gt;EUF-CMA[VES] for ECDSA&lt;/h3&gt;
&lt;p&gt;Here is the most technical, but the most important and difficult point
about all this. In producing an encrypted ECDSA signature you output:&lt;/p&gt;
&lt;p&gt;\((\sigma', R, R', m, P), \quad \textrm{DLEQ}(R, R')\)&lt;/p&gt;
&lt;p&gt;(while \(m, P\) may be implicit of course), and this means you output
one piece of information in addition to the signature: that two nonce
points are related in a specific way. It turns out that this can be
expressed differently as the Diffie Hellman key of the key pair \((P,
T)\) (or, in Fournier's parlance, the signing key and the encryption
key). That DH key would be \(tP = xT = xtG\). Here's how; starting
from the verification equation for a published encrypted signature,
using the notation that we've used so far:&lt;/p&gt;
&lt;p&gt;\(s'R' = \mathbb{H}(m) + R_{\mathrm{x}}P\)&lt;/p&gt;
&lt;p&gt;isolate the public key P (this is basically "pubkey recovery"):&lt;/p&gt;
&lt;p&gt;\(P = R_{\mathrm{x}}^{-1}\left(s'R' - \mathbb{H}(m)G\right)\)&lt;/p&gt;
&lt;p&gt;\(\Rightarrow tP = R_{\mathrm{x}}^{-1}\left(s'tR' -
\mathbb{H}(m)tG\right)\)&lt;/p&gt;
&lt;p&gt;\(\Rightarrow xT = tP = R_{\mathrm{x}}^{-1}\left(s'R -
\mathbb{H}(m)T\right)\)&lt;/p&gt;
&lt;p&gt;Notice how we - a verifier, not possessing either the nonce \(k\) nor
the secret \(t\) - were able to deduce &lt;em&gt;this&lt;/em&gt; DH key because we knew
the DH key of the key pair \((R', T)\) - it's \(R\), which we were
explicitly given. So this, in some sense "breaks" the &lt;a href="https://en.wikipedia.org/wiki/Computational_Diffie%E2%80%93Hellman_assumption"&gt;CDH
assumption&lt;/a&gt;:
that given only points on the curve \(A=aG, B=bG\) you should not be
able to calculate the third point \(abG\) (but "breaks" - because
actually we were given a related DH key to start with).&lt;/p&gt;
&lt;p&gt;Fournier addresses this point in two ways. First, he argues that
requirement of the CDH problem being hard is not part of the protocols
for which this scheme is useful and that keys are by design one-time-use
in these applications. The more important point though, is that an
attempt is made to show the scheme secure &lt;strong&gt;if the CDH problem is
easy&lt;/strong&gt;. A classic example of backwards cryptography logic ;)&lt;/p&gt;
&lt;p&gt;The framework for this is non-trivial, and it is exactly the framework
developed by Fersch et al that was discussed in the section on ECDSA in
&lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/"&gt;this&lt;/a&gt;
earlier blog post (subsection "What about ECDSA?"). I have not studied
this framework in any detail, only cursorily, and would encourage anyone
interested to at least watch the linked video of Fersch's talk on it,
which was quite interesting. With the addition of the assumption "CDH
is easy", Fournier claims that ECDSA can be said to have this
EUF-CMA[VES] security guarantee, which is intended to prove,
basically, that &lt;strong&gt;the leak of the DH key is the only leak of information
and that the scheme is secure against forgery&lt;/strong&gt;. I can't claim to be
able to validate this; I can only say the argument appears plausible.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="cryptography"></category><category term="bitcoin"></category></entry><entry><title>Ring Signatures</title><link href="https://joinmarket.me/blog/blog/ring-signatures/" rel="alternate"></link><published>2019-02-28T00:00:00+01:00</published><updated>2019-02-28T00:00:00+01:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2019-02-28:/blog/blog/ring-signatures/</id><summary type="html">&lt;p&gt;construction of several different ring signatures relevant to Bitcoin.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Ring signatures&lt;/h3&gt;
&lt;h2&gt;Outline:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Basic goal of 1-of-\(N\) ring signatures&lt;/li&gt;
&lt;li&gt;Recap: the \(\Sigma\)-protocol&lt;/li&gt;
&lt;li&gt;OR of \(\Sigma\)-protocols, CDS 1994&lt;/li&gt;
&lt;li&gt;Abe-Ohkubo-Suzuki (AOS) 2002 (broken version)&lt;/li&gt;
&lt;li&gt;Security weaknesses&lt;/li&gt;
&lt;li&gt;Key prefixing&lt;/li&gt;
&lt;li&gt;Borromean, Maxwell-Poelstra 2015&lt;/li&gt;
&lt;li&gt;Linkability and exculpability&lt;/li&gt;
&lt;li&gt;AND of \(\Sigma\)-protocols, DLEQ&lt;/li&gt;
&lt;li&gt;Liu-Wei-Wong 2004&lt;/li&gt;
&lt;li&gt;Security arguments for the LWW LSAG&lt;/li&gt;
&lt;li&gt;Back 2015; compression, single-use&lt;/li&gt;
&lt;li&gt;Fujisaki-Suzuki 2007 and Cryptonote 2014&lt;/li&gt;
&lt;li&gt;Monero MLSAG&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Basic goal of 1-of-\(N\) ring signatures&lt;/h2&gt;
&lt;p&gt;The idea of a &lt;a href="https://en.wikipedia.org/wiki/Ring_signature"&gt;ring
signature&lt;/a&gt;
(the term itself is a bit sloppy in context, but let's stick with it
for now) is simple enough:&lt;/p&gt;
&lt;p&gt;An owner of a particular private key \(x\) signs a message \(m\) by
taking, usually without setup or interaction, a whole set of public
keys, one of which is his (\(P=xG\)), and forms a signature (exact
form unspecified) such that there is proof that &lt;strong&gt;at least one&lt;/strong&gt; of the
private keys is known to the signer, but which one was responsible for
the signature is not known by the verifier, and not calculatable.&lt;/p&gt;
&lt;p&gt;Obviously that's pretty vague but captures the central idea. We often
use the term "ring" because the construction must have some symmetry
over the entire set of \(n\) public keys, and a ring/circle represents
symmetry of an arbitrarily high order (limit of an \(n\)-gon). Less
abstractly it could be a good name because of some "loop"-ing aspect
of the algorithm that constructs the signature, as we'll see.&lt;/p&gt;
&lt;p&gt;What properties do we want then, in summation?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unforgeability&lt;/li&gt;
&lt;li&gt;Signer ambiguity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We may want additional properties for some ring signatures, as we'll
see.&lt;/p&gt;
&lt;p&gt;In the following sections I want to cover some of the key conceptual
steps to the kinds of ring signatures currently used in cryptocurrency
protocols; most notably Monero, but also several others; and also in the
Confidential Transactions construction (see: Borromean ring signatures,
briefly discussed here). I will also discuss security of such
constructions, in much less detail than the &lt;a href="https://web.archive.org/web/20200713230948/https://joinmarket.me/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/"&gt;previous
blog&lt;/a&gt;
(on the security of Schnorr signatures), but showing how there are
several tricky issues to be dealt with, here.&lt;/p&gt;
&lt;h2&gt;Recap: the \(\Sigma\)-protocol&lt;/h2&gt;
&lt;p&gt;We consider a prover \(\mathbb{P}\) and a verifier \(\mathbb{V}\).&lt;/p&gt;
&lt;p&gt;A \(\Sigma\)-protocol is a three step game, in which the prover
convinces the verifier of something (it can be \(\mathbb{P}\)'s
knowledge of a secret, but it can also be something more complicated),
in zero knowledge. Readers interested in a much more detailed discussion
of the logic behind this and several applications of the idea can read
Sections 3 and 4 of my &lt;a href="https://github.com/AdamISZ/from0k2bp"&gt;From Zero (Knowledge) to
Bulletproofs&lt;/a&gt;
writeup, especially section 4.1.&lt;/p&gt;
&lt;p&gt;In brief, the three step game is:&lt;/p&gt;
&lt;p&gt;\(\mathbb{P} \rightarrow \mathbb{V}\): &lt;strong&gt;commitment&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\(\mathbb{V} \rightarrow \mathbb{P}\): &lt;strong&gt;challenge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\(\mathbb{P} \rightarrow \mathbb{V}\): &lt;strong&gt;response&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A few minor notes on this: obviously the game is not literally over with
the response step; the verifier will examine the response to establish
whether it is valid or invalid.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;commitment&lt;/strong&gt; will usually in this document be written \(R\) and
will here always be a point on an elliptic curve, which the prover may
(or may not! in these protocols) know the corresponding scalar multiple
(private key or nonce) \(k\) such that \(R=kG\).&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;challenge&lt;/strong&gt; will usually be written \(e\) and will usually be
formed as the hash of some transcript of data; the subtleties around
exactly &lt;em&gt;what&lt;/em&gt; is hashed can be vitally important, as we'll see. (This
is in the "Fiat-Shamir transform" case; we discussed the pure
interactive challenge case a bit in the previous blog and many other
places!)&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;response&lt;/strong&gt; will usually be a single scalar which will usually be
denoted \(s\).&lt;/p&gt;
&lt;p&gt;We will be playing with this structure a lot: forging transcripts \(R,
e, s\); running multiple instances of a \(\Sigma\)-protocol in
parallel and performing logical operations on them. All of this will
play out &lt;em&gt;mostly&lt;/em&gt; in the form of a Schnorr signature; again, refer to
previous blog posts or elementary explanations (including those written
by me) for more on that.&lt;/p&gt;
&lt;h2&gt;OR of \(\Sigma\)-protocols, CDS 1994&lt;/h2&gt;
&lt;p&gt;Let's start with the OR of \(\Sigma\)-protocols. I &lt;em&gt;believe&lt;/em&gt; this
solution is due to &lt;a href="https://link.springer.com/content/pdf/10.1007%2F3-540-48658-5_19.pdf"&gt;Cramer, Damgård and Schoenmakers
'94&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(Historical note: the "believe" is because I've seen it cited to that
paper (which is famous for good reason, I guess); but in the paper they
actually attribute &lt;em&gt;this specific idea&lt;/em&gt; to "M. Ito, A. Saito, and T.
Nishizeki: Secret Sharing Scheme realizing any Access Structure, Proc.
Glob.Com. (1987)" ; unfortunately I can't find that on the 'net).&lt;/p&gt;
&lt;p&gt;It is also described, with a brief discussion of its security proof, in
&lt;a href="https://crypto.stanford.edu/~dabo/cryptobook/BonehShoup_0_4.pdf"&gt;Boneh-Shoup&lt;/a&gt;
Sec 19.7.2.&lt;/p&gt;
&lt;p&gt;This is not, as far as I know, used at all(?) nor that widely discussed,
but it is in some sense the most simple and logical way to get a 1 out
of \(N\) ring signature; use the XOR (\(\oplus\)) operation:&lt;/p&gt;
&lt;p&gt;We have in advance a set of public keys \(P_i\). We only know one
private key for index \(j\), \(x_j\).&lt;/p&gt;
&lt;p&gt;We'll now use a standard three move \(\Sigma\)-protocol to prove
knowledge of &lt;strong&gt;at least one key&lt;/strong&gt; without revealing which index is
\(j\).&lt;/p&gt;
&lt;p&gt;We're going to fake the non-\(j\)-index signatures in advance. Choose
\(s_i \stackrel{\$}{\leftarrow} \mathbb{Z}_N\ ,\ e_i
\stackrel{\$}{\leftarrow} \mathbb{Z}_N \quad \forall i \neq j\).&lt;/p&gt;
&lt;p&gt;Calculate \(R_i = s_iG - e_iP_i \quad \forall i \neq j\).&lt;/p&gt;
&lt;p&gt;For the real signing index, \(k_j \stackrel{\$}{\leftarrow}
\mathbb{Z}_N\ ,\quad R_j = k_jG\).&lt;/p&gt;
&lt;p&gt;We now have the full set of commitments: \((R_i \ \forall i)\)&lt;/p&gt;
&lt;p&gt;Now for the clever part. In an interactive \(\Sigma\)-protocol, we
would at this point receive a random challenge \(e \in
\mathbb{Z}_N\). For the Fiat Shamir transformed case,
noninteractively (as for  a signature), we use the constructed
\(R\)-values as input to a hash function, i.e. \(e = H(m||R_i
\ldots)\). We have already set the non-signing index \(e\)-values,
for the signing index we set \(e_j = e \oplus (\bigoplus_{i \ne
j}{e_i})\).&lt;/p&gt;
&lt;p&gt;This allows us to calculate \(s_j = k_j + e_j x_j\), and we now have
the full set of 'responses' for all the \(\Sigma\)-protocols:
\(s_i \ \forall i\). (but here we are using Fiat Shamir, so it's
not actually a response).&lt;/p&gt;
&lt;p&gt;By working this way we have ensured that the signature verifier can
verify that the logical XOR of the three \(e\)-values is equal to the
Fiat Shamir based hash-challenge, e.g. for the case of three
"signatures", we will have:&lt;/p&gt;
&lt;p&gt;\(e = e_1 \oplus e_2 \oplus e_3 \stackrel{?}{=}
H(m||R_0||R_1||...)\)&lt;/p&gt;
&lt;p&gt;where the verifier would calculate each \(R_i\) as \(s_iG -
e_iP_i\).&lt;/p&gt;
&lt;p&gt;The excellent feature of this of course is that it is perfectly hidden
which of the three indexes was genuine. But the bad news is that the
protocol as stated, used let's say as a signature scheme, requires
about twice as many field elements as members of the group of signers.
The verifier needs to be given \((s_1, \ldots s_n),(e_1 \ldots
e_n)\).&lt;/p&gt;
&lt;p&gt;Another excellent feature: this is not restricted to the Schnorr ID
protocol. It can work with another identity protocol, and even better,
it could work with a &lt;em&gt;mix&lt;/em&gt; of them; they only have to share the one
challenge \(e\).&lt;/p&gt;
&lt;h2&gt;Abe-Ohkubo-Suzuki (AOS) 2002 (broken version)&lt;/h2&gt;
&lt;p&gt;This is an excellent
&lt;a href="https://www.iacr.org/cryptodb/archive/2002/ASIACRYPT/50/50.pdf"&gt;paper&lt;/a&gt;
generally, but its stand-out contribution, in this context, is a &lt;strong&gt;more
compact&lt;/strong&gt; version of the 1 of n ring signature above. To clarify here,
both this and the previous are \(O(n)\) where \(n\) is the group
size, so "much more compact" is about the constant factor (scale not
scaling!); we reduce it from roughly 2 to roughly 1.&lt;/p&gt;
&lt;p&gt;"Broken version" - here I'll present a slightly simpler form than the
one in the paper, and then explain the serious problem with it - which I
hope will be productive. &lt;strong&gt;Please don't mistake this as meaning that
the AOS design was broken, it was never presented like this in the
paper!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Anyway, I think the best explanation for what's going on here
conceptually is due to A. Poelstra in the &lt;a href="https://github.com/Blockstream/borromean_paper"&gt;Borromean ring signatures
paper&lt;/a&gt;,
particularly Section 2 ; the reference to time travel may seem whimsical
but it gets to the heart of what's going on here; it's about having a
simulated form of causality with one way functions, and then violating
that.&lt;/p&gt;
&lt;p&gt;In short: creating an ordinary Schnorr sig without the key (i.e.
forging) is impossible because, working at the curve point level of the
equation (\(sG = R + H(m||R)P\)), you need to know the hash value
before you can calculate \(R\), but you need to know the value of
\(R\) before you can calculate the hash. So we see that two one way
functions are designed to conflict with one another; only by removing
one of them (going from curve points to scalar eqn: (\(s = k +
H(m||kG)x\)), can we now create a valid \(s, R, m\) set.&lt;/p&gt;
&lt;p&gt;To achieve that goal over a set of keys, we can make that "simulated
causality enforcement" be based on the same principle, but over a set
of equations instead of one. The idea is to make the commitment
\(H(m||R)\) use the \(R\) value from the "previous"
signer/key/equation, where "previous" is modulo \(N\), i.e. there is
a loop of dependencies (a ring, in fact).&lt;/p&gt;
&lt;p&gt;[Quick description:]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;Our goal is a list of \(N\) correctly verifying Schnorr signature
equations, with the tweak as mentioned that each hash-value refers to
the "previous" commitment. We will work with \(N=4\) and index from
zero for concreteness. Our goal is:&lt;/p&gt;
&lt;p&gt;\(s_0 G = R_0 + H(m||R_3)P_0\)&lt;/p&gt;
&lt;p&gt;\(s_1 G = R_1 + H(m||R_0)P_1\)&lt;/p&gt;
&lt;p&gt;\(s_2 G = R_2 + H(m||R_1)P_2\)&lt;/p&gt;
&lt;p&gt;\(s_3 G = R_3 + H(m||R_2)P_3\)&lt;/p&gt;
&lt;p&gt;Again for concreteness, we imagine knowing specifically the private key
\(x_2\) for index 2, only. We can successfully construct the above,
but only in a certain sequence:&lt;/p&gt;
&lt;p&gt;Choose \(k_2 \stackrel{\$}{\leftarrow} \mathbb{Z}_N,\ R_2 =
k_2G\), choose \(s_3 \stackrel{\$}{\leftarrow} \mathbb{Z}_N\).&lt;/p&gt;
&lt;p&gt;\(\Rightarrow R_3 = s_3 G - H(m||R_2)P_3\). Now choose \(s_0
\stackrel{\$}{\leftarrow} \mathbb{Z}_N\).&lt;/p&gt;
&lt;p&gt;\(\Rightarrow R_0 = s_0 G - H(m||R_3)P_0\). Now choose \(s_1
\stackrel{\$}{\leftarrow} \mathbb{Z}_N\).&lt;/p&gt;
&lt;p&gt;\(\Rightarrow R_1 = s_1 G - H(m||R_0)P_1\).&lt;/p&gt;
&lt;p&gt;Last, do not choose but &lt;strong&gt;calculate&lt;/strong&gt; \(s_2\): it must be \(s_2 = k_2
+ H(m||R_1)x_2\).&lt;/p&gt;
&lt;p&gt;After this set of steps, the set of data: \(e_0, s_0, s_1, s_2, s_3\)
can be verified without exposing which private key was known. Here is
the verification:&lt;/p&gt;
&lt;p&gt;Given \(e_0, s_0\), reconstruct \(R_0 = s_0G -e_0P_0\).&lt;/p&gt;
&lt;p&gt;\(\Rightarrow e_1 =H(m||R_0)\ ,\ R_1 = s_1 G - e_1P_1\)&lt;/p&gt;
&lt;p&gt;\(\Rightarrow e_2 =H(m||R_1)\ ,\ R_2 = s_2 G - e_2P_2\)&lt;/p&gt;
&lt;p&gt;\(\Rightarrow e_3 =H(m||R_2)\ ,\ R_3 = s_3 G - e_3P_3\)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Check&lt;/strong&gt;: \(e_0 \stackrel{?}{=} H(m||R_3)\).&lt;/p&gt;
&lt;h3&gt;Security weaknesses&lt;/h3&gt;
&lt;p&gt;The description above can't be described as secure.&lt;/p&gt;
&lt;p&gt;To give a hint as to what I mean: is there something &lt;strong&gt;not completely
fixed&lt;/strong&gt; in the above construction? Maybe an issue that's not even
specific to the "ring" construction, but even for any one of the
signature equations?&lt;/p&gt;
&lt;p&gt;....&lt;/p&gt;
&lt;p&gt;The answer is the keys, \(P_i\). We can in the most general case
consider three scenarios, although there may be some gray areas between
them:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Key(s) fixed in advance: \(P_1 \ldots P_N\) are all specified
    before doing anything, and not allowed to change by the verifier.
    Every signature must be on that set of keys.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;set&lt;/em&gt; &lt;em&gt;of possible keys&lt;/em&gt; is fixed in advance exactly as
    described above, but the &lt;em&gt;set of keys used in the ring&lt;/em&gt; is chosen by
    the signer, dynamically, in signing oracle queries or forgery
    attempts.&lt;/li&gt;
&lt;li&gt;Even the set of possible keys is dynamic. That is to say, any valid
    curve point (for EC case) is a valid potential key in (ring)
    signature.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is not a full taxonomy of possible attack scenarios, either. Not
only must we consider the difference between EUF-CMA and SUF-CMA as was
discussed in the previous blog (a reminder: with SUF, a forger should
not be able to even create a second signature on the same message -
ECDSA doesn't have this in naive form), but much more: we must also
consider which of the above three key settings applies.&lt;/p&gt;
&lt;p&gt;Even outside of ring signature settings, just considering a large scale
deployment of a signature scheme across millions or billions of keys,
could mean that the difference between these cases really matters. In
&lt;a href="https://eprint.iacr.org/2015/996"&gt;this&lt;/a&gt;
paper by Dan Bernstein the term MU-UF-CMA is used to refer to the
"multi-user" setting for this, where only single-key signatures are
used but one must consider whether having billions of other keys and
signing oracles for them might impact the security of &lt;strong&gt;any one&lt;/strong&gt; key
(notice the huge difference between "I want to forge on \(P\)" and
"I want to forge on any existing key" is, in this scenario).&lt;/p&gt;
&lt;p&gt;So enough about settings, what exactly constitutes a security problem
with the above version of the AOS ring sig?&lt;/p&gt;
&lt;p&gt;Consider any one element in the ring like:&lt;/p&gt;
&lt;p&gt;\(s_0 = R_0 + H(m||R_3)P_0\)&lt;/p&gt;
&lt;p&gt;where, for concreteness, I choose \(n=4\) and look at the first of 4
signature equations. Because of Schnorr's linearity (see &lt;a href="https://web.archive.org/web/20200713230948/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;this earlier
blog
post&lt;/a&gt;
for some elucidations on the &lt;em&gt;advantage&lt;/em&gt; of this linearity, although it
was also noted there that it had concomitant dangers (worse,
actually!)), there are two obvious ways we could tweak this equation:&lt;/p&gt;
&lt;p&gt;(1) Tweaked \(s\) values on fixed message and tweaked keys:&lt;/p&gt;
&lt;p&gt;Choose \(\alpha \in \mathbb{Z}_N\) and set \(s' = s_0
+\alpha\). We will not alter \(R=kG\), but we alter \(P_0
\rightarrow P_0 + e_0\^{-1}\alpha G\). This makes the verification
still work &lt;strong&gt;without altering the fixing of the nonce in the hash value
\(e_0\):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\(s_0 G + \alpha G = R_0 + e_0 P_0 + \alpha G = R_0 + e_0\left(P_0 +
e_0\^{-1}\alpha G\right)\)&lt;/p&gt;
&lt;p&gt;So it's really not clear how bad this failing is; it's &lt;em&gt;kinda&lt;/em&gt; a
failure of strong unforgeability, but that notion doesn't precisely
capture it: we created a new, valid signature against a
[new]{style="text-decoration: underline;"} key, but with two severe
limitations: we weren't able to alter the message, and also, we
weren't able to &lt;em&gt;choose&lt;/em&gt; the new key \(P'\). That last is slightly
unobvious, but crucial : if I have a pre-prepared \(P\^{*}\), I
cannot choose \(\alpha\) to get \(P' = P\^{*}\) as that would
require a discrete logarithm break.&lt;/p&gt;
&lt;p&gt;A final statement, hopefully obvious: the above can apply to any and all
of the elements of the ring, so the forgery could consist of an entirely
different and random set of keys, not related to the starting set; but
the message would be the same, as would the \(R\) values.&lt;/p&gt;
&lt;p&gt;(2) Completely different messages on tweaked keys, with the same
signature&lt;/p&gt;
&lt;p&gt;This one is almost certainly more important. Algebraically, we here
allow alterations to the \(e\) values, using multiplication rather
than addition:&lt;/p&gt;
&lt;p&gt;Given the same starting \(s_0\) as in (1), we take a chosen new
message \(m\^{*}\) and calculate the new \(e\^{*} =
H(m\^{*}||R_3)\). If we likewise tweak the public key we get that
\(s_0, R_0\) is a valid signature on the new message, with the tweaked
key:&lt;/p&gt;
&lt;p&gt;\(s_0 G = R_0 + e_0\^{*}\left(\frac{e_0}{e_0\^{*}} P_0\right)\)&lt;/p&gt;
&lt;p&gt;We can see here that this produces a forgery with the same signature
values (but different hash values) on the new keys.&lt;/p&gt;
&lt;p&gt;Most definitions of security against forgery require the attacker to
create a signature on a not-previously-queried message - so this &lt;em&gt;is&lt;/em&gt; a
successful attack, by most measures.&lt;/p&gt;
&lt;p&gt;However it does share the same limitation with (1) mentioned above -
that you cannot "control" the keys on which you get a signature,
unless you know a relative discrete log between one of the existing keys
and your new key, which implies you knew the secret key of the first (in
which case all this is pointless; whenever you have a private key, there
is no forgery on it).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;All of this should make very clear the reason why the real AOS (see
Section 5.1 of the paper) discrete-log ring signature fixes the entire
set of keys inside the hash, i.e. \(e_i = H(m || R_{(i-1)\%n}||
P_0 \ldots P_{n-1})\).&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Key Prefixing&lt;/h3&gt;
&lt;p&gt;The method in the previous bolded sentence is sometimes called
"key-prefixing". One way of looking at it: the Fiat-Shamir transform
that takes the Identity Protocol into a signature scheme, should hash
the conversation transcript between the prover and verifier, previous to
the challenge step; by including the public keys in this hash, we are
treating the keyset as part of the conversation transcript, rather than
something ex-protocol-run.&lt;/p&gt;
&lt;p&gt;Also, the discussion above (both cases (1) and (2)) show clearly that
the same weakness exists for a single (\(n=1\)) key case.&lt;/p&gt;
&lt;p&gt;[And yet, for the single key case, it was not a done deal historically -
this caused real world arguments!]{style="text-decoration: underline;"}.
After all, there are many use cases where the key &lt;em&gt;is&lt;/em&gt; a given
ex-protocol-run, plus there may be some practical disadvantage to doing
the key-prefixing.&lt;/p&gt;
&lt;p&gt;In
&lt;a href="https://rd.springer.com/chapter/10.1007%2F978-3-662-53008-5_2"&gt;this&lt;/a&gt;
paper from CRYPTO-2016, the controversy arising out of this is
elucidated, showing that these theoretical concerns had very substantial
impact on arguably the largest real world crypto usage (TLS):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"Key-prefixing comes with the disadvantage that the entire public-key
has to\
be available at the time of signing. Specifically, in a CFRG message
from Sep-\
tember 2015 Hamburg [32] argues "having to hold the public key along
with\
the private key can be annoying" and "can matter for constrained
devices".\
Independent of efficiency, we believe that a cryptographic protocol
should be\
as light as possible and prefixing (just as any other component)
should only\
be included if its presence is justified. Naturally, in light of the
GMLS proof,\
Hamburg [32] and Struik [44] (among others) recommended against
key prefixing\
for Schnorr. Shortly after, Bernstein [10] identifies the error in
the GMLS theo-\
rem and posts a tight security proof for the key-prefixed variant of
Schnorr signa-\
tures. In what happens next, the participant of the CFRG mailing list
switched\
their minds and mutually agree that key-prefixing should be preferred,
despite of\
its previously discussed disadvantages. Specifically, Brown writes
about Schnorr\
signatures that "this justifies a MUST for inclusion of the public key
in the mes-\
sage of the classic signature" [16]. As a consequence, key-prefixing
is contained in\
the current draft for EdDSA [33]..."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Technical note: the "GMLS proof" mentioned in the above is the proof
given in
&lt;a href="https://www.researchgate.net/publication/256720499_Public_key_signatures_in_the_multi-user_setting"&gt;this&lt;/a&gt;
paper, that was intended to reduce the security of the multi-user
setting to that of the single-user setting, and that Dan Bernstein's
&lt;a href="https://eprint.iacr.org/2015/996"&gt;paper&lt;/a&gt;
previously mentioned proved to be invalid.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;What's the TLDR? Fix the keys in any group/ring/multisignature. And
even that may not be enough, see
&lt;a href="https://eprint.iacr.org/2018/068"&gt;MuSig&lt;/a&gt;
for details of why it really isn't, in the scenario of Bitcoin
aggregated multisig.&lt;/p&gt;
&lt;h2&gt;Borromean, Maxwell-Poelstra 2015&lt;/h2&gt;
&lt;p&gt;I covered this extensively (including description of AOS as above) in my
&lt;a href="https://github.com/AdamISZ/ConfidentialTransactionsDoc/"&gt;CT
writeup&lt;/a&gt;
section 3.2&lt;/p&gt;
&lt;p&gt;The idea of the construction as outlined in &lt;a href="https://github.com/Blockstream/borromean_paper"&gt;the paper by Maxwell,
Poelstra&lt;/a&gt;
is to increase the space-efficiency of the published proof even more. By
having several ring signatures joined at a single index we get a
reduction in the number of \(e\) values we publish. This is basically
the same idea as the "AND of \(\Sigma\)-protocols" discussed a
little later in this document (although here we will only be using it
for achieving a specific goal, "Linkability", see more on this next).&lt;/p&gt;
&lt;p&gt;For the real world context - Borromean ring signatures are used in
certain implementations of Confidential Transactions (e.g. Liquid by
Blockstream) today, and were previously used also in Monero for the same
goal of CT. They are a radically different use-case of ring signatures
to the one mostly described in the below; instead of using a ring
signature to hide the identity of a signer, they are used to hide which
exponent contains values in the encoding of a value committed to in a
Pedersen commitment. This allows arithmetic to be done on the
Pedersen-committed amount without worrying about overflow into negative
values modulo \(N\).&lt;/p&gt;
&lt;h2&gt;Linkability and Exculpability&lt;/h2&gt;
&lt;p&gt;In this section we'll briefly describe certain key features that turn
out to be useful in some real-world applications of a ring signature,
before in the following sections laying out how these features are, or
are not, achieved.&lt;/p&gt;
&lt;h3&gt;Linkability (and spontaneity)&lt;/h3&gt;
&lt;p&gt;At first glance, the idea "linkability" with a ring signature seems to
be a contradiction. Since we are trying to achieve signer
ambiguity/anonymity, we don't really want any "linking" being done.
But the idea is rather clever, and proves to be very interesting for
digital cash.&lt;/p&gt;
&lt;p&gt;In a &lt;strong&gt;linkable&lt;/strong&gt; ring signature, a participant with key \(P \in L\)
(i.e. \(L\) is a particular set of public keys), should be able to
produce one ring signature on a given message, but should not be able to
do so again without the two ring signatures being linked. Thus,
functionally, each participant can only make such a signature once
(note: they can still retain anonymity if double-signing).&lt;/p&gt;
&lt;p&gt;This restriction-to-one-signature-while-keeping-anonymity is easily seen
to be valuable in cases like electronic voting or digital cash, as well
as the oft-cited example explained in the next paragraph.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;spontaneity&lt;/strong&gt; property should be a lot more obvious. Consider the
example of a whistleblower. We would want individuals in some large
group (e.g. government bureaucrats) to attest to a statement, while only
revealing group membership and not individual identity. Clearly this is
not workable if it requires cooperation of other members of the group
(even in any setup phase), so it's necessary that the individual can
create the ring signature "spontaneously", knowing only the public key
of other participants.&lt;/p&gt;
&lt;p&gt;The paper uses the abbreviation LSAG for this type of signature:
"Linkable Spontaneous Anonymous Group" signature.&lt;/p&gt;
&lt;p&gt;Note that the previous two constructions (CDS, AOS) can also have this
spontaneity property; but not the linkability property.&lt;/p&gt;
&lt;h3&gt;Culpability, Exculpability and Claimability&lt;/h3&gt;
&lt;p&gt;A ring signature can be described as exculpable if, even given knowledge
of the signing private key, an adversary cannot deduce that that signing
key was the one used to create the ring signature.&lt;/p&gt;
&lt;p&gt;Notice that such a property may be immensely important in a range of
scenarios where a ring sig is useful - e.g. for a whistleblower whose
cryptographic keys were stolen or extracted by force, he could still
plausibly deny being the origin of a leak.&lt;/p&gt;
&lt;p&gt;The reader can easily verify that the AOS construction, for example, has
this exculpability. The fact that a particular key is released e.g.
\(x_2\) in our concrete example, does not allow inference of it having
been used to create that signature. Any other key could have created the
signature, using the same signing algorithm.&lt;/p&gt;
&lt;p&gt;The LWW LSAG, which we'll describe shortly, is on the other hand
&lt;strong&gt;culpable&lt;/strong&gt;, i.e. the opposite - because the key image can be verified
to be tied to one particular key.&lt;/p&gt;
&lt;p&gt;It's easy to see that the two properties &lt;strong&gt;exculpability&lt;/strong&gt; and
&lt;strong&gt;linkability&lt;/strong&gt; are somewhat in conflict, although I'm not aware of a
theorem that &lt;em&gt;absolutely requires&lt;/em&gt; linkability to somehow tag one key in
case it is leaked.&lt;/p&gt;
&lt;p&gt;Lastly, I'll mention &lt;strong&gt;claimability&lt;/strong&gt;, which is briefly described also
in the LWW paper (see below). It may be possible for the owner of a key
to independently/voluntarily prove that they were the source of a given
ring signature, which doesn't logically require culpability.
Claimability is generally easy to achieve with some proof of knowledge
technique.&lt;/p&gt;
&lt;h2&gt;AND of \(\Sigma\)-protocols, DLEQ&lt;/h2&gt;
&lt;p&gt;The thoughtful reader probably won't have much trouble in imagining
what it would mean to do the logical AND of 2 \(\Sigma\)-protocols.&lt;/p&gt;
&lt;p&gt;"AND" here just means you need to prove to the Verifier that you know
both secrets / both conditions are true. So this only requires that you
can answer both challenges (second step) with correct responses. Using
the standard notation, that means generating two transcripts:&lt;/p&gt;
&lt;p&gt;\((R_1, e, s_1) \quad (R_2, e, s_2)\)&lt;/p&gt;
&lt;p&gt;i.e. the same \(e\)-value is given to both protocol runs after
receiving the initial commitments from each. Fiat-Shamir-ising this
protocol will work the same as the usual logic; if considering a
signature scheme, we'll be hashing something like
\(H(m||R_1||R_2||P_1||P_2)\), if we include, as we have learnt
to, key-prefixing.&lt;/p&gt;
&lt;p&gt;As we already mentioned, the Borromean ring signature design uses this
idea to compactify a set of ring signatures, since only one
\(e\)-value is being published, rather than \(M\) for \(M\) ring
signatures.&lt;/p&gt;
&lt;p&gt;This much is not super-interesting; but we can tighten this up a bit and
only use &lt;strong&gt;one&lt;/strong&gt; commitment and response in a special case:&lt;/p&gt;
&lt;h3&gt;Proof of Discrete Log Equivalence (DLEQ, PoDLE)&lt;/h3&gt;
&lt;p&gt;See one of the first posts on this
&lt;a href="https://web.archive.org/web/20200713230948/https://joinmarket.me/blog/blog/poodle"&gt;blog&lt;/a&gt;
for a description of this technique; here we're giving a slightly
deeper look at the meaning.&lt;/p&gt;
&lt;p&gt;If you are proving not only knowledge of a secret \(x\), but also that
two curve points have the same discrete log \(x\) w.r.t. different
bases \(G\) and \(J\) (whose relative discrete log must not be
known; see earlier blog post etc.), you can condense the above AND by
reusing the commitment and challenge for the two bases:&lt;/p&gt;
&lt;p&gt;\(\mathbb{P} \rightarrow \mathbb{V}\): \(R_1= kG,R_2=kJ\)&lt;/p&gt;
&lt;p&gt;\(\mathbb{V} \rightarrow \mathbb{P}\): \(e =
H(m||R_1||R_2||P_1||P_2)\)&lt;/p&gt;
&lt;p&gt;\(\mathbb{P} \rightarrow \mathbb{V}\): \(s\),  (in secret:
\(=k+ex\))&lt;/p&gt;
&lt;p&gt;Now, if the prover acted honestly, his construction of \(s\) will
correctly pass verification &lt;strong&gt;twice&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;\(sG \stackrel{?}{=}R_1 +e P_1 \quad sJ \stackrel{?}{=} R_2 +
eP_2\)&lt;/p&gt;
&lt;p&gt;... and notice that it would be impossible to make that work for
different \(x\)-values on the two bases \(G\) and \(J\) because
you would need to find \(k_1, k_2 \in \mathbb{Z}_N, x_1, x_2 \in
\mathbb{Z}_N\) such that, &lt;strong&gt;without knowing \(e\) in advance,&lt;/strong&gt;
\(s = k_1 + ex_1 =k_2 + ex_2\), which is clearly impossible.&lt;/p&gt;
&lt;p&gt;Proof of soundness is easy to see using the standard rewinding technique
(see e.g. previous blog post amongst many other places); after the two
upfront commitments are fixed and the \(e\)-values are "forked", we
will get two \(s\) values as usual and extract \(x\).&lt;/p&gt;
&lt;h2&gt;Liu-Wei-Wong 2004 LSAG&lt;/h2&gt;
&lt;p&gt;Shortly after the AOS paper, Liu, Wei and Wong published a
&lt;a href="https://www.researchgate.net/publication/220798466_Linkable_Spontaneous_Anonymous_Group_Signature_for_Ad_Hoc_Groups_Extended_Abstract"&gt;paper&lt;/a&gt;
outlining how the same basic idea could be extended to a slightly more
complex context of requiring &lt;strong&gt;linkability&lt;/strong&gt;, as earlier mentioned. It
uses a combination of the above: DLEQ via AND of
\(\Sigma\)-protocols, and OR of \(\Sigma\)-protocols for the ring
signature hiding effect. Detailed algorithm with commentary follows.&lt;/p&gt;
&lt;h3&gt;Liu-Wei-Wong's LSAG algorithm&lt;/h3&gt;
&lt;p&gt;We start with a keyset \(L = \{P_0 \ldots P_{n-1}\}\) chosen by
the signer, whose index will be \(\pi\) (note the ambiguities about
"what is the set of valid keys?" as was discussed under "Key
Prefixing"). We then form a special new kind of curve point that we'll
name from now on as the &lt;strong&gt;key image&lt;/strong&gt; (for reasons that'll become
clear):&lt;/p&gt;
&lt;p&gt;\(I =x_{\pi} \mathbb{H}(L)\)&lt;/p&gt;
&lt;p&gt;Here \(\mathbb{H}\) is a hash function whose output space is points
on the curve, rather than scalar numbers. (&lt;em&gt;The mechanical operation for
doing this is sometimes described as "coerce to point"; for example,
take the 256 bit number output by SHA256 and interpret it as an
\(x-\)coordinate on secp256k1, find the "next" valid point
\(x,y\), incrementing \(x\) if necessary, or whatever; just has to
be deterministic&lt;/em&gt;). \(\mathbb{H}(L)\) is therefore going to play the
same role as \(J\) in the previous section, and we assume
intractability of relative discrete log due to the hashing.&lt;/p&gt;
&lt;h3&gt;Signing LWW LSAG&lt;/h3&gt;
&lt;p&gt;The following steps are very similar "in spirit" to AOS; we still
"extend the causality loop" (bastardising Poelstra's description)
over the whole set of signatures instead of just one, but this time we
also "lift" the loop onto a base of \(\mathbb{H}(L)\) and replicate
the signatures there, too:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set \(k_{\pi} \stackrel{\$}{\leftarrow} \mathbb{Z}_N\)&lt;/li&gt;
&lt;li&gt;Form the hash-challenge at the next index: \(e_{\pi+1} =
    H(m||L||k_{\pi}G||k_{\pi}\mathbb{H}(L)||I)\)&lt;/li&gt;
&lt;li&gt;Note to the above: \(k_{\pi}G\) was previously called
    \(R_{\pi}\) in AOS; we are trying to preserve here, the same
    notation where possible; and of course it's the \(R\) value, not
    the \(k\)-value that will be known/calculated by the verifier. The
    same applies to the "lifted" nonce-point which follows it in the
    concatenation. With respect to the key image, note that it &lt;em&gt;will&lt;/em&gt; be
    published and known to the verifier; but he won't know which index
    it corresponds to.&lt;/li&gt;
&lt;li&gt;Pick \(s_{\pi+1} \stackrel{\$}{\leftarrow} \mathbb{Z}_N\);
    then we do as in AOS, but duplicated; we set:&lt;/li&gt;
&lt;li&gt;\(R_{\pi+1} = s_{\pi+1}G - e_{\pi+1}P_{\pi+1}\) and
    \(R\^{*}_{\pi+1} = s_{\pi+1}\mathbb{H}(L) - e_{\pi+1}I\)&lt;/li&gt;
&lt;li&gt;I realise the last line is pretty dense, so let's clarify: the
    first half is exactly as for AOS; calculate \(R\) given the random
    \(s\) and the just-calculated hash value \(e\). The &lt;em&gt;second&lt;/em&gt;
    half is &lt;strong&gt;the same thing with the base point \(G\) replaced with
    \(\mathbb{H}(L)\), and the pubkey replaced with \(I\) at every
    index&lt;/strong&gt;. We used a shorthand \(R\^{*}\) to mean
    \(k_{\pi+1}\mathbb{H}(L)\), because of course we don't
    actually &lt;em&gt;know&lt;/em&gt; the value \(k_{\pi+1}\).&lt;/li&gt;
&lt;li&gt;Calculate the next hash-challenge as \(e_{pi+2} =
    H(m||L||R_{\pi+1}||R\^{*}_{\pi+1}||I)\)&lt;/li&gt;
&lt;li&gt;Etc...&lt;/li&gt;
&lt;li&gt;As with AOS, we can now forge all the remaining indices, wrapping
    around the loop, by repeating the above operation, generating a new
    random \(s\) at each step, until we get back to the signing index
    \(\pi\), when we must calculate \(s_{\pi}\) as: \(s_{\pi}
    = k_{\pi} + e_{\pi}x_{\pi}\).&lt;/li&gt;
&lt;li&gt;Signature is published as \(\sigma_{L}(m) = (s_0 \ldots
    s_{n-1}, e_0, I)\). (As before, if the keyset \(L\) is not
    specified in advance, it will have to be published for the
    verifier).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So what we're doing here is OR(DLEQ(0), DLEQ(1),.... DLEQ(n-1)). And
as observed, each DLEQ is actually an AND: "AND(I know x for P, x for P
is same as x for P2)". Hence this represents a clever combination of
AND- and OR- of \(\Sigma\)-protocols.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;On a personal note, when I first saw something of this type (I think it
was Cryptonote, see below), I found it quite bewildering, and I'm sure
I'm not alone! But what partially saved me is having already studied
PoDLE/DLEQ as well as AOS ring sigs, so I could intuit that something
combining the two ideas was going on. I hope the previous painstaking
introductions make it all a lot clearer!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Note the key similarities and difference(s) in the published signature,
to the AOS case: you still only need to publish one hash \(e_0\) since
the others are determined by it, but you &lt;strong&gt;must&lt;/strong&gt; publish also the key
image \(I\); if another LWW LSAG is published using the same private
key, it will perforce have the same key image, and be recognized as
having come from the same key [without revealing which
key]{style="text-decoration: underline;"}.&lt;/p&gt;
&lt;p&gt;The protocol using the LSAG can thus reject a "double-sign", if
desired.&lt;/p&gt;
&lt;p&gt;Let's sanity check that we understand the verification algorithm, since
it is slightly different than AOS:&lt;/p&gt;
&lt;h3&gt;Verifying LWW LSAG&lt;/h3&gt;
&lt;p&gt;Start with the given keyset \(L\), the message \(m\) and the
signature \((s_0 \ldots s_{n-1}, e_0, I)\)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Construct \(e_{1} = H(m||L||R_{0}||R\^{*}_{0}||I)\)
    using \(R_0 = s_0G - e_0 P_0\) and \(R\^{*}_{0} = s_0
    \mathbb{H}(L) - e_0 I \)&lt;/li&gt;
&lt;li&gt;Repeat at each index using the new \(e_j\) until \(e_0\) is
    calculated at the last step and verify it matches: \(e_0
    \stackrel{?}{=} H(m||L||R_{n-1}||R\^{*}_{n-1}||I)\).
    Accept if so, reject if not.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(with the additional point mentioned: the protocol using the sig scheme
may also reject this as valid if \(I\) has already been used; this
additional protocol step is usually described as "LINK" in the
literature).&lt;/p&gt;
&lt;h3&gt;A brief note on the key image&lt;/h3&gt;
&lt;p&gt;Make sure you get the difference between this \(\mathbb{H}(L)\) and
the previous \(J\) as per the general DLEQ. In the latter case we can
(and should) choose an arbitrary globally-agreed NUMS point, for example
hashing the standard curve base point \(G\) (with the
"coerce-to-point" technique mentioned). In this case, we have chosen
something that both signer and verifier agree on, as part of the
&lt;strong&gt;setting&lt;/strong&gt; of this particular run of the protocol - it's
deterministically tied to the keyset \(L\). The key image\(I\) is
analogous to \(P_2\) in my PoDLE blog post; it's the signer's
"hidden", one-time key.&lt;/p&gt;
&lt;p&gt;This changes in the next construction, Back 2015. But first, a few words
on security.&lt;/p&gt;
&lt;h2&gt;Security arguments for the LWW LSAG&lt;/h2&gt;
&lt;p&gt;The general approach to proving &lt;strong&gt;unforgeability&lt;/strong&gt; of this ring
signature is the same as that for the basic Schnorr signature as
described in the previous blog post.&lt;/p&gt;
&lt;p&gt;A wrapper around an attacker \(\mathbb{A}\) who we posit to have the
ability to construct a forgery without knowing any private key
\(x_i\), will, as before, have to guess which random oracle query
corresponds to the forgery, and will want to provide two different
"patched" answers to the RO query at that point. As before, there will
be some reduced probability of success due to having to make this kind
of guess, and so the reduction will be even less tight than before.&lt;/p&gt;
&lt;p&gt;Also as before, in the EUF-CMA model, we must allow for an arbitrary
number of signing oracle as well as RO queries, which complicates the
statistical analysis considerably, but the basic principles remain the
same. If at some point forgery is successfully achieved twice at the
same index, we will have something like:&lt;/p&gt;
&lt;p&gt;\(x_{\pi} =
\frac{s\^{*}_{\pi}-s_{\pi}}{e\^{*}_{\pi}-e_{\pi}}\)&lt;/p&gt;
&lt;p&gt;where the * superscripts indicate the second run, and the
\(e\)-values being the patched RO responses.&lt;/p&gt;
&lt;p&gt;And as usual, with appropriate statistical arguments, one can generate a
reduction such that forgery ability with a certain probability \(p\)
implies thus ability to solve ECDLP with a related probability
\(p'\).&lt;/p&gt;
&lt;p&gt;For proving &lt;strong&gt;signer ambiguity&lt;/strong&gt; - for simplicity, we break this into
two parts. If &lt;em&gt;all&lt;/em&gt; of the private keys are known to the attacker (e.g.
by subpoena), then this property completely fails. This is what we
called &lt;strong&gt;culpability&lt;/strong&gt;. It's easy to see why - we have the key image as
part of the signature, and that is deterministically reproducible given
the private key. If &lt;em&gt;none&lt;/em&gt; of the private keys are known to the
attacker, the problem is reduced to the &lt;strong&gt;solution of the &lt;a href="https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption"&gt;Decisional
Diffie Hellman
Problem&lt;/a&gt;&lt;/strong&gt;,
which is considered computationally hard. The reduction is quite
complicated, but as in a standard zero knowledgeness proof, the idea is
that a Simulator can generate a transcript that's statistically
indistinguishable from a genuine transcript.&lt;/p&gt;
&lt;p&gt;For proving &lt;strong&gt;linkability &lt;/strong&gt; - in the LWW paper an argument is made that
this reduces to ECDLP in more or less the same was as for the
unforgeability argument, using two pairs of transcripts for two
different signatures which are posited to be based on the same private
key but having different key images. Examination of the two pairs of
transcripts allows one to deduce that the private key in the two cases
are the same, else ECDLP is broken.&lt;/p&gt;
&lt;p&gt;Notice that these security arguments are [much more complicated than for
the single Schnorr signature case]{style="text-decoration: underline;"}
and perhaps for two distinct reasons: one, because the ring signature is
a more complex algebraic construction, with more degrees of freedom, but
also, because we are asking for a significantly richer set of properties
to hold. In particular notice that even for unforgeability, the EUF-CMA
description is not good enough (we've already discussed this a bit); we
need to consider what happens when creating multiple signatures on
different keysets and how they overlap. Signer anonymity/ambiguity is
especially difficult for LWW and its postdecessors (see below), because
by design it has been weakened (culpability).&lt;/p&gt;
&lt;h2&gt;Back 2015; compression, single-use&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;This is a good place to note that the constructions starting with LWW
are described in some detail in the useful document
&lt;a href="https://ww.getmonero.org/library/Zero-to-Monero-1-0-0.pdf"&gt;Zero-To-Monero&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Adam Back
&lt;a href="https://bitcointalk.org/index.php?topic=972541.msg10619684#msg10619684"&gt;posted&lt;/a&gt;
in 2015 on bitcointalk about a potential space saving over the
cryptonote ring signature, based on using AOS and tweaking it to include
a key image.&lt;/p&gt;
&lt;p&gt;As was noted above, it's a space saving of asymptotically about 50% to
use a scheme like AOS that only requires publication of one hash
challenge as opposed to one for each index (like the CDS for example).&lt;/p&gt;
&lt;p&gt;He then followed up noting that a very similar algorithm had already
been published, namely the LWW we've just described in the above, and
moreover it was published three years before Fujisaki-Suzuki that was
the basis of cryptonote (see below). So it was &lt;em&gt;somewhat&lt;/em&gt; of an
independent re-discovery, but there is a significant tweak. I'll
outline the algorithm below; it'll look very similar to LWW LSAG, but
there's a difference.&lt;/p&gt;
&lt;h3&gt;Signing Back-LSAG&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Define key image \(I =x_{\pi}\mathbb{H}(P_{\pi})\);&lt;/li&gt;
&lt;li&gt;Set \(k_{\pi} \stackrel{\$}{\leftarrow} \mathbb{Z}_N\)&lt;/li&gt;
&lt;li&gt;Form the hash-challenge at the next index: \(e_{\pi+1} =
    H(m||k_{\pi}G||k_{\pi}\mathbb{H}(P_{\pi}))\)&lt;/li&gt;
&lt;li&gt;Pick \(s_{\pi+1} \stackrel{\$}{\leftarrow} \mathbb{Z}_N\);
    then:&lt;/li&gt;
&lt;li&gt;\(R_{\pi+1} = s_{\pi+1}G - e_{\pi+1}P_{\pi+1}\) and
    \(R\^{*}_{\pi+1} = s_{\pi+1}\mathbb{H}(P_{\pi+1}) -
    e_{\pi+1}I\)&lt;/li&gt;
&lt;li&gt;Calculate the next hash-challenge as \(e_{pi+2} =
    H(m||R_{\pi+1}||R\^{*}_{\pi+1})\)&lt;/li&gt;
&lt;li&gt;Etc...&lt;/li&gt;
&lt;li&gt;As with AOS and LWW, we can now forge all the remaining indices,
    wrapping around the loop, by repeating the above operation,
    generating a new random \(s\) at each step, until we get back to
    the signing index \(\pi\), when we must calculate \(s_{\pi}\)
    as: \(s_{\pi} = k_{\pi} + e_{\pi}x_{\pi}\).&lt;/li&gt;
&lt;li&gt;Signature is published as \(\sigma_{L}(m) = (s_0 \ldots
    s_{n-1}, e_0, I)\), as in LWW (\(L\) being the set of \(P\)s).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Verification for this is near-identical as for LWW, so is left as an
exercise for the reader.&lt;/p&gt;
&lt;h3&gt;What's the difference, and what's the purpose?&lt;/h3&gt;
&lt;p&gt;The tweak - which is very similar to Cryptonote (makes sense as it was
an attempt to improve that) - is basically this: by making each of the
signatures in the shifted base point version symmetrical (example:
\(s_2 \mathbb{H}(P_2) = k_2 \mathbb{H}(P_2) + e_2 I\)), it means
that a key image will be valid &lt;em&gt;independent of the set of public keys,
\(L\).&lt;/em&gt; This is crucial in a cryptocurrency application - we need the
key image to be a unique double spend signifier across many different
ring signatures with different keysets - the keys are ephemeral and
change between transactions.&lt;/p&gt;
&lt;p&gt;So it's a blend of the LWW LSAG, which has the advantage of space
compaction for the same reason as AOS - only one hash must be published,
the others can be deduced from the ring structure - with the
F-S-2007/Cryptonote design, which fixes the key image to the key and not
just the specific ring.&lt;/p&gt;
&lt;p&gt;However I have to here leave open whether the security arguments of LWW
carry across to this case. I note that the original description did
&lt;em&gt;not&lt;/em&gt; include the keyset in the hash challenge (notice absence of
\(L\)); but see the note on MLSAG below.&lt;/p&gt;
&lt;h2&gt;Fujisaki-Suzuki 2007 and Cryptonote&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://cryptonote.org/whitepaper.pdf"&gt;Cryptonote&lt;/a&gt;
was adapted from a paper of &lt;a href="https://eprint.iacr.org/2006/389.pdf"&gt;Fujisaki and
Suzuki&lt;/a&gt;
describing an alternate version of a linkable (here "traceable") ring
signature, in 2007. We won't dwell on these constructions here (except
inasmuch as we referred to them above), as they provide the same
linkability function as the above LSAG, but are less compact. Instead,
in the final section, I'll describe how Monero has applied LWW LSAG and
the Back LSAG to their specific requirements.&lt;/p&gt;
&lt;h2&gt;Monero MLSAG&lt;/h2&gt;
&lt;p&gt;For anyone paying close attention all the way through, there will be
nothing surprising here!&lt;/p&gt;
&lt;p&gt;For a cryptocurrency, we build transactions consisting of multiple
inputs. Each input in Monero's case uses a ring signature, rather than
a single signature, to authenticate the transfer, referring back to
multiple pubkeys possessing coins as outputs of earlier transactions.&lt;/p&gt;
&lt;p&gt;So here we need &lt;strong&gt;one ring signature per input&lt;/strong&gt;. Moreover, per normal
transaction logic, we obviously need &lt;em&gt;all&lt;/em&gt; of those ring signatures to
successfully verify. So this is another case for the "AND of
\(\Sigma\)-protocols". We just run \(M\) cases of Back's LSAG and
combine them with a single \(e\) hash challenge at each key index (so
the hash challenge kind of "spans over the inputs"). Additionally,
note that the hash challenge here is assumed to include the keyset with
a generic \(L\) (limiting tiresome subscripting to a minimum...).&lt;/p&gt;
&lt;p&gt;To sign \(M\) inputs each of which have \(n\) keys:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For each input, define key image \(I_i
    =x_{i,\pi}\mathbb{H}(P_{i,\pi}) \ \forall i \in 0 \ldots
    M-1\);&lt;/li&gt;
&lt;li&gt;Set \(k_{i, \pi} \stackrel{\$}{\leftarrow} \mathbb{Z}_N \
    \forall i \in 0 \ldots M-1\)&lt;/li&gt;
&lt;li&gt;Form the hash-challenge at the next index: \(e_{\pi+1} =
    H(m||L||k_{0, \pi}G||k_{0,
    \pi}\mathbb{H}(P_{0,\pi})||k_{1, \pi}G||k_{1,
    \pi}\mathbb{H}(P_{1,\pi}) ...)\)&lt;/li&gt;
&lt;li&gt;Pick \(s_{i, \pi+1} \stackrel{\$}{\leftarrow} \mathbb{Z}_N\
    \forall i \in 0 \ldots M-1\); then:&lt;/li&gt;
&lt;li&gt;\(R_{i, \pi+1} = s_{i, \pi+1}G - e_{\pi+1}P_{i, \pi+1}\)
    and \(R\^{*}_{i, \pi+1} = s_{i, \pi+1}\mathbb{H}(P_{i,
    \pi+1}) - e_{\pi+1}I_i \ \forall i \in 0 \ldots M-1\)&lt;/li&gt;
&lt;li&gt;Calculate the next hash-challenge as \(e_{\pi+2} =
    H(m||L||R_{0, \pi+1}||R\^{*}_{0,\pi+1}||R_{1,
    \pi+1}||R\^{*}_{2,\pi+1} ...)\)&lt;/li&gt;
&lt;li&gt;Etc...&lt;/li&gt;
&lt;li&gt;Logic as for AOS, LWW but duplicated at every input with single
    \(e\)-challenge, and at signing index for all inputs (\(\pi\)):
    \(s_{i, \pi} = k_{i, \pi} + e_{i, \pi}x_{i, \pi}\ \forall
    i \in 0 \ldots M-1\).&lt;/li&gt;
&lt;li&gt;Signature is published as \(\sigma_{L}(m) = (s_{0,0} \ldots
    s_{0,M-1}, \ldots, s_{n-1,0}, \ldots s_{n-1,M-1}, e_0, I_0
    \ldots I_{M-1})\).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;(1)  This algorithm as described requires each input to have the genuine
signer at the same key-index in the set of pubkeys for each input, which
is a limitation.&lt;/p&gt;
&lt;p&gt;(2) Monero has implemented Confidential Transactions, and this is
folded in with the above into a new design which seems to have two
variants "RingCTFull" and "RingCTSimple". This can be investigate
further in the documents on RingCT as referenced in the previously
mentioned
&lt;a href="https://ww.getmonero.org/library/Zero-to-Monero-1-0-0.pdf"&gt;ZeroToMonero&lt;/a&gt;.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="cryptography"></category><category term="bitcoin"></category></entry><entry><title>Liars, cheats, scammers and the Schnorr signature</title><link href="https://joinmarket.me/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/" rel="alternate"></link><published>2019-02-01T00:00:00+01:00</published><updated>2019-02-01T00:00:00+01:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2019-02-01:/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/</id><summary type="html">&lt;p&gt;security arguments for Schnorr&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Liars, cheats, scammers and the Schnorr signature&lt;/h3&gt;
&lt;p&gt;How sure are &lt;em&gt;you&lt;/em&gt; that the cryptography underlying Bitcoin is secure?
With regard to one future development of Bitcoin's crypto, in
discussions in public fora, I have more than once confidently asserted
"well, but the Schnorr signature has a security reduction to ECDLP".
Three comments on that before we begin:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you don't know what "reduction" means here, fear not, we will
    get deeply into this here.&lt;/li&gt;
&lt;li&gt;Apart from simply &lt;em&gt;hearing&lt;/em&gt; this and repeating it, I was mostly
    basing this on a loose understanding that "it's kinda related to
    the soundness proof of a sigma protocol" which I discussed in my
    &lt;a href="https://github.com/AdamISZ/from0k2bp"&gt;ZK2Bulletproofs&lt;/a&gt;
    paper, which is true -  but there's a lot more involved.&lt;/li&gt;
&lt;li&gt;The assertion is true, but there are caveats, as we will see. And
    Schnorr is different from ECDSA in this regard, as we'll also see,
    at the end.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But why write this out in detail? It actually came sort of out of left
field. Ruben Somsen was asking on slack about some aspect of Monero, I
forget, but it prompted me to take another look at those and other ring
signatures, and I realised that attempting to understand the
&lt;strong&gt;security&lt;/strong&gt; of those more complex constructions is a non-starter unless
you &lt;strong&gt;really understand why we can say "Schnorr is secure" in the
first place&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Liars and cheats&lt;/h3&gt;
&lt;p&gt;The world of "security proofs" in cryptography appears to be a set of
complex stories about liars - basically made up magic beans algorithms
that &lt;em&gt;pretend&lt;/em&gt; to solve things that nobody &lt;em&gt;actually&lt;/em&gt; knows how to
solve, or someone placing you in a room and resetting your clock
periodically and pretending today is yesterday - and cheats, like
"let's pretend the output of the hash function is (x), because it
suits my agenda for it to be (x)" (at least in this case the lying
is consistent - the liar doesn't change his mind about (x); that's
something!).&lt;/p&gt;
&lt;p&gt;I hope that sounds crazy, it mostly really is :)&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;Concepts I am alluding to include: the random oracle, a ZKP simulator,
extractor/"forking", an "adversary" etc. etc.&lt;/em&gt;)&lt;/p&gt;
&lt;h2&gt;Preamble: the reluctant Satoshi scammer&lt;/h2&gt;
&lt;p&gt;The material of this blog post is pretty abstract, so I decided to spice
it up by framing it as some kind of sci-fi :)&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://web.archive.org/web/20200428212652im_/https://joinmarket.me/static/media/uploads/cube-250082_6402.png"&gt;{width="174"
height="174"}&lt;/p&gt;
&lt;p&gt;Imagine you have a mysterious small black cube which you were given by
an alien that has two slots you can plug into to feed it input data and
another to get output data, but you absolutely can't open it (so like
an Apple device, but more interoperable), and it does one thing only,
but that thing is astonishing: if you feed it a message and a &lt;strong&gt;public&lt;/strong&gt;
key in its input slot, then it'll &lt;em&gt;sometimes&lt;/em&gt; spit out a valid Schnorr
signature on that message.&lt;/p&gt;
&lt;p&gt;Well in 2019 this is basically useless, but after considerable
campaigning (mainly by you, for some reason!), Schnorr is included into
Bitcoin in late 2020. Delighted, you start trying to steal money but it
proves to be annoying.&lt;/p&gt;
&lt;p&gt;First, you have to know the public key, so the address must be reused or
something similar. Secondly (and this isn't a problem, but is weird and
will become relevant later): the second input slot is needed to pass the
values of the hash function sha2 (or whatever is the right one for our
signature scheme) into the black box for any data it needs to hash. Next
problem: it turns out that the device only works if you feed it a few
&lt;em&gt;other&lt;/em&gt; signatures of other messages on the same public key, first.
Generally speaking, you don't have that. Lastly, it doesn't &lt;em&gt;always&lt;/em&gt;
work for any message you feed into it (you want to feed in 'messages'
which are transactions paying you money), only sometimes.&lt;/p&gt;
&lt;p&gt;With all these caveats and limitations, you fail to steal any money at
all, dammit!&lt;/p&gt;
&lt;p&gt;Is there anything else we can try? How about we pretend to be someone
else? Like Satoshi? Hmm ...&lt;/p&gt;
&lt;p&gt;For argument's sake, we'll assume that people use the Schnorr Identity
Protocol (henceforth SIDP), which can be thought of as "Schnorr
signature without the message, but with an interactive challenge".
We'll get into the technicals below, for now note that a signature
doesn't prove anything about identity (because it can be passed
around), you need an interactive challenge, a bit like saying "yes,
give me a signature, but *I* choose what you sign".&lt;/p&gt;
&lt;p&gt;So to get people to believe I'm Satoshi (and thus scam them into
investing in me perhaps? Hmm sounds familiar ...) I'm going to somehow
use this black box thing to successfully complete a run of SIDP. But as
noted it's unreliable; I'll need a bunch of previous signatures
(let's pretend that I get that somehow), but I *also* know this thing
doesn't work reliably for every message, so the best I can do is
probably to try to &lt;strong&gt;scam 1000&lt;/strong&gt; &lt;strong&gt;people simultaneously&lt;/strong&gt;. That way
they might reasonably believe that their successful run represents
proof; after all it's supposed to be &lt;em&gt;impossible&lt;/em&gt; to create this kind
of proof without having the private key - that's the entire idea of it!
(the fact that it failed for other people could be just a rumour, after
all!)&lt;/p&gt;
&lt;p&gt;So it's all a bit contrived, but weirder scams have paid off - and they
didn't even use literally alien technology!&lt;/p&gt;
&lt;p&gt;So, we'll need to read the input to our hash function slot from the
magic box; it's always of the form:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;message || R-value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;... details to follow, but basically (R) is the starting value in
the SIDP, so we pass it to our skeptical challenger(s). They respond
with (e), intended to be completely random to make our job of
proving ID as hard as possible, then &lt;strong&gt;we trick our black box&lt;/strong&gt; - we
don't return SHA2((m||R)) but instead we return (e). More on
this later, see "random oracle model" in the below. Our magic box
outputs, if successful, (R, s) where (s) is a new random-looking
value. The challenger will be amazed to see that:&lt;/p&gt;
&lt;p&gt;(sG = R + eP_{satoshi})&lt;/p&gt;
&lt;p&gt;is true!! And the millions roll in.&lt;/p&gt;
&lt;p&gt;If you didn't get in detail how that scam operated, don't worry,
we're going to unpack it, since it's the heart of our technical story
below. The crazy fact is that &lt;strong&gt;our belief that signatures like the
Schnorr signature (and ECDSA is a cousin of it) is mostly reliant on
basically the argument above.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;But 'mostly' is an important word there: what we actually do, to make
the argument that it's secure, is stack that argument on top of at
least 2 other arguments of a similar nature (using one algorithm as a
kind of 'magic black box' and feeding it as input to a different
algorithm) and to relate the digital signature's security to the
security of something else which ... we &lt;em&gt;think&lt;/em&gt; is secure, but don't
have absolute proof.&lt;/p&gt;
&lt;p&gt;Yeah, really.&lt;/p&gt;
&lt;p&gt;We'll see that our silly sci-fi story has &lt;em&gt;some&lt;/em&gt; practical reality to
it - it really &lt;em&gt;is&lt;/em&gt; true that to impersonate is a bit more practically
feasible than to extract private keys, and we can even quantify this
statement, somewhat.&lt;/p&gt;
&lt;p&gt;But not the magic cube part. That part was not real at all, sorry.&lt;/p&gt;
&lt;h2&gt;Schnorr ID Protocol and signature overview&lt;/h2&gt;
&lt;p&gt;I have explained SIDP with reference to core concepts of Sigma Protocols
and Zero Knowledge Proofs of Knowledge in Section 3.2
&lt;a href="https://github.com/AdamISZ/from0k2bp"&gt;here&lt;/a&gt;
. A more thorough explanation can be found in lots of places, e.g.
Section 19.1 of &lt;a href="https://crypto.stanford.edu/~dabo/cryptobook/"&gt;Boneh and
Shoup&lt;/a&gt;.
Reviewing the basic idea, cribbing from my own doc:&lt;/p&gt;
&lt;p&gt;Prover (\mathbf{P}) starts with a public key (P) and a
corresponding private key (x) s.t. (P = xG).\
(\mathbf{P}) wishes to prove in zero knowledge, to verifier
(\mathbf{V}), that he knows (x).\
(\mathbf{P}) → (\mathbf{V}): (R) (a new random curve
point, but (\mathbf{P}) knows (k) s.t. (R = kG))\
(\mathbf{V}) → (\mathbf{P}): (e) (a random scalar)\
(\mathbf{P}) → (\mathbf{V}): (s) (which (\mathbf{P})
calculated from the equation (s = k + ex))\
Note: the transcript of the conversation would here be: ((R, e,
s)).\
Verification works fairly trivially: verifier checks sG
(\stackrel{?}{=} R+eP). See previously mentioned doc for details on
why this is supposedly &lt;em&gt;zero knowledge&lt;/em&gt;, that is to say, the verifier
doesn't learn anything about the private key from the procedure.&lt;/p&gt;
&lt;p&gt;As to why it's sound - why does it really prove that the Prover knows
(x), see the same doc, but in brief: if we can convince the prover
to re-run the third step with a modified second step (but the same first
step!), then he'll be producing a second signature (s') on a
second random (e'), but with the same (k) and (R), thus:&lt;/p&gt;
&lt;p&gt;(x = \frac{s-s'}{e-e'})&lt;/p&gt;
&lt;p&gt;So we say it's "sound" in the specific sense that only a
knower-of-the-secret-key can complete the protocol. But more on this
shortly!&lt;/p&gt;
&lt;p&gt;What about the famous "Schnorr signature"? It's just an
noninteractive version of the above. There is btw a brief summary in
&lt;a href="https://web.archive.org/web/20200428212652/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;this&lt;/a&gt;
earlier blog post, also. Basically replace (e) with a hash (we'll
call our hash function (H)) of the commitment value (R) and the
message we want to sign (m):&lt;/p&gt;
&lt;p&gt;(e = H(m||R))&lt;/p&gt;
&lt;p&gt;; as mentioned in the just-linked blog post, it's also possible to add
other stuff to the hash, but these two elements at least are necessary
to make a sound signature.&lt;/p&gt;
&lt;p&gt;As was noted in the 80s by &lt;a href="https://link.springer.com/content/pdf/10.1007%2F3-540-47721-7_12.pdf"&gt;Fiat and
Shamir&lt;/a&gt;,
this transformation is generic to any zero-knowledge identification
protocol of the "three pass" or sigma protocol type - just use a hash
function to replace the challenge with H(message, commitment) to create
the new signature scheme.&lt;/p&gt;
&lt;p&gt;Now, if we want to discuss security, we first have to decide what that
even means, for a signature scheme. Since we're coming at things from a
Bitcoin angle, we're naturally focused on preventing two things:
forgery and key disclosure. But really it's the same for any usage of
signatures. Theorists class security into at least three types (usually
more, these are the most elementary classifications):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Total break&lt;/li&gt;
&lt;li&gt;Universal forgery&lt;/li&gt;
&lt;li&gt;Existential forgery&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Interesting historical note: this taxonomy is due to Goldwasser, Micali
and Rackoff - the same authors who introduced the revolutionary notion
of a "Zero Knowledge Proof" in the 1980s.)&lt;/p&gt;
&lt;p&gt;Total break means key disclosure. To give a silly example: if (k=0)
in the above, then (s = ex) and, on receipt of (s), the verifier
could simply multiply it by the modular inverse of (e) to extract
the private key (x). A properly random (k) value, or 'nonce',
as explained ad nauseam elsewhere, is critical to the security. Since
this is the worst possible security failure, being secure against it is
considered the weakest notion of "security" (note this kind of
"reverse" reasoning, it is very common and important in this field).&lt;/p&gt;
&lt;p&gt;The next weakest notion of security would be security against universal
forgery - the forger should not be able to generate a signature on any
message they are given. We won't mention this too much; we will focus
on the next, stronger notion of "security":&lt;/p&gt;
&lt;p&gt;"Security against existential forgery under adaptive chosen message
attack", often shortened to EUF-CMA for sanity (the 'adaptive(ly)'
sometimes seems to be dropped, i.e. understood), is clearly the
strongest notion out of these three, and papers on this topic generally
focus on proving this. "Chosen message" here refers to the idea that
the attacker even gets to choose &lt;em&gt;what&lt;/em&gt; message he will generate a
verifying forgery for; with the trivial restriction that it can't be a
message that the genuine signer has already signed.&lt;/p&gt;
&lt;p&gt;(A minor point: you can also make this definition more precise with
SUF-CMA (S = "strongly"), where you insist that the finally produced
signature by the attacker is not on the same message as one of the
pre-existing signatures. The famous problem of &lt;strong&gt;signature
malleability&lt;/strong&gt; experienced in ECDSA/Bitcoin relates to this, as noted by
Matt Green
&lt;a href="https://blog.cryptographyengineering.com/euf-cma-and-suf-cma/"&gt;here&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;I believe there are even stronger notions (e.g. involving active
attacks) but I haven't studied this.&lt;/p&gt;
&lt;p&gt;In the next, main section of this post, I want to outline how
cryptographers try to argue that both the SIDP and the Schnorr signature
are secure (in the latter case, with that strongest notion of security).&lt;/p&gt;
&lt;h2&gt;Why the Schnorr signature is secure&lt;/h2&gt;
&lt;h3&gt;Why the SIDP is secure&lt;/h3&gt;
&lt;p&gt;Here, almost by definition, we can see that only the notion of "total
break" makes sense: there is no message, just an assertion of key
ownership. In the context of SIDP this is sometimes called the
"impersonation attack" for obvious reasons - see our reluctant
scammer.&lt;/p&gt;
&lt;p&gt;The justification of this is somehow elegantly and intriguingly short:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The SIDP is secure against impersonation = The SIDP is &lt;em&gt;sound&lt;/em&gt; as a
ZKPOK.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You can see that these are just two ways of saying the same thing. But
what's the justification that either of them are true? Intuitively the
soundness proof tries to isolate the Prover as a machine/algorithm and
screw around with its sequencing, in an attempt to force it to spit out
the secret that we believe it possesses. If we hypothesise an adversary
(\mathbb{A}) who &lt;em&gt;doesn't&lt;/em&gt; possess the private key to begin with,
or more specifically, one that can pass the test of knowing the key for
any public key we choose, we can argue that there's only one
circumstance in which that's possible: &lt;strong&gt;if (\mathbb{A}) can solve
the general Elliptic Curve Discrete Logarithm Problem(ECDLP) on our
curve.&lt;/strong&gt; That's intuitively &lt;em&gt;very&lt;/em&gt; plausible, but can we prove it?&lt;/p&gt;
&lt;h3&gt;Reduction&lt;/h3&gt;
&lt;p&gt;(One of a billion variants on the web, taken from
&lt;a href="https://jcdverha.home.xs4all.nl/scijokes/6_2.html"&gt;here&lt;/a&gt;
:))&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;``` {.joke}
A mathematician and a physicist were asked the following question:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;    Suppose you walked by a burning house and saw a hydrant and&lt;/span&gt;
&lt;span class="err"&gt;    a hose not connected to the hydrant.  What would you do?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;P: I would attach the hose to the hydrant, turn on the water, and put out
   the fire.&lt;/p&gt;
&lt;p&gt;M: I would attach the hose to the hydrant, turn on the water, and put out
   the fire.&lt;/p&gt;
&lt;p&gt;Then they were asked this question:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;    Suppose you walked by a house and saw a hose connected to&lt;/span&gt;
&lt;span class="err"&gt;    a hydrant.  What would you do?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;P: I would keep walking, as there is no problem to solve.&lt;/p&gt;
&lt;p&gt;M: I would disconnect the hose from the hydrant and set the house on fire,
   reducing the problem to a previously solved form.
```&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The general paradigm here is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A protocol X is "reducible to" a hardness assumption Y if a
hypothetical adversary (\mathbb{A}) who can break X can also
violate Y.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the concrete case of X = SIDP and Y = ECDLP we have nothing to do,
since we've already done it. SIDP is intrinsically a test that's
relying on ECDLP; if you can successfully impersonate (i.e. break SIDP)
on any given public key (P) then an "Extractor" which we will now
call a &lt;strong&gt;wrapper&lt;/strong&gt;, acting to control the environment of
(\mathbb{A}) and running two executions of the second half of the
transcript, as already described above, will be able to extract the
private key/discrete log corresponding to (P). So we can think of
that Extractor itself as a machine/algorithm which spits out the (x)
after being fed in the (P), in the simple case where our
hypothetical adversary (\mathbb{A}) is 100% reliable. In this
specific sense:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;SIDP is reducible to ECDLP&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;However, in the real world of cryptographic research, such an analysis
is woefully inadequate; because to begin with ECDLP being "hard" is a
computational statement: if the group of points on the curve is only of
order 101, it is totally useless since it's easy to compute all
discrete logs by brute force. So, if ECDLP is "hard" on a group of
size (2\^k), let's say its hardness is measured as the probability
of successfully cracking by guessing, i.e. (2\^{-k}) (here
&lt;strong&gt;deliberately avoiding&lt;/strong&gt; the real measure based on smarter than pure
guesses, because it's detail that doesn't affect the rest). Suppose
(\mathbb{A}) has a probability of success (\epsilon); what
probability of success does that imply in solving ECDLP, in our
"wrapper" model? Is it (\epsilon)?&lt;/p&gt;
&lt;p&gt;No; remember the wrapper had to actually extract &lt;strong&gt;two&lt;/strong&gt; successful
impersonations in the form of valid responses (s) to challenge
values (e). We can say that the wrapper &lt;strong&gt;forks&lt;/strong&gt; (\mathbb{A}):&lt;/p&gt;
&lt;p&gt;&lt;img alt="Fork your sigma protocol if you want
fork" src="/web/20200428212652im_/https://joinmarket.me/static/media/uploads/.thumbnails/forking.png/forking-659x466.png"&gt;{width="659"
height="466"}&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Fork your sigma protocol if you want fork&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Crudely, the success probability is (\epsilon\^2); both of those
impersonations have to be successful, so we multiply the probabilities.
(More exact: by a subtle argument we can see that the size of the
challenge space being reduced by 1 for the second run of the protocol
implies that the probability of success in that second run is reduced,
and the correct formula is (\epsilon\^2 - \frac{\epsilon}{n}),
where (n) is the size of the hash function output space; obviously
this doesn't matter too much).&lt;/p&gt;
&lt;p&gt;How does this factor into a real world decision? We have to go back to
the aforementioned "reverse thinking". The reasoning is something
like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We believe ECDLP is hard for our group, let's say we think you
    can't do better than p = (p) (I'll ignore running time and
    just use probability of success as a measure, for simplicity).&lt;/li&gt;
&lt;li&gt;The above reduction implies that &lt;em&gt;if&lt;/em&gt; we can break SIDP with prob
    (\epsilon), we can also break ECDLP with prob (\simeq
    \epsilon\^2).&lt;/li&gt;
&lt;li&gt;This reduction is thus &lt;strong&gt;not tight&lt;/strong&gt; - if it's really the case that
    "the way to break SIDP is only to break ECDLP" then a certain
    hardness (p) only implies a hardness (\sqrt{p}) for SIDP,
    which we may not consider sufficiently improbable (remember that if
    (p=2\^{-128}), it means halving the number of bits: (\sqrt{p}
    =2\^{-64})). See
    &lt;a href="https://crypto.stackexchange.com/questions/14439/proofs-by-reduction-and-times-of-adversaries"&gt;here&lt;/a&gt;
    for a nice summary on "non-tight reductions".&lt;/li&gt;
&lt;li&gt;And &lt;em&gt;that&lt;/em&gt; implies that if I want 128 bit security for my SIDP, I
    need to use 256 bits for my ECDLP (so my EC group, say). This is all
    handwavy but you get the pattern: these arguments are central to
    deciding what security parameter is used for the underlying hardness
    problem (here ECDLP) when it's applied in practice to a specific
    protocol (here SIDP).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I started this subsection on "reductions" with a lame math joke; but I
hope you can see how delicate this all is ... we start with something
we believe to be hard, but then "solve" it with a purely hypothetical
other thing (here (\mathbb{A}) ), and from this we imply a two-way
connection (I don't say &lt;em&gt;equivalence&lt;/em&gt;; it's not quite that) that we
use to make concrete decisions about security. Koblitz (he of the 'k'
in secp256k1) had some interesting thoughts about 'reductionist'
security arguments in Section 2.2 and elsewhere in
&lt;a href="https://cr.yp.to/bib/2004/koblitz.pdf"&gt;this&lt;/a&gt;
paper. More from that later.&lt;/p&gt;
&lt;p&gt;So we have sketched out how to think about "proving our particular SIDP
instance is/isn't secure based on the intractability of ECDLP in the
underlying group"; but that's only 2 stacks in our jenga tower; we
need MOAR!&lt;/p&gt;
&lt;h2&gt;From SIDP to Schnorr signature&lt;/h2&gt;
&lt;p&gt;So putting together a couple of ideas from previous sections, I hope it
makes sense to you now that we want to prove that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"the (EC) Schnorr signature has existential unforgeability against
chosen message attack (EUFCMA) &lt;strong&gt;if&lt;/strong&gt; the Schnorr Identity Protocol is
secure against impersonation attacks."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;with the understanding that, if we succeed in doing so, we have proven
also:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"the (EC) Schnorr signature has existential unforgeability against
chosen message attack (EUFCMA) &lt;strong&gt;if&lt;/strong&gt; the Elliptic Curve discrete
logarithm problem is hard in our chosen EC group."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;with the substantial caveat, as per the previous section, that the
reduction involved in making this statement is not tight.&lt;/p&gt;
&lt;p&gt;(there is another caveat though - see the next subsection, &lt;em&gt;The Random
Oracle Model&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;This second (third?) phase is much less obvious and indeed it can be
approached in more than one way.
&lt;a href="https://crypto.stanford.edu/~dabo/cryptobook/"&gt;Boneh-Shoup&lt;/a&gt;
deals with it in a lot more detail; I'll use this as an outline but
dumb it down a fair bit. There is a simpler description
&lt;a href="http://web.stanford.edu/class/cs259c/lectures/schnorr.pdf"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The "CMA" part of "EUFCMA" implies that our adversary
(\mathbb{A}), who we are now going to posit has the magical ability
to forge signatures (so it's the black cube of our preamble), should be
able to request signatures on an arbitrarily chosen set of messages
(m_i), with (i) running from 1 to some defined number (S).
But we must also allow him to make queries to the hash function, which
we idealise as a machine called a "random oracle". Brief notes on that
before continuing:&lt;/p&gt;
&lt;h3&gt;Aside: The Random Oracle Model&lt;/h3&gt;
&lt;p&gt;Briefly described
&lt;a href="https://en.wikipedia.org/wiki/Random_oracle"&gt;here&lt;/a&gt;
. It's a simple but powerful idea: we basically idealise how we want a
cryptographic hash function (f) to behave. We imagine an output
space for (f) of size (C). For any given input (x) from a
predefined input space of one or more inputs, we will get a
deterministic output (y), but it should be unpredictable, so we
imagine that the function is &lt;em&gt;randomly&lt;/em&gt; deterministic. Not a
contradiction - the idea is only that there is no &lt;strong&gt;public&lt;/strong&gt; law or
structure that allows the prediction of the output without actually
passing it through the function (f). The randomness should be
uniform.&lt;/p&gt;
&lt;p&gt;In using this in a security proof, we encounter only one problem: we
will usually want to model (f) by drawing its output (y) from a
uniformly random distribution (you'll see lines like (y
\stackrel{\$}{\leftarrow} \mathbb{Z}_N) in papers, indicating
(y) is set randomly). But in doing this, we have set the value of
the output for that input (x) permanently, so if we call (f)
again on the same (x), whether by design or accident, we &lt;em&gt;must&lt;/em&gt;
again return the same "random" (y).&lt;/p&gt;
&lt;p&gt;We also find sometimes that in the nature of the security game we are
playing, one "wrapper" algorithm wants to "cheat" another, wrapped
algorithm, by using some hidden logic to decide the "random" (y)
at a particular (x). This &lt;em&gt;can&lt;/em&gt; be fine, because to the "inner"
algorithm it can look entirely random. In this case we sometimes say we
are "&lt;strong&gt;patching the value of the RO at (x) to (y)"&lt;/strong&gt; to
indicate that this artificial event has occurred; as already mentioned,
it's essential to remember this output and respond with it again, if a
query at (x) is repeated.&lt;/p&gt;
&lt;p&gt;Finally, this "perfectly random" behaviour is very idealised. Not all
cryptographic protocols involving hash functions require this behaviour,
but those that do are said to be "secure in the random oracle model
(ROM)" or similar.&lt;/p&gt;
&lt;h3&gt;Wrapping A with B&lt;/h3&gt;
&lt;p&gt;&lt;img alt="B tries to win the impersonation game against C, by wrapping the
signature forger
A" src="/web/20200428212652im_/https://joinmarket.me/static/media/uploads/.thumbnails/EUFCMA1.png/EUFCMA1-584x413.png"&gt;{width="584"
height="413"}&lt;/p&gt;
&lt;p&gt;So we now wrap (\mathbb{A})  with (\mathbb{B}).
And (\mathbb{B})'s job will be to succeed at winning the SIDP
"game" against a challenger (\mathbb{C}) .&lt;/p&gt;
&lt;p&gt;Now (\mathbb{A}) is allowed (S) signing queries; given his
messages (m_i), we can use (S) eavesdropped conversations (R,
e, s) from the actual signer (or equivalently, just forge transcripts
- see "zero knowledgeness" of the Schnorr signature), and for each,
(\mathbb{B}) can patch up the RO to make these transcripts fit
(\mathbb{A})'s requested messages; just do
(H(m_i||R_i)=e_i). Notice that this part of the process represents
(S) queries to the random oracle.&lt;/p&gt;
&lt;p&gt;Observe that (\mathbb{B})  is our real "attacker" here: he's the
one trying to fool/attack (\mathbb{C}) 's identification
algorithm; he's just using (\mathbb{A}) as a black box (or cube,
as we say). We can say (\mathbb{A}) is a "subprotocol" used by
(\mathbb{B}).&lt;/p&gt;
&lt;p&gt;It's all getting a bit complicated, but by now you should probably have
a vague intuition that this will work, although of course not reliably,
and as a function of the probability of (\mathbb{A}) being able to
forge signatures of course (we'll again call this (\epsilon)).&lt;/p&gt;
&lt;h3&gt;Toy version: (\epsilon = 1)&lt;/h3&gt;
&lt;p&gt;To aid understanding, imagine the simplest possible case, when
(\mathbb{A}) works flawlessly. The key (P) is given to him and
he chooses a random (k, R =kG), and also chooses his message (m)
as is his right in this scenario. The "CMA" part of EUF-CMA is
irrelevant here, since (\mathbb{A}) can just forge immediately
without signature queries:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(\mathbb{A}) asks for the value of (H(m||R)), by passing
    across (m,R) to (\mathbb{B}).&lt;/li&gt;
&lt;li&gt;(\mathbb{B}) receives this query and passes (R) as the
    first message in SIDP to (\mathbb{C}) .&lt;/li&gt;
&lt;li&gt;(\mathbb{C}) responds with a completely random challenge value
    (e).&lt;/li&gt;
&lt;li&gt;(\mathbb{B}) "patches" the RO with (e) as the output for
    input (m, R), and returns (e) to (\mathbb{A}) .&lt;/li&gt;
&lt;li&gt;(\mathbb{A}) takes (e) as (H(m||R)), and provides a
    valid (s) as signature.&lt;/li&gt;
&lt;li&gt;(\mathbb{B}) passes (s) through to (\mathbb{C}) , who
    verifies (sG = R + eP); identification passed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can see that nothing here is new except the random oracle patching,
which is trivially non-problematic as we make only one RO query, so
there can't be a conflict. The probability of successful impersonation
is 1.&lt;/p&gt;
&lt;p&gt;Note that this implies the probability of successfully breaking ECDLP is
also (\simeq 1). We just use a second-layer wrapper around
(\mathbb{B}), and fork its execution after the provision of
(R), providing two separate challenges and thus in each run getting
two separate (s) values and solving for (x), the private
key/discrete log as has already been explained.&lt;/p&gt;
&lt;p&gt;Why (\simeq)? As noted on the SIDP to ECDLP reduction above, there
is a tiny probability of a reused challenge value which must be factored
out, but it's of course negligible in practice.&lt;/p&gt;
&lt;p&gt;If we assert that the ECDLP is not trivially broken in reasonable time,
we must also assert that such a powerful (\mathbb{A}) does not
exist, given similarly limited time (well; &lt;em&gt;in the random oracle model&lt;/em&gt;,
of course...).&lt;/p&gt;
&lt;h3&gt;Full CMA case, (\epsilon \&amp;lt;\&amp;lt; 1)&lt;/h3&gt;
&lt;p&gt;Now we give (\mathbb{A}) the opportunity to make (S) signing
queries (as already mentioned, this is what we mean by an "adaptive
chosen message attack"). The sequence of events will be a little longer
than the previous subsection, but we must think it through to get a
sense of the "tightness of the reduction" as already discussed.&lt;/p&gt;
&lt;p&gt;The setup is largely as before: (P) is given. There will be (h)
RO queries allowed (additional to the implicit ones in the signing
queries).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For any signing query from (\mathbb{A}), as we covered in
    "Wrapping A with B", a valid response can be generated by patching
    the RO (or using real transcripts). We'll have to account for the
    possibility of a conflict between RO queries (addressed below), but
    it's a minor detail.&lt;/li&gt;
&lt;li&gt;Notice that as per the toy example previously, during
    (\mathbb{A})'s forgery process, his only interaction with his
    wrapper (\mathbb{B}) is to request a hash value
    (H(m||R)). So it's important to understand that, first
    because of the probabilistic nature of the forgery ((\epsilon
    \&amp;lt;\&amp;lt; 1)), and second because (\mathbb{A})'s algorithm is
    unknown, &lt;strong&gt;(\mathbb{B}) does not know which hash function query
    (and therefore which RO response) will correspond to a successful
    forgery.&lt;/strong&gt; This isn't just important to the logic of the game; as
    we'll see, it's a critical limitation of the security result we
    arrive at.&lt;/li&gt;
&lt;li&gt;So to address the above, (\mathbb{B}) has to make a decision
    upfront: which query should I use as the basis of my impersonation
    attempt with (\mathbb{C})? He chooses an index (\omega\
    \in 1..h).&lt;/li&gt;
&lt;li&gt;There will be a total of (S+h+1) queries to the random oracle,
    at most (the +1 is a technical detail I'll ignore here). We
    discussed in the first bullet point that if there is a repeated
    (m, R) pair in one of the (S) signing queries, it causes a
    "conflict" on the RO output. In the very most pessimistic
    scenario, the probability of this causing our algorithm to fail can
    be no more than (\frac{S+h+1}{n}) for each individual signing
    query, and (\frac{S(S+h+1)}{n}) for all of them (as before we
    use (n) for the size of the output space of the hash function).&lt;/li&gt;
&lt;li&gt;So (\mathbb{B}) will &lt;strong&gt;fork&lt;/strong&gt; (\mathbb{A})'s execution,
    just as for the SIDP (\rightarrow) ECDLP reduction, &lt;strong&gt;at index
    (\omega)&lt;/strong&gt;, without knowing in advance whether (\omega) is
    indeed the index at the which the hash query corresponds to
    (\mathbb{A})'s final output forgery. There's a (1/h)
    chance of this guess being correct. So the "partial success
    probability", if you will, for this first phase, is
    (\epsilon/h), rather than purely (\epsilon), as we had for
    the SIDP case.&lt;/li&gt;
&lt;li&gt;In order to extract (x), though, we need that the execution
    &lt;em&gt;after&lt;/em&gt; the fork, with the new challenge value, at that same index
    (\omega), also outputs a valid forgery. What's the probability
    of both succeeding together? Intuitively it's of the order of
    (\epsilon\^2) as for the SIDP case, but clearly the factor
    (1/h), based on accounting for the guessing of the index
    (\omega), complicates things, and it turns out that the
    statistical argument is rather subtle; you apply what has been
    called the &lt;strong&gt;Forking Lemma&lt;/strong&gt;, described on
    &lt;a href="https://en.wikipedia.org/wiki/Forking_lemma"&gt;Wikipedia&lt;/a&gt;
    and with the clearest statement and proof in
    &lt;a href="https://cseweb.ucsd.edu/~mihir/papers/multisignatures-ccs.pdf"&gt;this&lt;/a&gt;
    paper of Bellare-Neven '06. The formula for the success probability
    of (\mathbb{B}) turns out to be:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;(\epsilon_{\mathbb{B}} = \epsilon\left(\frac{\epsilon}{h} -
\frac{1}{n}\right))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://crypto.stanford.edu/~dabo/cryptobook/"&gt;Boneh-Shoup&lt;/a&gt;
    in Section 19.2 bundle this all together (with significantly more
    rigorous arguments!) into a formula taking account of the Forking
    Lemma, the accounting for collisions in the signing queries, to
    produce the more detailed statement, where (\epsilon) on the
    left here refers to the probability of success of (\mathbb{B}),
    and "DLADv" on the right refers to the probability of success in
    solving the discrete log. The square root term of course corresponds
    to the "reduction" from Schnorr sig. to ECDLP being roughly a
    square:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;(\epsilon \le \frac{S(S+h+1)}{n} + \frac{h+1}{n} +
\sqrt{(h+1)\ \times \ \textrm{DLAdv}})&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So in summary: we see that analysing the full CMA case in detail is
pretty complicated, but by far the biggest take away should be: &lt;strong&gt;The
security reduction for Schnorr sig to ECDLP has the same
(\epsilon\^2) dependency, but is nevertheless far less tight,
because the success probability is also reduced by a factor (\simeq
h) due to having to guess which RO query corresponds to the successful
forgery.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;Minor clarification: basically ignoring the first two terms on the RHS
of the preceding as "minor corrections", you can see that DLAdv is
very roughly (\epsilon\^2/h)&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;The above bolded caveat is, arguably, very practically important, not
just a matter of theory - because querying a hash function is something
that it's very easy for an attacker to do. If the reduction loses
(h) in tightness, and the attacker is allowed (2\^{60}) hash
function queries (note - they can be offline), then we (crudely!) need
60 bits more of security in our underlying cryptographic hardness
problem (here ECDLP); at least, &lt;em&gt;if&lt;/em&gt; we are basing our security model on
the above argument.&lt;/p&gt;
&lt;p&gt;Although I haven't studied it, &lt;a href="https://eprint.iacr.org/2012/029"&gt;the 2012 paper by Yannick
Seurin&lt;/a&gt;
makes an argument (as far as I understand) that we cannot do better than
this, in the random oracle model, i.e. the factor of (h) cannot be
removed from this security reduction by some better kind of argument.&lt;/p&gt;
&lt;h2&gt;Summary - is Schnorr secure?&lt;/h2&gt;
&lt;p&gt;For all that this technical discussion has exposed the non-trivial guts
of this machine, it's still true that the argument provides some pretty
nice guarantees. We can say something like "Schnorr is secure if:"&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The hash function behaves to all intents and purposes like an ideal
    random oracle as discussed&lt;/li&gt;
&lt;li&gt;The ECDLP on our chosen curve (secp256k1 in Bitcoin) is hard to the
    extent we reasonably expect, given the size of the curve and any
    other features it has (in secp256k1, we hope, no features at all!)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This naturally raises the question "well, but how hard &lt;em&gt;is&lt;/em&gt; the
Elliptic Curve discrete logarithm problem, on secp256k1?" Nobody really
knows; there are known, standard ways of attacking it, which are better
than brute force unintelligent search, but their "advantage" is a
roughly known quantity (see e.g. &lt;a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm"&gt;Pollard's
rho&lt;/a&gt;).
What there isn't, is some kind of proof "we know that (\nexists)
algorithm solving ECDLP on (insert curve) faster than (X)".&lt;/p&gt;
&lt;p&gt;Not only don't we know this, but it's even rather difficult to make
statements about analogies. I recently raised the point on
#bitcoin-wizards (freenode) that I thought there must be a relationship
between problems like RSA/factoring and discrete log finding on prime
order curves, prompting a couple of interesting responses, agreeing that
indirect evidence points to the two hardness problems being to some
extent or other connected. Madars Virza kindly pointed out a
&lt;a href="https://wstein.org/projects/john_gregg_thesis.pdf#page=43"&gt;document&lt;/a&gt;
that details some ideas about the connection (obviously this is some
pretty highbrow mathematics, but some may be interested to investigate
further).&lt;/p&gt;
&lt;h2&gt;What about ECDSA?&lt;/h2&gt;
&lt;p&gt;ECDSA (and more specifically, DSA) were inspired by Schnorr, but have
design decisions embedded in them that make them &lt;em&gt;very&lt;/em&gt; different when
it comes to security analysis. ECDSA looks like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(s = k\^{-1}\left(H(m) + rx\right), \quad r=R.x, \ R = kG)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The first problem with trying to analyse this is that it doesn't
conform to the
three-move-sigma-protocol-identification-scheme-converts-to-signature-scheme-via-Fiat-Shamir-transform.
Why? Because the hash value is (H(m)) and doesn't include the
commitment to the nonce, (R). This means that the standard
"attack" on Schnorr, via rewinding and resetting the random oracle
doesn't work. This doesn't of course mean, that it's insecure -
there's another kind of "fixing" of the nonce, in the setting
of(R.x). This latter "conversion function" kind of a random
function, but really not much like a hash function; it's trivially
"semi-invertible" in as much as given an output x-coordinate one can
easily extract the two possible input R-values.&lt;/p&gt;
&lt;p&gt;Some serious analysis has been done on this, for the obvious reason that
(EC)DSA is &lt;strong&gt;very widely used in practice.&lt;/strong&gt; There is work by
&lt;a href="https://www.iacr.org/archive/pkc2003/25670309/25670309.pdf"&gt;Vaudenay&lt;/a&gt;
and
&lt;a href="https://www.cambridge.org/core/books/advances-in-elliptic-curve-cryptography/on-the-provable-security-of-ecdsa/69827A20CC94C54BBCBC8A51DBAF075A"&gt;Brown&lt;/a&gt;
(actually a few papers but I think most behind academic paywalls)  and
most recently &lt;a href="https://dl.acm.org/citation.cfm?doid=2976749.2978413"&gt;Fersch et
al&lt;/a&gt;.
Fersch gave a talk on this work
&lt;a href="https://www.youtube.com/watch?v=5aUPBT4Rdr8"&gt;here&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;The general consensus seems to be "it's very likely secure - but
attempting to get a remotely "clean" security reduction is very
difficult compared to Schnorr".&lt;/p&gt;
&lt;p&gt;But wait; before we trail off with an inaudible mumble of "well, not
really sure..." - there's a crucial logical implication you may not
have noticed. Very obviously, ECDSA is not secure if ECDLP is not secure
(because you just get the private key; game over for any signature
scheme). Meanwhile, in the long argument above we &lt;strong&gt;reduced&lt;/strong&gt; Schnorr to
ECDLP. This means:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;If ECDSA is secure, Schnorr is secure, but we have no security
reduction to indicate the contrary.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The aforementioned Koblitz paper tells an interesting historical
anecdote about all this, when the new DSA proposal was first put forth
in '92 (emphasis mine):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"At the time, the proposed standard --- which soon after became the
first digital signature algorithm ever approved by the industrial
standards bodies --- encountered stiff opposition, especially from
advocates of RSA signatures and from people who mistrusted the NSA's
motives. Some of the leading cryptographers of the day tried hard to
find weaknesses in the NIST proposal. A summary of the most important
objections and the responses to them was published in the Crypto'92
proceedings[17]. The opposition was unable to find any significant
defects in the system. [In retrospect, it is amazing that none of the
DSA opponents noticed that when the Schnorr signature was modified,
the equivalence with discrete logarithms was
lost.]{style="text-decoration: underline;"}"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;More exotic constructions&lt;/h2&gt;
&lt;p&gt;In a future blog post, I hope to extend this discussion to other
constructions, which are based on Schnorr in some way or other, in
particular:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The AOS ring signature&lt;/li&gt;
&lt;li&gt;The Fujisaki-Suzuki, and the cryptonote ringsig&lt;/li&gt;
&lt;li&gt;the Liu-Wei-Wong, and the Monero MLSAG (via Adam Back) ringsig&lt;/li&gt;
&lt;li&gt;The MuSig multisignature&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While these are all quite complicated (to say the least!), so no
guarantee of covering all that, the security arguments follow similar
lines to the discussion in this post. Of course ring signatures have
their own unique features and foibles, so I will hopefully cover that a
bit, as well as the security question.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="coinjoin"></category><category term="bitcoin"></category></entry><entry><title>Payjoin</title><link href="https://joinmarket.me/blog/blog/payjoin/" rel="alternate"></link><published>2018-12-15T00:00:00+01:00</published><updated>2018-12-15T00:00:00+01:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2018-12-15:/blog/blog/payjoin/</id><summary type="html">&lt;p&gt;coinjoins in payments&lt;/p&gt;</summary><content type="html">&lt;h3&gt;PayJoin&lt;/h3&gt;
&lt;h2&gt;PayJoin.&lt;/h2&gt;
&lt;p&gt;You haven't read any other blog posts here? No worries, here's what
you need to know (&lt;em&gt;unless you're an expert, read them anyway...&lt;/em&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A utxo is an "unspent transaction output" - a Bitcoin transaction
    creates one or more of these, and each contains a specific amount of
    Bitcoin. Those outputs get "used up" in the transaction that
    spends them (somewhat like physical coins, someone gives you them in
    a payment to you, then you give them to someone else when you spend
    them; bitcoins aren't coins, utxos are coins; only difference is
    physical coins don't get destroyed in transactions).&lt;/li&gt;
&lt;li&gt;The fees you have to pay for a Bitcoin transaction depend on how
    many bytes it takes up; this is *somewhat* dominated by how many
    inputs you provide, although there are other factors.&lt;/li&gt;
&lt;li&gt;CoinJoin basically means - two or more people provide inputs (utxos)
    to a transaction and co-sign without needing trust, because when
    they sign that the output amounts and addresses are what they
    expect. &lt;strong&gt;Note that CoinJoin requires interaction, almost always.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Traditional "equal-sized" CoinJoin means a bunch of people paying
    &lt;em&gt;themselves&lt;/em&gt; the same fixed amount in a single transaction
    (according to the process just mentioned), with the intention that
    nobody can tell which of the equal sized outputs belong to who
    (basically!).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;The drawbacks of CoinJoin as implemented&lt;/h2&gt;
&lt;p&gt;Current implementations of CoinJoin are of the "equal-sized" variety
(see above). This requires coordination, but it's possible to get a
decent number of people to come together and agree to do a CoinJoin of a
certain fixed amount. The negative is that this kind of transaction is
trivially distinguishable from an "ordinary" transaction, in
particular a payment from one counterparty to another. Here's a typical
Joinmarket CoinJoin (and other implementations are just as, or more,
distinguishable):&lt;/p&gt;
&lt;p&gt;&lt;img alt="Equal-outs-coinjoin-example" src="/web/20200803124759im_/https://joinmarket.me/static/media/uploads/.thumbnails/screenshot_from_2019-01-18_15-00-33.png/screenshot_from_2019-01-18_15-00-33-807x433.png"&gt;{width="807"
height="433"}&lt;/p&gt;
&lt;p&gt;The biggest flag of "this is CoinJoin" is exactly the multiple
equal-value (0.18875417 here) outputs that are the core premise of the
idea, that give the anonymity. Here, you get anonymity in an "anonymity
set" of all participants of &lt;em&gt;this&lt;/em&gt; transaction, first, but through
repeated rounds, you &lt;em&gt;kind of&lt;/em&gt; get a much bigger anonymity set,
ultimately of all participants of that CoinJoin implementation in the
absolute best scenario. But it's still only a small chunk of Bitcoin
usage generally.&lt;/p&gt;
&lt;p&gt;And while this obviously gets better if more people use it, there is a
limit to that thinking: because &lt;strong&gt;all participants are forced to use the
same denomination for any single round&lt;/strong&gt;, it isn't possible to fold in
the payments you're doing using Bitcoin as a currency (don't laugh!)
into these CoinJoin rounds (notice: this problem mostly disappears with
blinded amounts).&lt;/p&gt;
&lt;p&gt;So a world where "basically everyone uses CoinJoin" is cool for
privacy, but could end up pretty bad for scalability, because these
transactions are &lt;em&gt;in addition to&lt;/em&gt; the normal payments.&lt;/p&gt;
&lt;p&gt;Also, the fact that these transactions are trivially watermarked means
that, if the blockchain analyst is not able to "crack" and unmix such
transactions, he can at least isolate them in analysis. That's
something; "these coins went from Exchange A to wallet B and then into
this mixset" may be a somewhat negative result, but it's still a
result. There are even noises made occasionally that coins might be
blocked from being sent to certain exchange-type entities if they're
seen to have come from a "mixer" (doesn't matter that CoinJoin is
&lt;em&gt;trustless&lt;/em&gt; mixing here; just that it's an activity specific for
obfuscation).&lt;/p&gt;
&lt;p&gt;I don't mean to scaremonger - I have used such CoinJoin for years
(measured in the thousands) and will continue to do so, and never had
payments blocked because of it. But this is another angle that must be
borne in mind.&lt;/p&gt;
&lt;p&gt;So let's say our primary goal is to minimize the negative privacy
effects of blockchain analysis; can we do better? It's debatable, but
we &lt;em&gt;do&lt;/em&gt; have another angle of attack.&lt;/p&gt;
&lt;h2&gt;Hiding in a much bigger crowd ... ?&lt;/h2&gt;
&lt;p&gt;[One angle is to make your behaviour look more like other, non-coinjoin
transactions]{style="text-decoration: underline;"}. (For the
philosophically/abstract inclined people, &lt;a href="https://web.archive.org/web/20200803124759/https://joinmarket.me/blog/blog/the-steganographic-principle/"&gt;this post might be of
interest&lt;/a&gt;,
but it sidetracks us here, so - later!). Let's think of the naive way
to do that. Suppose just Alice and Bob make a 2 party CoinJoin:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.05 BTC ---&amp;gt;|   0.05 BTC  3AliceSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.05 BTC ---&amp;gt;|   0.05 BTC  3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This first attempt is a clear failure - it "looks like an ordinary
payment" &lt;em&gt;only&lt;/em&gt; in the sense that it has two outputs (one change, one
payment). But the failure is not &lt;em&gt;just&lt;/em&gt; the obvious, that the output
amounts are equal and so "obviously CoinJoin". There's another aspect
of that failure, illustrated here:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.01 BTC ---&amp;gt;|   0.05 BTC  3AliceSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.04 BTC ---&amp;gt;|   0.06 BTC  3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.03 BTC ---&amp;gt;|&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.03 BTC ---&amp;gt;|&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This at least is &lt;em&gt;more&lt;/em&gt; plausible as a payment, but it shows the
&lt;strong&gt;subset sum&lt;/strong&gt; problem that I was describing in my &lt;a href="https://web.archive.org/web/20200803124759/https://joinmarket.me/blog/blog/coinjoinxt/"&gt;CoinJoinXT
post&lt;/a&gt;
- and trying to solve with CoinJoinUnlimited (i.e. using a Lightning
channel to break the subset sum problem and feed-back the LN privacy
onto the main chain). While the blockchain analyst &lt;em&gt;could&lt;/em&gt; interpret
this as a payment, semi-reasonably, of 0.05 btc by one participant, he
could also notice that there are two subsets of the inputs that add up
to 0.05, 0.06. And also splitting the outputs doesn't fundamentally
solve that problem, notice (they'd also have to split into subsets),
and it would anyway break the idea of "looking like a normal payment"
(one payment, one change):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.01 BTC ---&amp;gt;|   0.011 BTC  3AliceSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.04 BTC ---&amp;gt;|   0.022 BTC  3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.03 BTC ---&amp;gt;|   0.039 BTC  3Alice2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.03 BTC ---&amp;gt;|   0.038 BTC  3Bob2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;After you think about this problem for a while you come to the
conclusion - only if there's actually a transfer of coins from one
party to the other is it solved. Hence
&lt;a href="https://web.archive.org/web/20200803124759/https://joinmarket.me/blog/blog/coinjoinxt/"&gt;CoinJoinXT&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But also, hence &lt;strong&gt;PayJoin&lt;/strong&gt; - why not actually do a CoinJoin [while you
are making a payment?]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;[]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;h2&gt;PayJoin advantages&lt;/h2&gt;
&lt;p&gt;I'm not sure who first thought of doing CoinJoins (see bullet point at
start) of this particular flavour, but a &lt;a href="https://blockstream.com/2018/08/08/improving-privacy-using-pay-to-endpoint/"&gt;blogpost from Matthew
Haywood&lt;/a&gt;
last summer detailed an implementation approach which came out of a
technical workshop in London shortly before, and a little later a
&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki"&gt;BIP&lt;/a&gt;
was put out by Ryan Havar.&lt;/p&gt;
&lt;p&gt;The central idea is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Let Bob do a CoinJoin with his customer Alice - he'll provide at
    least one utxo as input, and that/those utxos will be consumed,
    meaning that in net, he will have no more utxos after the
    transaction than before, and an obfuscation of ownership of the
    inputs will have happened [without it looking different from an
    ordinary payment.]{style="text-decoration: underline;"}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before we look in detail at the advantages, it's worth answering my
earlier question ("Why not actually do a CoinJoin while you are making
a payment?") in the negative: it's not easy to coordinate that. It
means that either (a) all wallets support it and have a way for
*anyone* to connect to *anyone* to negotiate this (2-party) CoinJoin
or (b) it's only limited to peer to peer payments between owners of a
specific wallet that has a method for them to communicate. So let's be
clear: this is not going to suddently take over the world, but
incremental increases in usage could be tremendously valuable (I'll
explain that statement shortly; but you probably already get
it).[]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Advantage 1: Hiding the payment amount&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is what will immediately stand out from looking at the idea. Bob
"chips in" a utxo (or sometimes more than one). So the payment
&lt;em&gt;output&lt;/em&gt; will be more than the actual payment, and it will be profoundly
unobvious what the true payment amount was. Here's an example:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.05 BTC ---&amp;gt;|   0.04 BTC  3AliceSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.09 BTC ---&amp;gt;|   0.18 BTC  3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.08 BTC ---&amp;gt;|&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Now, actually, Alice paid Bob 0.1 BTC using 0.09 and 0.05, getting back
0.04 change. But what does a blockchain analyst think? His first
interpretation will certainly be that there is a payment &lt;em&gt;either&lt;/em&gt; of
0.04 BTC or 0.18 BTC, by the owner of the wallet containing all the
inputs. Now, it probably seems very unlikely that the &lt;em&gt;payment&lt;/em&gt; was 0.04
and the &lt;em&gt;change&lt;/em&gt; 0.18. Why? Because, if the payment output were 0.04,
why would you use all three of those utxos, and not just the first, say?
(0.05). This line of reasoning we have called "UIH1" in the comments
to &lt;a href="https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e"&gt;this
gist&lt;/a&gt;
(h/t Chris Belcher for the nomenclature - "unnecessary input
heuristic") for the details. To be fair, this kind of deduction by a
blockchain analyst is unreliable, as it depends on wallet selection
algorithms; many are not nearly so simplistic that this deduction would
be correct. But possibly combined with wallet fingerprinting and
detailed knowledge of wallet selection algorithms, it's one very
reasonable line of attack to finding the change output and hence the
payment output.&lt;/p&gt;
&lt;p&gt;For those interested in the "weeds" I've reproduced the key points
about this UIH1 and UIH2 (probably more important) including stats
collected by LaurentMT of oxt.me, in an "Appendix" section at the end
of this post.&lt;/p&gt;
&lt;p&gt;Anyway, what else &lt;em&gt;could&lt;/em&gt; the payment amount be, in the transaction
above? As well as 0.04 and 0.18, there is 0.09 and 0.01. Do you see the
reasoning? &lt;em&gt;If&lt;/em&gt; we assume that PayJoin is a possibility, then one party
could be consuming 0.09 and 0.08 and getting back 0.01. And similarly
for other contributions of inputs. In the simplest case, I would claim
there are 4 potential payment amounts if there are only two inputs and
we assume that one of the two is owned by the receiver. For the
blockchain analyst, this is a huge mess.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Advantage 2 - breaking Heuristic 1&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I discussed Heuristic 1 in the &lt;a href="%22https://joinmarket.me/blog/blog/coinjoinxt/"&gt;CoinJoinXT
post&lt;/a&gt;. Simple
description: people (analysts) assume that all the inputs to any
particular transaction are owned by one wallet/owner; i.e. they assume
coinjoin is not used, usually. Following the overall logic of our
narrative here, it's obvious what the main point is with PayJoin - we
break the heuristic &lt;em&gt;without flagging to the external observer that the
breakage has occurred. &lt;/em&gt;This is enormously important, even if the
breakage of the assumption of common input ownership on its own seems
rather trivial (especially if PayJoin is used by only few people), with
only 2 counterparties in each transaction.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Advantage 3 - Utxo sanitization&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This one might not occur to you immediately, at all, but is actually
really nice. Consider the plight of the merchant who sells 1,000 widgest
per day for Bitcoin. At the end of the day he has 1,000 utxos that he
has to spend. Perhaps the next day he pays his supplier with 80% of the
money; he'll have to construct a transaction (crudest scenario) with
800 inputs. It's not just that that costs a lot in fees (it does!); we
can't really directly solve that problem (well - use layer 2! - but
that's another blog post); but we can solve something else about it -
the privacy. The merchant immediately links &lt;em&gt;almost&lt;/em&gt; &lt;em&gt;all&lt;/em&gt; of his
payments in the 800-input payout transaction - horrible!&lt;/p&gt;
&lt;p&gt;But PayJoin really helps this; each payment that comes in can consume
the utxo of the last payment. Here are two fictitious widget payments in
sequence to illustrate; Bob's utxos are bolded for clarity:&lt;/p&gt;
&lt;p&gt;[PayJoin 1 - Alice pays Bob 0.1 for a
widget:]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.05 BTC ---&amp;gt;|   0.04 BTC  3AliceSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.09 BTC ---&amp;gt;|   0.18 BTC  3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.08 BTC ---&amp;gt;|&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;(notice: Bob used up one utxo and created one utxo - no net change)&lt;/p&gt;
&lt;p&gt;[PayJoin2 - Carol pays Bob 0.05 for a discount
widget:]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.01 BTC ---&amp;gt;|   0.02 BTC  3CarolSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.06 BTC ---&amp;gt;|   0.23 BTC  3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.18 BTC ---&amp;gt;|&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This would be a kind of snowball utxo in the naive interpretation, that
gets bigger and bigger with each payment. In the fantasy case of every
payment being PayJoin, the merchant has a particularly easy wallet to
deal with - a wallet that only ever has 1 coin/utxo! (I know it's quite
dubious to think that nobody could trace this sequence, there are other
potential giveaways &lt;em&gt;in this case&lt;/em&gt; than just Heuristic 1; but with
Heuristic 1 gone, you have a lot more room to breathe, privacy-wise).&lt;/p&gt;
&lt;p&gt;It's worth mentioning though that the full snowball effect can damage
the anonymity set: after several such transactions, Bob's utxo is
starting to get big, and may dwarf other utxos used in the transaction.
In this case, the transaction will violate "UIH2" (you may remember
UIH1 - again, see the Appendix for more details on this) because a
wallet &lt;em&gt;probably&lt;/em&gt; wouldn't choose other utxos if it can fulfil the
payment with only one. So this may create a dynamic where it's better
to mix PayJoin with non-PayJoin payments.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Advantage 4 - hiding in (and being helpful to) the large crowd&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;"...but incremental increases in usage could be tremendously
valuable..." - let's be explicit about that now. If you're even
reasonably careful, these PayJoin transactions will be basically
indistinguishable from ordinary payments (see earlier comments about
UIH1 and UIH2 here, which don't contradict this statement). It's a
good idea to use decide on a specific locktime and sequence value that
fits in with commonly used wallets (transaction version 2 makes the most
sense). Now, here's the cool thing: suppose a small-ish uptake of this
was publically observed. Let's say 5% of payments used this method.
&lt;strong&gt;The point is that nobody will know which 5% of payments are PayJoin&lt;/strong&gt;.
That is a great achievement (one that we're not yet ready to achieve
for some other privacy techniques which use custom scripts, for example;
that may happen after Schnorr/taproot but not yet), because &lt;em&gt;it means
that all payments, including ones that don't use PayJoin, gain a
privacy advantage!&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Merchants? Automation?&lt;/h2&gt;
&lt;p&gt;The aforementioned
&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki"&gt;BIP79&lt;/a&gt;
tries to address how this might work in a standardized protocol;
there's probably still significant work to do before the becomes
actualized. As it stands, it may be enough to have the following
features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some kind of "endpoint" (hence "pay to endpoint"/p2ep) that a
    customer/payer can connect to encoded as some kind of URL. A Tor
    hidden service would be ideal, in some cases. It could be encoded in
    the payment request similar to BIP21 for example.&lt;/li&gt;
&lt;li&gt;Some safety measures on the server side (the merchant/receiver) to
    make sure that an attacker doesn't use the service to connect,
    request, and block: thus enumerating the server's (merchant's)
    utxos. BIP79 has given one defensive measure against this that may
    be sufficient, Haywood's blog post discussed some more advanced
    ideas on that score.&lt;/li&gt;
&lt;li&gt;To state the obvious friction point - wallets would have to
    implement such a thing, and it is not trivial compared to features
    like RBF which are pure Bitcoin.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Who pays the fees?&lt;/h2&gt;
&lt;p&gt;The "snowball effect" described above, where the merchant always has
one utxo, may lead you to think that we are saving a lot of fees (no 800
input transactions). But not true except because of some second/third
order effect: every payment to the merchant creates a utxo, and every
one of those must be paid for in fees when consumed in some transaction.
The effect here is to pay those fees slowly over time. And it's left
open to the implementation how to distribute the bitcoin transaction
fees of the CoinJoin. Most logically, each participant pays according to
the amount of utxos they consume; I leave the question open here.&lt;/p&gt;
&lt;h2&gt;Implementation in practice&lt;/h2&gt;
&lt;p&gt;As far as I know as of this writing (mid-January 2019), there are two
implementations of this idea in the wild. One is from Samourai Wallet,
called
&lt;a href="https://samouraiwallet.com/stowaway"&gt;Stowaway&lt;/a&gt;
and the other is in
&lt;a href="https://github.com/Joinmarket-Org/joinmarket-clientserver/blob/master/docs/PAYJOIN.md"&gt;Joinmarket&lt;/a&gt;
as of version 0.5.2 (just released).&lt;/p&gt;
&lt;p&gt;I gave a demo of the latter in my last &lt;a href="https://web.archive.org/web/20200803124759/https://joinmarket.me/blog/blog/payjoin-basic-demo/"&gt;post on this
blog&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In both cases this is intended for peers to pay each other, i.e. it's
not something for large scale merchant automation (as per discussion in
previous section).&lt;/p&gt;
&lt;p&gt;It requires communication between parties, as does any CoinJoin, except
arguably
&lt;a href="https://web.archive.org/web/20200803124759/https://joinmarket.me/blog/blog/snicker/"&gt;SNICKER&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The sender of the payment always sends a non-CoinJoin payment
transaction to start with; it's a convenient/sane thing to do, because
if connection problems occur, or software problems, the receiver can
simply broadcast this "fallback" payment instead.&lt;/p&gt;
&lt;p&gt;In Joinmarket specifically, the implementation looks crudely like this:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sender            Receiver&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pubkey+versionrange --&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;-- pubkey and version&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(ECDH e2e encryption set up)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fallback tx ---&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;--- PayJoin tx partial-signed&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;co-signs and broadcasts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Before starting that interchange of course, the receiver must "send"
(somehow) the sender the payment amount and destination address, as well
as (in Joinmarket) an ephemeral "nick" to communicate over the message
channel. Details here of course will vary, but bear in mind that as any
normal payment, there &lt;em&gt;must &lt;/em&gt;be some mechanism for receiver to
communicate payment information to the sender.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This is another nail in the coffin of blockchain analysis. If 5% of us
do this, it will &lt;em&gt;not&lt;/em&gt; be safe to assume that a totally ordinary looking
payment is not a CoinJoin. That's basically it.&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------&lt;/p&gt;
&lt;h3&gt;Appendix: Unnecessary Input Heuristics&lt;/h3&gt;
&lt;p&gt;The health warning to this reasoning has already been given: wallets
will definitely not &lt;em&gt;always&lt;/em&gt; respect the logic given below - I know of
at least one such case (h/t David Harding). However I think it's worth
paying attention to (this is slightly edited from the comment section of
the referenced gist):&lt;/p&gt;
&lt;p&gt;[Definitions:]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;"UIH1" : one output is smaller than any input. This heuristically
implies that &lt;em&gt;that&lt;/em&gt; output is not a payment, and must therefore be a
change output.&lt;/p&gt;
&lt;p&gt;"UIH2": one input is larger than any output. This heuristically
implies that &lt;em&gt;no output&lt;/em&gt; is a payment, or, to say it better, it implies
that this is not a normal wallet-created payment, it's something
strange/exotic.&lt;/p&gt;
&lt;p&gt;Note: UIH2 does not necessarily imply UIH1.&lt;/p&gt;
&lt;p&gt;~~ ~~&lt;/p&gt;
&lt;p&gt;So we just have to focus on UIH2. Avoiding UIH1 condition is nice,
because it means that both outputs could be the payment; but in any case
the normal blockchain analysis will be wrong about the payment amount.
If we don't avoid the UIH2 condition, though, we lose the
steganographic aspect which is at least 50% of the appeal of this
technique.&lt;/p&gt;
&lt;p&gt;Joinmarket's current implementation does its best to avoid UIH2, but
proceeds with PayJoin anyway even if it can't. The reasoning is
partially as already discussed: not all wallets follow this logic; the
other part of the reasoning is the actual data, as we see next:&lt;/p&gt;
&lt;p&gt;[Data collection from LaurentMT:]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;From block 552084 to block 552207 (One day: 01/12/2018)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Txs with 2 outputs and more than 1 input = 35,349&lt;ul&gt;
&lt;li&gt;UIH1 Txs (identifiable change output) = 19,020 (0.54)&lt;/li&gt;
&lt;li&gt;!UIH1 Txs = 16,203 (0.46)&lt;/li&gt;
&lt;li&gt;Ambiguous Txs = 126 (0.00)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From block 552322 to block 553207 (One week: 03/12/2018 - 09/12/2018)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Txs with 2 outputs and more than 1 input = 268,092&lt;ul&gt;
&lt;li&gt;UIH1 Txs (identifiable change output) = 145,264 (0.54)&lt;/li&gt;
&lt;li&gt;!UIH1 Txs = 121,820 (0.45)&lt;/li&gt;
&lt;li&gt;Ambiguous Txs = 1,008 (0.00)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And here are a few stats for UIH2:&lt;/p&gt;
&lt;p&gt;Stats from block 552084 to block 552207 (One day: 01/12/2018)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Txs with 2 outputs and more than 1 input = 35,349&lt;ul&gt;
&lt;li&gt;UIH2 Txs = 10,986 (0.31)&lt;/li&gt;
&lt;li&gt;!UIH2 Txs = 23,596 (0.67)&lt;/li&gt;
&lt;li&gt;Ambiguous Txs = 767 (0.02)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From block 552322 to block 553207 (One week: 03/12/2018 - 09/12/2018)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Txs with 2 outputs and more than 1 input = 268,092&lt;ul&gt;
&lt;li&gt;UIH2 Txs = 83,513 (0.31)&lt;/li&gt;
&lt;li&gt;!UIH2 Txs = 178,638 (0.67)&lt;/li&gt;
&lt;li&gt;Ambiguous Txs = 5,941 (0.02)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="waxwings Blog"></category><category term="coinjoin"></category><category term="bitcoin"></category></entry><entry><title>CoinjoinXT</title><link href="https://joinmarket.me/blog/blog/coinjoinxt/" rel="alternate"></link><published>2018-09-15T00:00:00+02:00</published><updated>2018-09-15T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2018-09-15:/blog/blog/coinjoinxt/</id><summary type="html">&lt;p&gt;a proposal for multi-transaction coinjoins.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;CoinJoinXT&lt;/h3&gt;
&lt;h1&gt;CoinJoinXT - a more flexible, extended approach to CoinJoin&lt;/h1&gt;
&lt;p&gt;*Ideas were first discussed
&lt;a href="https://gist.github.com/AdamISZ/a5b3fcdd8de4575dbb8e5fba8a9bd88c"&gt;here&lt;/a&gt;.
Thanks again to arubi on IRC for helping me flesh them out.\
*&lt;/p&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;We assume that the reader is familiar with CoinJoin as a basic idea -
collaboratively providing inputs to a transactions so that it may be
made difficult or impossible to distinguish ownership/control of the
outputs.&lt;/p&gt;
&lt;p&gt;The way that CoinJoin is used in practice is (today mainly using
JoinMarket, but others over Bitcoin's history) is to create large-ish
transactions with multiple outputs of exactly the same amount. This can
be called an "intrinsic fungibility" model - since, although the
transactions created are unambiguously recognizable as CoinJoins, the
indistinguishability of said equal outputs is kind of "absolute".&lt;/p&gt;
&lt;p&gt;However, as partially discussed in the earlier blog post &lt;a href="https://web.archive.org/web/20200603010653/https://joinmarket.me/blog/blog/the-steganographic-principle/"&gt;"the
steganographic
principle"&lt;/a&gt;,
there's at least an argument for creating fungibility in a less
explicit way - that is to say, creating transactions that have a
fungibility effect but aren't &lt;em&gt;necessarily&lt;/em&gt; visible as such - they
&lt;em&gt;may&lt;/em&gt; look like ordinary payments. I'll call this the &lt;em&gt;deniability&lt;/em&gt;
model vs the &lt;em&gt;intrinsic fungibility&lt;/em&gt; model. It's harder to make this
work, but it has the possibility of being much more effective than the
&lt;em&gt;intrinsic fungibility model&lt;/em&gt;, since it gives the adversary (who we'll
talk about in a minute) an additional, huge problem: he doesn't even
know where to start.&lt;/p&gt;
&lt;h2&gt;The adversary's assumptions&lt;/h2&gt;
&lt;p&gt;In trying to create privacy, we treat the "blockchain analyst" as our
adversary (henceforth just "A").&lt;/p&gt;
&lt;p&gt;Blockchain analysis consists, perhaps, of two broad areas (not sure
there is any canonical definition); we can call the first one
"metadata", vaguely, and think of it is every kind of data that is not
directly recorded on the blockchain, such as personally identifying
information, exchange records etc, network info etc. In practice, it's
probably the most important. The second is stuff recorded directly on
the blockchain - pseudonyms (scriptPubKeys/addresses) and amount
information (on non-amount-blinded blockchains as Bitcoin's is
currently; for a discussion about that see this earlier &lt;a href="https://web.archive.org/web/20200603010653/https://joinmarket.me/blog/blog/the-steganographic-principle/"&gt;blog
post&lt;/a&gt;);
note that amount information includes the implicit amount - network fee.&lt;/p&gt;
&lt;p&gt;Timing information perhaps straddles the two categories, because while
transactions are (loosely) timestamped, there is also the business of
trying to pick up timing and perhaps geographic information from
snooping the P2P network.&lt;/p&gt;
&lt;p&gt;With regard to that second category, the main goal of A is to correlate
ownership of different utxos. An old
&lt;a href="https://cseweb.ucsd.edu/~smeiklejohn/files/imc13.pdf"&gt;paper&lt;/a&gt;
of Meiklejohn et al 2013 identified two Heuristics (let's call them
probabilistic assumptions), of which the first was by far the most
important:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Heuristic 1 - All inputs to a transaction are owned by the same
    party&lt;/li&gt;
&lt;li&gt;Heuristic 2 - One-time change addresses are owned by the same party
    as the inputs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The second is less important mainly because it had to be caveat-ed quite
a bit and wasn't reliable in naive form; but, identification of change
addresses generally is a plausible angle for A. The first has been, as
far as I know, the bedrock of blockchain analysis and has been referred
to in many other papers, was mentioned in Satoshi's whitepaper, and you
can see one functional example at the long-existent website
&lt;a href="https://www.walletexplorer.com/"&gt;walletexplorer&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[But I think it's important to observe that this list is
incomplete.]{style="text-decoration: underline;"}[]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;I'll now add two more items to the list; the first is omitted because
it's elementary, the other, because it's subtle (and indeed you might
find it a bit dumb at first sight):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Heuristic/Assumption 0&lt;/code&gt;: All inputs controlled by only one pubkey
    are unilaterally controlled&lt;/li&gt;
&lt;li&gt;Heuristic/Assumption 1: All inputs to a transaction are owned by the
    same party&lt;/li&gt;
&lt;li&gt;Heuristic/Assumption 2(?): One-time change addresses are owned by
    the same party as the inputs&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Heuristic/Assumption 3&lt;/code&gt;: Transfer of ownership between parties in
    one transaction implies payment&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, "Heuristic/Assumption" because assumption is probably a better
word for all of these generally, but I want to keep the existing
nomenclature, the "?" for 2 is simply because, as mentioned, this one
is problematic (although still worthy of consideration).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assumption 0&lt;/strong&gt;: basically, that if it's not multisig, was never fully
safe; there was always &lt;a href="https://en.wikipedia.org/wiki/Shamir's_Secret_Sharing"&gt;Shamir's secret
sharing&lt;/a&gt;
to share shards of a key, albeit that's very rarely used, and you can
argue pedantically that full reconstruction means unilateral control.
But Assumption 0 is a lot less safe now due to the recent
&lt;a href="https://eprint.iacr.org/2018/472"&gt;work&lt;/a&gt;
by Moreno-Sanchez et al. which means, at the very least, that 2 parties
can easily use a 2-party computation based on the Paillier encryption
system to effectively use a single ECDSA pubkey as a 2-2 multisig. So
this assumption is generally unspoken, but in my opinion is now
generally important (i.e. not necessarily correct!).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assumption 3&lt;/strong&gt;: this is rather strange and looks tautological; I could
have even written "transfer of ownership between parties in one
transaction implies transfer of ownership" to be cheeky. The point, if
it is not clear to you, will become clear when I explain what
"CoinJoinXT" means.&lt;/p&gt;
&lt;p&gt;Our purpose, now, is to make A's job harder &lt;strong&gt;by trying to invalidate
all of the above assumptions at once&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Quick refresher: BIP141&lt;/h2&gt;
&lt;p&gt;This has been discussed in other blog posts about various types of
"CoinSwap", so I won't dwell on it.&lt;/p&gt;
&lt;p&gt;Segwit fixes transaction malleability
(&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki"&gt;BIP141&lt;/a&gt;,
along with BIP143,144 were the BIPs that specified segwit). One of the
most important implications of this is explained directly in BIP 141
itself, to
&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#Trustfree_unconfirmed_transaction_dependency_chain"&gt;quote&lt;/a&gt;
from it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Two parties, Alice and Bob, may agree to send certain amount of
Bitcoin to a 2-of-2 multisig output (the "funding transaction").
Without signing the funding transaction, they may create another
transaction, time-locked in the future, spending the 2-of-2 multisig
output to third account(s) (the "spending transaction"). Alice and
Bob will sign the spending transaction and exchange the signatures.
After examining the signatures, they will sign and commit the funding
transaction to the blockchain. Without further action, the spending
transaction will be confirmed after the lock-time and release the
funding according to the original contract.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In short, if we agree a transaction, then we can fix its txid and sign
transactions which use its output(s). The BIP specifically references
the Lightning Network as an example of the application of this pattern,
but of course it's not restricted to it. We can have Alice and Bob
agree to any arbitrary set of transactions and pre-sign them, in
advance, with all of them having the funding transaction as the root.&lt;/p&gt;
&lt;h2&gt;CoinJoinXT - the basic case&lt;/h2&gt;
&lt;p&gt;CoinJoin involves 2 or more parties contributing their utxos into 1
transaction, but using the above model they can do the same to a funding
transaction, but then pre-sign a set of more than one spending
transaction. Here's a simple schematic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;A 1btc ---&amp;gt;&lt;/span&gt;
&lt;span class="err"&gt;              F (2,2,A,B) --+&lt;/span&gt;
&lt;span class="err"&gt;B 1btc ---&amp;gt;                 |&lt;/span&gt;
&lt;span class="err"&gt;                            |&lt;/span&gt;
&lt;span class="err"&gt;                            +--&amp;gt;[Proposed transaction graph (PTG) e.g. -&amp;gt;TX1-&amp;gt;TX2-&amp;gt;TX3 ..]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In human terms, you can envisage that: Alice and Bob would like to start
to negotiate a set of conditional contracts about what happens to their
money. Then they go through these steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;One side proposes F (the funding transaction) and a full graph of
    unsigned transactions to fill out the PTG above; e.g. Alice
    proposes, Bob and Alice share data (pubkeys, destination addresses).
    Note that the set doesn't have to be a chain (TX1-&gt;TX2-&gt;TX3...),
    it can be a tree, but each transaction must require sign-off of both
    parties (either, at least one 2-2 multisig utxo, or at least one
    utxo whose key is owned by each party).&lt;/li&gt;
&lt;li&gt;They exchange signatures on all transactions in the PTG, in either
    order. Of course, they abort if signatures don't validate.&lt;/li&gt;
&lt;li&gt;With this in place (i.e. &lt;strong&gt;only&lt;/strong&gt; after valid completion of (2)),
    they both sign (in either order) F.&lt;/li&gt;
&lt;li&gt;Now both sides have a valid transaction set, starting with F. Either
    or both can broadcast them. [The transactions are &lt;em&gt;all&lt;/em&gt; guaranteed
    to occur as long as at least one of them wants
    it]{style="text-decoration: underline;"}. Contrariwise, &lt;strong&gt;none&lt;/strong&gt; of
    them is valid without F being broadcast.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This does achieve one significant thing: &lt;strong&gt;one transaction such as TX2
can transfer coins to, say, Bob's wallet, giving Alice nothing; and yet
we can still get the overall effect of a CoinJoin. In other words,
we've opened up the possibility to violate Heuristic 3 as well as
Heuristic 1, in the same (short) interaction.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This construction works fine if &lt;em&gt;all&lt;/em&gt; inputs used in transactions in the
PTG are descendants of F; but this makes the construction very limited.
So we'll immediately add more details to allow a more general use-case,
in the next section.&lt;/p&gt;
&lt;h2&gt;Introducing Promises&lt;/h2&gt;
&lt;p&gt;If we allowed any of the transactions (TX1, TX2, ...) in the PTG in our
previous example to have an input which did &lt;em&gt;not&lt;/em&gt; come from the funding
transaction F, then we would have introduced a risk; if Alice added utxo
UA to, say, TX2, then, before Bob attempted to broadcast TX2, she could
double spend it. This would break the atomicity of the graph, which was
what allowed the crucial additional interesting feature (in bold,
above): that an individual transaction could transfer funds to one
party, without risks to the other. To address this problem, we call
these additional inputs &lt;strong&gt;promise utxos&lt;/strong&gt; and make use of &lt;strong&gt;refund
transactions&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;A 1btc ---&amp;gt;&lt;/span&gt;
&lt;span class="err"&gt;              F (2,2,A,B) ---&lt;/span&gt;
&lt;span class="err"&gt;B 1btc ---&amp;gt;                 |       +--&amp;gt; external payout 0.5 btc to Bob&lt;/span&gt;
&lt;span class="err"&gt;                            |       |&lt;/span&gt;
&lt;span class="err"&gt;                            +-&amp;gt;[TX1 --&amp;gt; TX2 --&amp;gt; TX3 --&amp;gt; TX4]&lt;/span&gt;
&lt;span class="err"&gt;                                         |       ^&lt;/span&gt;
&lt;span class="err"&gt;                                         |       |&lt;/span&gt;
&lt;span class="err"&gt;                                         |       |&lt;/span&gt;
&lt;span class="err"&gt;                                         |       +--- utxo A1&lt;/span&gt;
&lt;span class="err"&gt;                                         |&lt;/span&gt;
&lt;span class="err"&gt;                                         +--&amp;gt; refund locktime M, pay out *remaining* funds to A: 1btc, B: 0.5btc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In words: if, between the negotiation time and the time of broadcast of
TX3, Alice spends A1 in some other transaction, Bob will still be safe;
after block M he can simply broadcast the presigned refund transaction
to claim the exact number of coins he is owed at that point in the
graph.&lt;/p&gt;
&lt;p&gt;The above addresses the case of a single external input being included
in a chain of transactions in the PTG (here, TX1,2,3,4). Extending this,
and generalising to allowing external inputs in many transactions, is
straightforward; we can add such in-PTG backouts at every step,
redeeming all remaining funds to parties according to what they're
owed.&lt;/p&gt;
&lt;p&gt;To summarize this section and how it differs from the original, simpler
construction:&lt;/p&gt;
&lt;p&gt;Alice and Bob have a choice:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;They can set up a fully trustless PTG, without promises. They are
    then guaranteed to achieve "all or nothing": either all
    cooperative signing works, then all transactions can be broadcast
    (as long as &lt;em&gt;at least one&lt;/em&gt; of them wants to), or nothing
    (including F) is broadcast at all.&lt;/li&gt;
&lt;li&gt;They can set up a PTG including promises from one or both parties.
    Now they don't get "all or nothing" but only ensure that the
    transactions that complete are a subset, in order, from the start F.
    To achieve this they add presigned backouts at (probably every)
    step, so that if the chain "breaks" somewhere along, they will
    recover all the funds remaining that are owed to them.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The tradeoff is: (2) is not perfectly atomic, but it allows the
transaction graph to include utxos from outside of F's ancestory,
particularly useful for privacy applications. In a sequence of 10
coinjoins, you may be happy to risk that TXs 6-10 don't end up
happening, if it doesn't cost you money. Case (2) is more likely to be
of interest.&lt;/p&gt;
&lt;h2&gt;Interlude - overview of features of CoinJoinXT&lt;/h2&gt;
&lt;p&gt;There's a large design space here.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We can have N parties, not just 2.&lt;/li&gt;
&lt;li&gt;We can have as many transactions as we like.&lt;/li&gt;
&lt;li&gt;We can have a tree with F as root, rather than a chain.&lt;/li&gt;
&lt;li&gt;We can have as many promise utxos from any of the N parties as we
    like.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A mixture of these features may give different tradeoffs in terms of
&lt;em&gt;intrinsic fungibility&lt;/em&gt; vs &lt;em&gt;deniability&lt;/em&gt; vs &lt;em&gt;cost&lt;/em&gt;; the tradeoff
discussed in the introduction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interactivity&lt;/strong&gt; - unlike either a CoinSwap of types discussed earlier
in this blog, or doing multiple CoinJoins (to get a better fungibility
effect than just a single one), this only requires one "phase" of
interactivity (in terms of rounds, it may be 3). The two parties
connect, exchange data and signatures, and then immediately disconnect.
(This is what I called no-XBI in the previous &lt;a href="https://web.archive.org/web/20200603010653/https://joinmarket.me/blog/blog/the-half-scriptless-swap/"&gt;blog
post&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boundary&lt;/strong&gt; - the adversary A, as was hinted at in the introduction, in
this model, will not necessarily be able to easily see on the blockchain
where the start and end points of this flow of transactions was. To the
extent that this is true, it's an enormous win, but more on this later.&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;img alt="ExampleCJXT" src="../../../../../../20200603010653im_/https:/joinmarket.me/static/media/uploads/.thumbnails/onchaincontract3.png/onchaincontract3-614x422.png"&gt;{width="614"
height="422"}&lt;/p&gt;
&lt;p&gt;Here we are still restricting to 2 parties for simplicity of the
diagram. There is still a chain of 4 TXs, but here we flesh out the
inputs and outputs. About colors:&lt;/p&gt;
&lt;p&gt;Blue txos are co-owned by the two parties, envisioned as 2 of 2 multisig
(although as originally mentioned, the technical requirement is only
that each transaction is signed by both parties).&lt;/p&gt;
&lt;p&gt;Red inputs are &lt;strong&gt;promise utxos&lt;/strong&gt; as described in the earlier section.&lt;/p&gt;
&lt;p&gt;Each promise has a corresponding backout transaction pre-signed as
output consuming the bitcoins of the
[previous]{style="text-decoration: underline;"} transaction to the one
consuming that promise.&lt;/p&gt;
&lt;p&gt;Notice that this example contains two possible setups for each
individual transaction in the chain; it can pay out only to one party
(like TX3 which pays bob 0.6btc), or it can pay "CoinJoin-style"
equal-sized outputs to 2 (or N) parties. Choosing this latter option
means you are consciously deciding to blur the line between the
&lt;em&gt;intrinsic-fungibility&lt;/em&gt; model and the &lt;em&gt;deniability&lt;/em&gt; &lt;em&gt;model,&lt;/em&gt; which, by
the way, is not necessarily a bad idea.&lt;/p&gt;
&lt;h2&gt;The return of A - amounts leak.&lt;/h2&gt;
&lt;p&gt;As mentioned, our adversary A has a very important problem - he may not
know that the above negotiation has happened, unlike a simple CoinJoin
where the transactions are watermarked as such (and this is particularly
true if Alice and Bob do &lt;em&gt;not&lt;/em&gt; use equal-sized outputs). The boundary
may be unclear to A.&lt;/p&gt;
&lt;p&gt;So, what strategy &lt;em&gt;can&lt;/em&gt; A use to find the transaction graph/set? He can
do &lt;a href="https://en.wikipedia.org/wiki/Subset_sum_problem"&gt;subset
sum&lt;/a&gt;
analysis.&lt;/p&gt;
&lt;p&gt;If Alice and Bob are just 'mixing' coins, so that they are paid out
the same amount that they paid in, I'll assert that subset sum is
likely to work. It's true that A's job is quite hard, since in
general, he would have to do such subset-sum analysis on a huge array of
different possible sets of (inputs, outputs) on chain; but nevertheless
it's the kind of thing that can be done by a professional adversary,
over time. The fact that subset sum analysis is theoretically
exponential time and therefore not feasible for very large sets may not
be relevant in practice.&lt;/p&gt;
&lt;p&gt;In our example above it may not be hard to identify the two inputs from
Alice (1btc, 0.3btc) as corresponding to 3 outputs (0.8btc, 0.2btc,
0.3btc), albeit that the latter two - 0.2, 0.3 were part of CoinJoins.
Remember that this was a tradeoff - if we &lt;em&gt;didn't&lt;/em&gt; make equal sized
outputs, to improve deniability/hiding, we'd no longer have any
ambiguity there.&lt;/p&gt;
&lt;h2&gt;Breaking subset-sum with Lightning&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="../../../../../../20200603010653im_/https:/joinmarket.me/static/media/uploads/.thumbnails/amtdecorr2.png/amtdecorr2-711x392.png"&gt;{width="711"
height="392"}&lt;/p&gt;
&lt;p&gt;Here's one way of addressing the fact that A can do subset-sum on such
a privacy-enhancing CoinJoinXT instantiation. The PTG is unspecified but
you can imagine it as something similar to the previous example.&lt;/p&gt;
&lt;p&gt;Marked in blue is what the adversary A doesn't know, even if he has
identified the specific transaction/graph set (as we've said, that in
itself is already hard). Subset-sum analysis won't work here to
identify which output belongs to Alice and which to Bob; since 5.5 + 1.5
!= 6.6, nor does 5.4 fit, nor does such an equation fit with Alice's
input 5.8 on the right hand side of the equation.&lt;/p&gt;
&lt;p&gt;The trick is that the 1.5 output is actually a &lt;strong&gt;dual funded Lightning
channel&lt;/strong&gt; between Alice and Bob. The actual channel balance is shown in
blue again because hidden from A: (0.3, 1.2). If the channel is then
immediately closed we have fallen back to a case where subset sum works,
as the reader can easily verify.&lt;/p&gt;
&lt;p&gt;But if, as is usually the intent, the channel gets used, the balance
will shift over time, due to payments over HTLC hops to other
participants in the Lightning network. This will mean that the final
closing balance of the channel will be something else; for example,
(0.1, 1.4), and then subset-sum will still not reveal which of the 2
outputs (5.4, 5.5) belong to Alice or Bob.&lt;/p&gt;
&lt;p&gt;At a high level, you can understand this as a &lt;strong&gt;bleed-through and
amplification of off-chain privacy to on-chain.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;It's worth noting that you clearly get a significant part of this
effect from just the dual-funded Lightning channel; if you consider
change outputs in such a single funding transaction, you see the same
effect:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;Alice&lt;/span&gt;
&lt;span class="err"&gt;2.46&lt;/span&gt;
&lt;span class="err"&gt;       -&amp;gt; Lightning funding 0.1&lt;/span&gt;
&lt;span class="err"&gt;       -&amp;gt; Change 2.41&lt;/span&gt;
&lt;span class="err"&gt;       -&amp;gt; Change 2.37&lt;/span&gt;
&lt;span class="err"&gt;2.42&lt;/span&gt;
&lt;span class="err"&gt;Bob&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It's easy to see that there is no delinking effect on the change-outs
&lt;em&gt;if&lt;/em&gt; we know that the funding is equal on both sides. However, there's
no need for that to be the case; if the initial channel balance is
(Alice: 0.09, Bob: 0.01) then the change-outs are going to the opposite
parties compared to if the channel funding is (Alice: 0.05, Bob: 0.05).
So this concrete example should help you to understand a crucial aspect
of this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Such a fungibility effect is only achieved if the difference between
    the two parties' initial inputs is small enough compared to the
    size of the dual-funded Lightning channel&lt;/li&gt;
&lt;li&gt;If the size of the inputs is very large compared to the Lightning
    channel overall size, which currently at maximum is 2**24 satoshis
    (about 0.16btc), then, in order to achieve this obfuscation effect,
    we "converge" to the case of something like a 2-in and 2-out
    equal-sized coinjoin. It's hard for 2 parties to arrange to have
    inputs of equal sizes, and it somewhat loses the deniability feature
    we were going for. (You can easily confirm for yourself that there
    will be no ambiguity if Alice and Bob's inputs are of completely
    different sizes).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So how does the picture change if instead of just doing a single
dual-funded Lightning channel, we include it as an output in a
CoinJoinXT structure?&lt;/p&gt;
&lt;p&gt;The answer again is deniability. Any contiguous subset of the entire
blockchain has the property of sum preservation, modulo fees: the input
total is \~= the output total. So no particular contiguous subset on the
blockchain flags itself as being such a CoinJoinXT structure - unless
subset sum works for some N subsets (2, as in our examples, or higher).
But with the dual funded Lightning output of the type shown here, at
least for the 2 of 2 case, this doesn't work.&lt;/p&gt;
&lt;h2&gt;Remove all traces?&lt;/h2&gt;
&lt;p&gt;What's been described up to now doesn't quite achieve the desired goal
of "deniability"; there are still what we might call "fingerprints"
in such a CoinJoinXT structure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Timing correlation: if we don't use nLockTime on these
    transactions, then one party might choose to broadcast them all at
    once. This is at the least a big clue, although not unambiguous. To
    avoid it, have the pre-signed transactions in the PTG all be given
    specific timelocks.&lt;/li&gt;
&lt;li&gt;Shared control utxos. If we use 2 of 2, or N of N, multisig outputs,
    of the current normal p2sh type, then they are observable as such,
    and this could easily help A to find the "skeleton" of such a
    CoinJoinXT structure. Of course, let's not forget that we can do
    CoinJoinXT with various equal sized outputs too, mixing the
    "intrinsic fungibility" and "deniability" approaches together,
    as discussed, so it's not that CoinJoinXT with p2sh multisig
    connecting utxos is useless. But we may want to focus on less
    detectable forms, like Schnorr/MuSig based multisig with key
    aggregation so that N of N is indistinguishable from 1 of 1, or the
    new
    &lt;a href="https://eprint.iacr.org/2018/472"&gt;construction&lt;/a&gt;
    that allows an ECDSA pubkey to be effectively a 2 of 2 multisig.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Proof of Concept&lt;/strong&gt; - I put together a some very simple &lt;a href="https://github.com/AdamISZ/CoinJoinXT-POC"&gt;PoC
code&lt;/a&gt;;
it only covers something like the above first "Example" with 2
parties. Going through such an exercise in practice at least allows one
to see concretely that (a) the interaction between the parties is very
minimal (sub-second) which is great of course, but it gets a little
hairy when you think about how to set up a template of such a
transaction chain that 2 parties can agree on using whatever utxos they
have available as inputs. A substantial chunk of that PoC code was
devoted to that - there is a general &lt;code&gt;Template&lt;/code&gt; class for specifying a
graph of transactions, with parametrized input/output sizes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Practicality today&lt;/strong&gt; - Although it can be done today (see previous),
there are barriers to making this work well. Ideally we'd have Schnorr
key aggregation for multisig, and support for dual funded Lightning
channels for the amount decorrelation trick mentioned. Without either of
those, such a transaction graph on the blockchain will be &lt;em&gt;somewhat&lt;/em&gt;
identifiable, but I still think there can be a lot of use doing it as an
alternative to large sets of clearly identifiable CoinJoins.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cost tradeoffs&lt;/strong&gt; - left open here is the tradeoffs in terms of
blockchain space usage for each "unit of fungibility", i.e. how much
it costs to gain privacy/fungibility this way. I think it's almost
impossible to come up with definitive mathematical models of such
things, but my feeling is that, exactly to the extent any
"deniability" is achieved, it's cost-effective, and to the extent
it's not, it's not cost-effective.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Coordination model&lt;/strong&gt; - Currently we have "in play" at least two
models of coordination for CoinJoin - Joinmarket's market-based model,
and the Chaumian server model currently championed by
&lt;a href="https://github.com/nopara73/ZeroLink"&gt;ZeroLink&lt;/a&gt;.
&lt;strong&gt;CoinJoinXT as an idea is orthogonal to the coordination mechanism&lt;/strong&gt;.
The only "non-orthogonal" aspect, perhaps, is that I think the
CoinJoinXT approach may still be pretty useful with only 2 parties (or
3), more so that CoinJoin with only 2/3.&lt;/p&gt;
&lt;p&gt;Finally, where should this fit in one's fungibility "toolchest"?
Lightning is &lt;em&gt;hopefully&lt;/em&gt; going to emerge as a principal way that people
gain fungibility for their everyday payments. The area it can't help
with now, and probably not in the future due to its properties, is with
larger amounts of money. So you might naturally want to ensure that in,
say, sending funds to an exchange, making a large-ish payment, or
perhaps funding a channel, you don't reveal the size of your cold
storage wallet. I would see the technique described on this blog post as
fitting into that medium-large sized funds transfer situation. CoinJoin
of the pure "intrinsic fungibility" type, done in repeated rounds or
at least in very large anonymity sets, is the other alternative (and
perhaps the best) for large sizes.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="coinjoin"></category><category term="bitcoin"></category></entry><entry><title>SNICKER</title><link href="https://joinmarket.me/blog/blog/snicker/" rel="alternate"></link><published>2017-09-15T00:00:00+02:00</published><updated>2017-09-15T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2017-09-15:/blog/blog/snicker/</id><summary type="html">&lt;p&gt;a proposal for non-interactive coinjoins.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;SNICKER&lt;/h3&gt;
&lt;h2&gt;SNICKER - Simple Non-Interactive Coinjoin with Keys for Encryption Reused&lt;/h2&gt;
&lt;p&gt;I'm going to do this backwards - start with the end goal user
experience, and then work backwards to the technical design. This way,
those not wanting to get lost in technical details can still get the
gist.&lt;/p&gt;
&lt;h3&gt;&lt;img alt="Me misusing a meme as a symbol and not adding any text." height="330" src="../../../../../../20200510162733im_/https:/joinmarket.me/static/media/uploads/.thumbnails/evilplanbaby.jpg/evilplanbaby-400x330.jpg" width="400"&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Pictured above: me misusing a meme as a symbol and deliberately not
adding any text to it.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Scenario&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Alisa&lt;/strong&gt; lives in Moscow; she is a tech-savvy Bitcoin user, uses Linux
and the command line, and runs a fully verifying Bitcoin Core node. She
doesn't have indexing enabled, but she (sometimes, or long-running)
runs a tool called &lt;code&gt;snicker-scan&lt;/code&gt; on the blocks received by her node. It
scans recent Bitcoin blocks looking for transactions with a particular
pattern, and returns to her in a file a list of candidate transactions.
She pipes this list into another tool which uses her own Bitcoin wallet
and constructs proposals: new transactions involving her own utxos and
utxos from these newly found transactions, which she signs herself.
Then, for each one, she makes up a secret random number and sends (the
proposed transactions + the secrets), encrypted to a certain public key,
in each case, so no one but the owner can read it, to a Tor hidden
service which accepts such submissions. For now, her job is done and she
gets on with her day.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bob&lt;/strong&gt; lives in New York. He's a Bitcoin enthusiast who uses it a lot,
and likes to test out new features, but has never written code and
isn't tech-savvy like that. A few hours after Alisa went to bed he
opens one of his mobile wallets and a message pops up:
&lt;code&gt;New coinjoin proposals found. Check?&lt;/code&gt;. He heard about this, and heard
that you can improve your privacy with this option, and even sometimes
gain a few satoshis in the process. So he clicks &lt;code&gt;Yes&lt;/code&gt;. In the
background his mobile wallet downloads a file of some 5-10MB (more on
this later!). Bob did this once before and was curious about the file;
when he opened it he saw it was text with lots of unintelligible
encrypted stuff like this:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QklFMQOVXvpqgjaJFm00QhuJ1iWsnYYV4yJLjE0LaXa8N8c34Hzg5CeQduV.....&lt;/code&gt;\
&lt;code&gt;QklFMQI2JR50dOGEQdDdmeX0BwMH4c+yEW1v5/IyT900WBGdYRA/T5mqBMc.....&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Now his mobile does some processing on this file; it takes a little
while, some seconds perhaps, processing in the background. At the end it
pops up a new message:
&lt;code&gt;Coinjoin transaction found. Would you like to broadcast it?&lt;/code&gt; and
underneath it shows the transaction spending 0.2433 BTC out of his
wallet and returning 0.2434 BTC in one of the outputs. It shows that the
other inputs and outputs are not his, although one of them is also for
0.2434 BTC. Does he want to accept? Sure! Free money even if it's only
cents. Even with no free money, he knows that coinjoin makes his privacy
better. So he clicks &lt;code&gt;Yes&lt;/code&gt; and it's broadcast. Done.&lt;/p&gt;
&lt;h3&gt;The NIC in SNICKER&lt;/h3&gt;
&lt;p&gt;Non-interactivity is a hugely desirable property in protocols; this is
particularly the case where privacy is a priority. Firstly, it avoids
the need to synchronize (&lt;strong&gt;Alisa&lt;/strong&gt;, and her computer, had gone to sleep
when &lt;strong&gt;Bob&lt;/strong&gt; performed his step). Second, to avoid malicious
interruption of an interactive protocol, it can help to identify the
participants, but that is very damaging to the whole point of a protocol
whose goal is privacy. Non-interactivity cuts this particular Gordian
knot; one side can send the message anonymously and the other
participant simply uses the data, but this has the limitation of the
sender finding the receiver, which means some weak identification of the
latter. Even better is if the request can be sent encrypted to the
receiver, then it can be broadcast anywhere for the receiver to notice.
That latter model is the most powerful, and is used here, but it does
have practicality drawbacks as we'll discuss.&lt;/p&gt;
&lt;p&gt;So, note that in the above scenario &lt;strong&gt;Alisa&lt;/strong&gt; and &lt;strong&gt;Bob&lt;/strong&gt; do not meet,
do not synchronize, and need never meet or find out who each other are
in future either. Their "meeting" is entirely abstracted out to one
side publishing an encrypted message and the other side receiving &lt;em&gt;all&lt;/em&gt;
such encrypted messages and only reading the one(s) encrypted to his
pubkey. The &lt;em&gt;all&lt;/em&gt; part helps preserve Bob's privacy, if he finds a way
to broadcast the final transaction with a reasonable anonymity defence
(see e.g.
&lt;a href="https://github.com/gfanti/bips/blob/master/bip-dandelion.mediawiki"&gt;Dandelion&lt;/a&gt;;
I'm of the opinion that that battle - making Bitcoin transaction
broadcast anonymous - is something we &lt;em&gt;will&lt;/em&gt; win, there is a massive
asymmetry in favour of the privacy defender there).&lt;/p&gt;
&lt;h3&gt;Quick background - how to do a Coinjoin&lt;/h3&gt;
&lt;p&gt;Here's the obligatory
&lt;a href="https://bitcointalk.org/index.php?topic=279249.0"&gt;link&lt;/a&gt;
to the Coinjoin OP. You can skip this section if you know Coinjoin well.&lt;/p&gt;
&lt;p&gt;Otherwise, I'll give you a quick intro here, one that naturally leads
into the SNICKER concept:&lt;/p&gt;
&lt;p&gt;Each input to a transaction requires (for the transaction to be valid) a
signature by the owner of the private key (using singular deliberately,
restricting consideration to p2pkh or segwit equivalent here) over a
message which is \~ the transaction. Each of these signatures can be
constructed separately, by separate parties if indeed the private key
for each input are owned by separate parties. The "normal" coinjoining
process thus involves the following steps (for now, not specifying &lt;em&gt;who&lt;/em&gt;
carries out each step):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gather all of the inputs - the utxos that will be spent&lt;/li&gt;
&lt;li&gt;Gather all of the destination addresses to various parties, and the
    amounts to be paid&lt;/li&gt;
&lt;li&gt;Distribute a "template" of the transaction to all parties (i.e.
    the transaction without any signatures)&lt;/li&gt;
&lt;li&gt;In some order all of the parties sign the transaction; whomever has
    a transaction with all signatures complete, can broadcast it to the
    Bitcoin network&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are different protocols one can choose to get all these steps
done, ranging from simple to complex. A server can be the coordinating
party; blinding can be used to prevent the server knowing input-output
mapping.
&lt;a href="http://crypsys.mmci.uni-saarland.de/projects/CoinShuffle/"&gt;Coinshuffle&lt;/a&gt;
can be used, creating a kind of onion-routing approach to prevent
parties involved knowing the linkages (doesn't require a server to
coordinate, but requires more complex interactivity). One of the parties
in the join can be the "server", thus that party gains privacy that
the others don't (Joinmarket). Etc.&lt;/p&gt;
&lt;p&gt;The difficulties created by any interactivity are considerably
ameliorated in a client-server model (see e.g. the old blockchain.info
&lt;a href="https://en.bitcoin.it/wiki/Shared_coin"&gt;SharedCoin&lt;/a&gt;(link
outdated) model), the serious tradeoff is the server knowing too much,
and/or a coordination/waiting problem (which may be considered
tolerable; see both SharedCoin and
&lt;a href="https://github.com/darkwallet/darkwallet"&gt;DarkWallet&lt;/a&gt;;
with a sufficient liquidity pool the waiting may be acceptable).&lt;/p&gt;
&lt;p&gt;There are a lot of details to discuss here, but there is always &lt;em&gt;some&lt;/em&gt;
interactivity (you can only sign once you know the full transaction,
assuming no custom sighashing^1^), and a model with a server is
basically always going to be more problematic, especially at scale.&lt;/p&gt;
&lt;p&gt;So hence we try to construct a way of doing at least simple Coinjoins,
in at least some scenarios, without any server requirement or
coordination. Now I'll present the basic technical concept of how to do
this in SNICKER, in 2 versions.&lt;/p&gt;
&lt;h3&gt;First version - snicKER = Keys for Encryption Reused&lt;/h3&gt;
&lt;p&gt;To make the Coinjoin non-interactive, we need it to be the case that
Alisa can post a message for Bob, without explicitly requesting to
create a private message channel with him. This requires encrypting a
message that can then be broadcast (e.g. over a p2p network or on a
bulletin board).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(In case it isn't clear that either encryption or a private message
channel is required, consider that Alice must pass to Bob a secret which
identifies Bob's output address (explained below), critically, and also
her signature, which is on only her inputs; if these are seen in public,
the input-output linkages are obvious to anyone watching, defeating the
usual purpose of Coinjoin.)&lt;/em&gt;&lt;/p&gt;
&lt;h5&gt;Encryption&lt;/h5&gt;
&lt;p&gt;To achieve this we need a public key to encrypt a message to Bob. This
is the same kind of idea as is used in tools like PGP/gpg - only the
owner of the public key's private key can read the message.&lt;/p&gt;
&lt;p&gt;In this "First version" we will assume something naughty on Bob's
part: that he has &lt;strong&gt;reused an address&lt;/strong&gt;! Thus, a public key will exist
on the blockchain which we assume (not guaranteed but likely; nothing
dangerous if he doesn't) he still holds the private key for.&lt;/p&gt;
&lt;p&gt;Given this admittedly unfortunate assumption, we can use a simple and
established encryption protocol such as
&lt;a href="https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme"&gt;ECIES&lt;/a&gt;
to encrypt a message to the holder of that public key.&lt;/p&gt;
&lt;p&gt;Alisa, upon finding such a pubkey, call it &lt;code&gt;PB&lt;/code&gt;, and noting the
corresponding utxo &lt;code&gt;UB&lt;/code&gt;, will need to send, ECIES encrypted to &lt;code&gt;PB&lt;/code&gt;,
several items (mostly wrapped up in a transaction) to Bob to give him
enough material to construct a valid coinjoin without any interaction
with herself:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Her own utxos (just &lt;code&gt;UA&lt;/code&gt; for simplicity)&lt;/li&gt;
&lt;li&gt;Her proposed destination address(s)&lt;/li&gt;
&lt;li&gt;Her proposed amounts for output&lt;/li&gt;
&lt;li&gt;Her proposed bitcoin transaction fee&lt;/li&gt;
&lt;li&gt;The full proposed transaction template using &lt;code&gt;UA&lt;/code&gt; and &lt;code&gt;UB&lt;/code&gt; as inputs
    (the above 4 can be implied from this)&lt;/li&gt;
&lt;li&gt;Her own signature on the transaction using the key for &lt;code&gt;UA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Her proposed destination address &lt;strong&gt;for Bob&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Destination&lt;/h4&gt;
&lt;p&gt;The last point in the above list is of course at first glance not
possible, unless you made some ultra dubious assumptions about shared
ownership, i.e. if Alisa somehow tried to deduce other addresses that
Bob already owns (involving &lt;em&gt;more&lt;/em&gt; address reuse). I don't dismiss this
approach &lt;em&gt;completely&lt;/em&gt; but it certainly looks like a bit of an ugly mess
to build a system based on that. Instead, we can use a very well known
construct in ECC; in English something like "you can tweak a
counterparty's pubkey by adding a point that &lt;em&gt;you&lt;/em&gt; know the private key
for, but you still won't know the private key of the sum". Thus in
this case, Alice, given Bob's existing pubkey &lt;code&gt;PB&lt;/code&gt;, which is the one
she is using to encrypt the message, can construct a new pubkey:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;PB2 = PB + k*G&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;for some 32 byte random value &lt;code&gt;k&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Alice will include the value of &lt;code&gt;k&lt;/code&gt; in the encrypted message, so Bob can
verify that the newly proposed destination is under his control (again
we'll just assume a standard p2pkh address based on &lt;code&gt;PB2&lt;/code&gt;, or a segwit
equivalent).&lt;/p&gt;
&lt;p&gt;Assuming Bob somehow finds this message and successfully ECIES-decrypts
it using the private key of &lt;code&gt;PB&lt;/code&gt;, he now has everything he needs to (if
he chooses), sign and broadcast the coinjoin transaction.&lt;/p&gt;
&lt;h4&gt;A protocol for the most naive version, in broad strokes:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Alisa must have the ability to scan the blockchain to some extent;
    she must find scriptSigs or witnesses containing pubkeys which were
    later reused in new addresses/scriptPubKeys.&lt;/li&gt;
&lt;li&gt;Alisa will use some kind of filtering mechanism to decide which are
    interesting. The most obvious two examples are: amounts under
    control in Bob's utxos matching her desired range, and perhaps age
    of utxos (so likely level of activity of user) or some watermarking
    not yet considered.&lt;/li&gt;
&lt;li&gt;Having found a set of potential candidates, for each case &lt;code&gt;PB, UB&lt;/code&gt;:
    Construct a standard formatted message; here is a simple suggestion
    although in no way definitive:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;{=html}
&amp;lt;!-- --&amp;gt;&lt;/code&gt;
        8(?) magic bytes and 2 version bytes for the message type
        k-value 32 bytes
        Partially signed transaction in standard Bitcoin serialization
        (optionally padding to some fixed length)&lt;/p&gt;
&lt;p&gt;We defer discussing how in practice Bob will get access to the message
later; but note that if he has done this, he already knows the value of
&lt;code&gt;P_B&lt;/code&gt; and will thus know also &lt;code&gt;U_B&lt;/code&gt;. He ECIES-decrypts it, and
recognizes it's for him through correct magic bytes (other messages
encrypted to other pubkeys will come out random).&lt;/p&gt;
&lt;p&gt;Then, this format has sufficient information for Bob to evaluate easily.
First, he can verify that &lt;code&gt;U_B&lt;/code&gt; is in the inputs. Then he can verify
that for 1 of the 2 outputs (simple model) has a scriptPubKey
corresponding to &lt;code&gt;PB2 = PB + k*G&lt;/code&gt;. He can then verify the output amounts
fit his requirements. Finally he can verify the ECDSA signature provided
on &lt;code&gt;U_A&lt;/code&gt; (hence "partially signed transaction"). Given this he can, if
he chooses, sign on &lt;code&gt;UB&lt;/code&gt; using &lt;code&gt;PB&lt;/code&gt; and broadcast. He must of course
keep a permanent record of either &lt;code&gt;k&lt;/code&gt; itself or, more likely, the
private key &lt;code&gt;k + x&lt;/code&gt; (assuming &lt;code&gt;P = x * G&lt;/code&gt;).&lt;/p&gt;
&lt;h3&gt;A proof-of-concept&lt;/h3&gt;
&lt;p&gt;Before going further into details, and discussing the second (probably
superior but not as obviously workable) version of SNICKER, I want to
mention that I very quickly put together some proof of concept code in
&lt;a href="https://github.com/AdamISZ/SNICKER-POC"&gt;this github
repo&lt;/a&gt;;
it uses
&lt;a href="https://github.com/Joinmarket-Org/joinmarket-clientserver"&gt;Joinmarket-clientserver&lt;/a&gt;
as a dependency, implements ECIES in a compatible form to that used by
&lt;a href="https://electrum.org/"&gt;Electrum&lt;/a&gt;,
and allows testing on regtest or testnet, admittedly with a bunch of
manual steps, using the python script &lt;code&gt;snicker-tool.py&lt;/code&gt;. The workflow
for testing is in the README. To extend the testing to more wallets
requires some way to do ECIES as well as some way to construct the
destination addresses as per &lt;code&gt;PB2 = PB + kG&lt;/code&gt; above. I did note that,
usefully, the partially signed transactions can be signed directly in
Bitcoin Core using &lt;code&gt;signrawtransaction&lt;/code&gt; and then &lt;code&gt;sendrawtransaction&lt;/code&gt;
for broadcast, but note that somehow you'll have to recover the
destination address, as receiver, too. Note that there was no attempt at
all to construct a scanning tool for any reused-key transactions here,
and I don't intend to do that (at least, in that codebase).&lt;/p&gt;
&lt;h2&gt;Practical issues&lt;/h2&gt;
&lt;p&gt;In this section will be a set of small subsections describing various
issues that will have to be addressed to make this work.&lt;/p&gt;
&lt;h3&gt;Wallet integration&lt;/h3&gt;
&lt;p&gt;One reason this model is interesting is because it's much more
plausible to integrate into an existing wallet than something like
Joinmarket - which requires dealing with long term interactivity with
other participants, communicating on a custom messaging channel,
handling protocol negotiation failures etc. To do SNICKER as a receiver,
a wallet needs the following elements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ECIES - this is really simple if you have the underlying secp256k1
    and HMAC dependencies; see
    &lt;a href="https://github.com/spesmilo/electrum/blob/master/lib/bitcoin.py#L774-L817"&gt;here&lt;/a&gt;
    and
    &lt;a href="https://github.com/AdamISZ/SNICKER-POC/blob/master/ecies/ecies.py#L10-L50"&gt;here&lt;/a&gt;;
    note that the root construction in ECIES is ECDH.&lt;/li&gt;
&lt;li&gt;The ability to calculate &lt;strong&gt;and store&lt;/strong&gt; the newly derived keys of the
    form &lt;code&gt;P' = P + kG&lt;/code&gt; where &lt;code&gt;k&lt;/code&gt; is what is passed to you, and &lt;code&gt;P&lt;/code&gt; is
    the pubkey of your existing key controlling the output to be spent.
    I would presume that you would have to treat &lt;code&gt;k+x&lt;/code&gt;, where &lt;code&gt;P=xG&lt;/code&gt;, as
    a newly imported private key. Note that we &lt;em&gt;cannot&lt;/em&gt; use a
    deterministic scheme for this from &lt;code&gt;P&lt;/code&gt;, since that would be
    calculatable by an external observer; it must be based on a secret
    generated by "Alisa".This could be a bit annoying for a wallet,
    although of course it's easy in a naive sense.&lt;/li&gt;
&lt;li&gt;Ability to parse files containing encrypted coinjoin proposals in
    the format outlined above - this is trivial.&lt;/li&gt;
&lt;li&gt;Ability to finish the signing of a partially signed transaction.
    Most wallets have this out of the box (Core does for example); there
    might be a problem for a wallet if it tacitly assumes complete
    ownership of all inputs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If a wallet only wanted to implement the receiver side (what we called
"Bob" above), that's it.&lt;/p&gt;
&lt;h4&gt;Compatibility/consensus between different wallets&lt;/h4&gt;
&lt;p&gt;The only "consensus" part of the protocol is the format of the
encrypted coinjoin proposals (and the ECIES algorithm used to encrypt
them). We could deal with different transaction types being proposed
(i.e. different templates, e.g. 3 outputs or 4, segwit or not), although
obviously it'll be saner if there are a certain set of templates that
everyone knows is acceptable to others.&lt;/p&gt;
&lt;h3&gt;Notes on scanning for candidates&lt;/h3&gt;
&lt;p&gt;There is no real need for each individual "Alisa" to scan, although
she might wish to if she has a Bitcoin node with indexing enabled. This
is a job that can be done by any public block explorer and anyone can
retrieve the data, albeit there are privacy concerns just from you
choosing to download this data. The data could be replicated on Tor
hidden services for example for better privacy. So for now I'm assuming
that scanning, itself, is not an issue.&lt;/p&gt;
&lt;p&gt;A much bigger issue might be finding &lt;strong&gt;plausible&lt;/strong&gt; candidates. Even in
this version 1 model of looking only for reused keys, which are
hopefully not a huge subset of the total utxo set, there are tons of
potential candidates and, to start with, none of them at all are
plausible. How to filter them?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Filter on amount - if Alisa has X coins to join, she'll want to
    work with outputs \&amp;lt; X.&lt;/li&gt;
&lt;li&gt;Filter on age - this is more debatable, but very old utxos are less
    likely to be candidates for usage.&lt;/li&gt;
&lt;li&gt;An "active" filter - this is more likely to be how things work.
    Are certain transactions intrinsically watermarked in a way that
    indicates that the "Bob" in question is actually interested in
    this function? One way this can happen is if we know that the
    transaction is from a certain type of wallet, which already has this
    feature enabled.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Bootstrapping&lt;/h4&gt;
&lt;p&gt;If a set of users were using a particular wallet or service (preferably
a &lt;em&gt;large&lt;/em&gt; set), it might be possible to identify their transactions
"Acme wallet transactions". Funnily enough, Joinmarket, because it
uses a set and unusual coinjoin pattern, satisfies this property in a
very obvious way; but there might be other cases too. See the notes in
"second version", below, on how Joinmarket might work specifically in
that case.&lt;/p&gt;
&lt;p&gt;Better of course, is if we achieved that goal with a more user-friendly
wallet with a much bigger user-base; I'd ask wallet developers to
consider how this might be achieved.&lt;/p&gt;
&lt;p&gt;Another aspect of bootstrapping is the Joinmarket concept - i.e. make a
financial incentive to help bootstrap. If creators/proposers are
sufficiently motivated they may offer a small financial incentive to
"sweeten the pot", as was suggested in the scenario at the start of
this post. This will help a lot if you want the user-set to grow
reasonably large.&lt;/p&gt;
&lt;h3&gt;Scalability&lt;/h3&gt;
&lt;p&gt;This is of course filed under "problems you really want to have", but
it's nevertheless a very real problem, arguably the biggest one here.&lt;/p&gt;
&lt;p&gt;Imagine 10,000 utxo candidates that are plausible and 1000 active
proposers. Imagine they could all make proposals for a large-ish subset
of the total candidates, we could easily imagine 1,000,000 candidates at
a particular time. Each encrypted record takes 500-800 bytes of space,
let's say. Just the data transfer starts to get huge - hundreds of
megabytes? Perhaps this is not as bad as it looks, &lt;em&gt;if&lt;/em&gt; the data is
being received in small amounts over long periods.&lt;/p&gt;
&lt;p&gt;And let's say we can find a way to get the data out to everybody - they
still have to try to decrypt &lt;strong&gt;every&lt;/strong&gt; proposal with &lt;strong&gt;every&lt;/strong&gt; pubkey
they have that is a valid candidate (in version 1, that's reused keys,
let's say, or some subset of them). The computational requirement of
that is huge, even if some cleverness could reduce it (decrypt only one
AES block; use high performance C code e.g. based on libsecp256k1).
Again, perhaps if this is happening slowly, streamed over time, or in
chunks at regular integrals, it's not as bad. Still.&lt;/p&gt;
&lt;p&gt;It's true that these problems don't arise at small scale, but then the
real value of this would be if it scaled up to large anonymity sets.&lt;/p&gt;
&lt;p&gt;Even if this is addressed, there is another problem arising out of the
anonymous submission - any repository of proposals could be filled with
junk, to waste everyone's time. Apart from a
&lt;a href="https://en.wikipedia.org/wiki/Hashcash"&gt;hashcash&lt;/a&gt;-like
solution (not too implausible but may impose too much cost on the
proposer), I'm not sure how one could address that while keeping
submission anonymity.&lt;/p&gt;
&lt;p&gt;At least we have the nice concept that this kind of protocol can improve
privacy on Bitcoin's blockchain without blowing up bandwidth and
computation for the Bitcoin network itself - it's "off-band", unlike
things like &lt;a href="https://www.elementsproject.org/elements/confidential-transactions/investigation.html"&gt;Confidential
Transactions&lt;/a&gt;
(although, of course, the effect of that is much more powerful). I think
ideas that take semantics and computation off chain are particularly
interesting.&lt;/p&gt;
&lt;h3&gt;Conflicting proposals&lt;/h3&gt;
&lt;p&gt;This is not really a problem: if Alisa proposes a coinjoin to Bob1 and
Bob2, and Bob1 accepts, then when Bob2 checks, he will find one of the
inputs for his proposed coinjoin is already spent, so it's not valid.
Especially in cases where there is a financial incentive, it just
incentives Bobs to be more proactive, or just be out of luck.&lt;/p&gt;
&lt;h3&gt;Transaction structure and 2 party joins&lt;/h3&gt;
&lt;p&gt;We have thus far talked only about 2 party coinjoins, which &lt;em&gt;ceteris
paribus&lt;/em&gt; are an inferior privacy model compared to any larger number
(consider that in a 2 party coinjoin, the &lt;em&gt;other&lt;/em&gt; party necessarily
knows which output is yours). The SNICKER model is not easily extendable
to N parties, although it's not impossible. But DarkWallet used 2 of 2
joins, and it's still in my opinion valuable. Costs are kept lower, and
over time these joins heavily damage blockchain analysis. A larger
number of joins, and larger anonymity set could greatly outweigh the
negatives&lt;em&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Structure: the model used in the aforementioned
&lt;a href="https://github.com/AdamISZ/SNICKER-POC"&gt;POC&lt;/a&gt;,
although stupid simple, is still viable: 2 inputs, one from each party
(easily extendable to 1+N), 3 outputs, with the receiver getting back
exactly one output of \~ the same size as the one he started with. The
proposer then has 1 output of exactly that size (so 2 equal outputs) and
one change. Just as in Joinmarket, the concept is that fungibility is
gained specifically in the equal outputs (the "coinjoin outputs"); the
change output is of course trivially linked back to its originating
input(s).&lt;/p&gt;
&lt;p&gt;But there's no need for us to be limited to just one transaction
structure; we could imagine many, perhaps some templates that various
wallets could choose to support; and it'll always be up to the receiver
to decide if he likes the structure or not. Even the stupid X-&gt;X, Y-&gt;Y
"coinjoin" I mused about in my Milan presentation
&lt;a href="https://youtu.be/IKSSWUBqMCM?t=47m21s"&gt;here&lt;/a&gt;(warning:youtube)
might be fun to do (for some reason!). What a particularly good or
"best" structure is, I'll leave open for others to discuss.&lt;/p&gt;
&lt;h3&gt;Second version - snicKER = Keys Encrypted to R&lt;/h3&gt;
&lt;p&gt;We've been discussing all kinds of weird and whacky "Non-Interactive
Coinjoin" models on IRC for years; and perhaps there will still be
other variants. But arubi was mentioning to me yesterday that he was
looking for a way to achieve this goal &lt;em&gt;without&lt;/em&gt; the nasty requirement
of reused keys, and between us we figured out that it is a fairly
trivial extension, &lt;em&gt;if&lt;/em&gt; you can find a way to get confidence that a
particular existing utxo is co-owned with an input (or any input).
That's because if you have an input, you have not only a pubkey, but
also a &lt;strong&gt;signature&lt;/strong&gt; (both will either be stored in the scriptSig, or in
the case of segwit, in the witness section of the transaction). An
&lt;a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"&gt;ECDSA&lt;/a&gt;
signature is published on the blockchain as a pair: &lt;code&gt;(r, s)&lt;/code&gt;, where &lt;code&gt;r&lt;/code&gt;
is the x-coordinate of a point &lt;code&gt;R&lt;/code&gt; on the secp256k1 curve. Now, any
elliptic curve point can be treated as a pubkey, assuming someone knows
the private key for it; in the case of ECDSA, we call the private key
for &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, that is: &lt;code&gt;R = kG&lt;/code&gt;. &lt;code&gt;k&lt;/code&gt; is called the nonce (="number used
once"), and is usually today calculated using the algorithm
&lt;a href="https://tools.ietf.org/html/rfc6979"&gt;RFC6979&lt;/a&gt;,
which determines its value deterministically from the private key
you're signing with, and the message. But what matters here is, the
signer either already knows &lt;code&gt;k&lt;/code&gt;, or can calculate it trivially from the
signing key and the transaction. This provides us with exactly the same
scenario as in the first version; Bob knows the private key of &lt;code&gt;R&lt;/code&gt;, so
Alisa can send a proposal encrypted to that public key, and can derive a
new address for Bob's destination using the same formula:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;PB2 = R + k&amp;#39;G&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Here I used &lt;code&gt;k'&lt;/code&gt; to disambiguate from the signature nonce &lt;code&gt;k&lt;/code&gt;, but it's
exactly the same as before. As before, Bob, in order to spend the output
from the coinjoin, will need to store the new private key &lt;code&gt;k+k'&lt;/code&gt;. For a
wallet it's a bit more work because you'll have to keep a record of
past transaction &lt;code&gt;k&lt;/code&gt; values, or perhaps keep the transactions and
retrieve &lt;code&gt;k&lt;/code&gt; as and when. Apart from that, the whole protocol is
identical.&lt;/p&gt;
&lt;h4&gt;Finding candidates in the second version&lt;/h4&gt;
&lt;p&gt;In version 2, we no longer need Bob to do something dubious (reusing
addresses). But now the proposer (Alisa) has a different and arguably
harder problem than before; she has to find transactions where she has
some reasonable presumption that a specific output and a specific input
are co-owned. You could argue that this is good, because now Alisa is
proposing coinjoins where linkages &lt;em&gt;are&lt;/em&gt; known, so she's improving
privacy exactly where it's needed :) (only half true, but amusing). In
a typical Bitcoin transaction there are two outputs - one to
destination, one change; if you can unambiguously identify the change,
even with say 90% likelihood not 100%, you could make proposals on this
basis. This vastly expands the set of &lt;em&gt;possible&lt;/em&gt; candidates, if not
necessarily plausible ones (see above on bootstrapping).&lt;/p&gt;
&lt;p&gt;Additionally paradoxical is the fact that Joinmarket transactions &lt;em&gt;do&lt;/em&gt;
have that property! The change outputs are unambiguously linkable to
their corresponding inputs through subset-sum analysis, see e.g.
&lt;a href="https://github.com/AdamISZ/JMPrivacyAnalysis/blob/master/tumbler_privacy.md#jmsudoku-coinjoin-sudoku-for-jmtxs"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thus, Adlai Chandrasekhar's
&lt;a href="http://adlai.uncommon-lisp.org:5000/"&gt;cjhunt&lt;/a&gt;
tool (appears down as of writing),
&lt;a href="https://github.com/adlai/cjhunt"&gt;code&lt;/a&gt;,
identifies all very-likely-to-be Joinmarket transactions through
blockchain scanning, and its output could be used to generate candidates
(the proposed joins could be with those change outputs, using the `R`
values from one of the identified-as-co-owned inputs). See also
&lt;a href="https://citp.github.io/BlockSci/chain/blockchain.html"&gt;BlockSci&lt;/a&gt;.
Then if Joinmarket had both proposer- and receiver- side code
integrated, it would create a scenario where these type of coinjoins
would most likely be quite plausible to achieve.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;I think this idea might well be viable. It's simple enough that there
aren't likely crypto vulnerabilities. The short version of the pros and
cons:&lt;/p&gt;
&lt;h4&gt;Pros&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;No interactivity (the point), has many positive consequences, and
    high anonymity standard&lt;/li&gt;
&lt;li&gt;Relative ease of wallet integration (esp. compared to e.g.
    Joinmarket), consensus requirement between them is limited.&lt;/li&gt;
&lt;li&gt;Potentially huge anonymity set (different for version 1 vs version
    2, but both very large)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Cons&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;For now only 2 parties and probably stuck there; limited coinjoin
    model (although many transaction patterns possible).&lt;/li&gt;
&lt;li&gt;Finding plausible candidates is hard, needs a bootstrap&lt;/li&gt;
&lt;li&gt;Sybil attack on the encrypted messages; how to avoid the "junk
    mail" problem&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lastly, it should be fine with Schnorr (to investigate: aggregation in
this model), in version 1 and version 2 forms.&lt;/p&gt;
&lt;h3&gt;Footnotes&lt;/h3&gt;
&lt;p&gt;1. Sighashing - attempting a non-interactive coinjoin with some
interesting use of &lt;code&gt;SIGHASH_SINGLE&lt;/code&gt; and &lt;code&gt;SIGHASH_ANYONECANPAY&lt;/code&gt; seems at
least plausible (see
&lt;a href="https://en.bitcoin.it/wiki/OP_CHECKSIG#Procedure_for_Hashtype_SIGHASH_SINGLE"&gt;here&lt;/a&gt;),
although it's not exactly heartening that no one ever uses
&lt;code&gt;SIGHASH_SINGLE&lt;/code&gt; (and its rules are arcane and restrictive), not to even
speak of watermarking. Hopefully the idea expressed here is better.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="coinjoin"></category><category term="bitcoin"></category></entry></feed>