<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Joinmarket.me archive - waxwings Blog</title><link href="https://joinmarket.me/" rel="alternate"></link><link href="https://joinmarket.me/feeds/waxwings-blog.atom.xml" rel="self"></link><id>https://joinmarket.me/</id><updated>2020-11-05T00:00:00+01:00</updated><entry><title>From MAC to Wabisabi</title><link href="https://joinmarket.me/blog/blog/from-mac-to-wabisabi/" rel="alternate"></link><published>2020-11-05T00:00:00+01:00</published><updated>2020-11-05T00:00:00+01:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2020-11-05:/blog/blog/from-mac-to-wabisabi/</id><summary type="html">&lt;p&gt;new coinjoin coordination mechanism based on MACs&lt;/p&gt;</summary><content type="html">&lt;h2&gt;From MAC to Wabisabi&lt;/h2&gt;
&lt;!-- vim-markdown-toc GFM --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#preamble"&gt;Preamble - big-and-randomized&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#wabisabi-from-the-ground-up"&gt;Wabisabi, from the ground up.&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#do-not-cover"&gt;What the Wabisabi paper, and this article, do not cover&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#signatures-keyed-macs-and-credentials"&gt;Signatures, keyed MACs and credentials&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#creating-a-mac"&gt;Creating a MAC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#algebraic-macs"&gt;Algebraic MACs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#security-notions"&gt;Security notions needed for algebraic MACs used for anonymous credentials&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#mac-1"&gt;Algebraic MAC attempt 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#mac-2"&gt;Algebraic MAC attempt 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#mac-3"&gt;Algebraic MAC attempt 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#mac-4"&gt;Algebraic MAC attempt 4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#mac-ggm"&gt;MAC-GGM - a vector of messages; different security arguments&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#key-verified"&gt;Key-Verified Anonymous Credentials (KVAC)&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#how-does-issuance-work"&gt;How does issuance work?&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#without-blinding"&gt;Without any blinding:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#side-note"&gt;Side note: what are these mysterious "zero knowledge proofs"?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#with-blinding"&gt;With blinding of attributes:&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#CPZ19"&gt;Chase-Perrin-Zaverucha 2019&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#wabisabi"&gt;Wabisabi: credentials on amounts with splitting&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#range-proofs"&gt;Range proofs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#final-thoughts"&gt;Final thoughts on the security and functionality proposed in Wabisabi&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- vim-markdown-toc --&gt;

&lt;p&gt;&lt;em&gt;Thanks to nothingmuch for answering several questions about the mechanics of Wabisabi.&lt;/em&gt;
&lt;a name="preamble"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Preamble - big-and-randomized&lt;/h3&gt;
&lt;p&gt;First, assume we think it's valuable to have big coinjoins with random amounts for all the inputs and outputs, and probably for this one specific reason: we want to make payments &lt;em&gt;from&lt;/em&gt; coinjoins and, possibly, to make payments &lt;em&gt;within&lt;/em&gt; coinjoins (the latter is literally what is meant by payjoin, so that is part of this discussion, note however we'd be talking about payjoin batched together with other sub-transactions, so a lot of earlier analysis of payjoin doesn't apply).&lt;/p&gt;
&lt;p&gt;Second let's &lt;em&gt;partially&lt;/em&gt; address why this is, at least superficially, a bad idea, even a terrible one: previous discussion of the subset sum problem pointed out that &lt;em&gt;some of the time&lt;/em&gt; (being deliberately vague about how much of the time!) a coinjoin with non-equal amounts can be easily analyzed to find the sub-transactions which are really happening, removing any privacy boost. So that's not good.&lt;/p&gt;
&lt;p&gt;Then, let's mention, without writing an essay about it (though it's a fascinating topic), that there are surprising outcomes of scaling the number of inputs and outputs (or just "coins") in such a model. Due the combinatorial nature of the subset sum problem (or more generally the "knapsack problem"), even having numbers like 50-100 on the input and output side (remember: these may be batched payments! not like separately created coinjoins, extra to payment transactions) can lead to a ridiculous combinatorial blowup making calculation of subsets near impossible. To illustrate: he set of subsets of a set is called the "power-set" and its size is \(2^N\) where \(N\) is the number of elements of the set; but the number of &lt;em&gt;partitions&lt;/em&gt; of a set is found using Bell's number \(B_n\), which scales (or doesn't!) even faster than exponential (i.e. faster than \(a^N\) where a is constant, here \(a\) is a function of \(N\), although it's pretty complex. \(B_2 = 2, B_10 \simeq 115000\), while \(B_100\) has 116 &lt;em&gt;digits&lt;/em&gt;, in decimal. So it's easy to see than even at 50 inputs and 50 outputs, the enumeration process &lt;em&gt;by brute force&lt;/em&gt; is not possible.&lt;/p&gt;
&lt;p&gt;This point is expanded on in some detail in the &lt;a href="https://github.com/cashshuffle/spec/blob/master/CASHFUSION.md"&gt;cashfusion writeup&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However the point is definitely controversial, basically because brute force is not the only way to approach an attempt to deanonymize a coinjoin. A simple thing like a rounded value (0.25000000 BTC) substantially (sort of exponentially) reduces the search space.&lt;/p&gt;
&lt;p&gt;Those who completely dismiss this approach based on the idea "well sure, it's worst case impossible to analyze, but not average, typical case!" should notice a really key subtlety though: the claim is not &lt;em&gt;only&lt;/em&gt; that such constructions are computationally impractical to analyze - it's also that they have &lt;strong&gt;multiple, and in fact a huge number of mathematically valid solutions&lt;/strong&gt;, at least when we scale up to very large numbers of utxos. Moreover &lt;a href="https://www.comsys.rwth-aachen.de/fileadmin/papers/2017/2017-maurer-trustcom-coinjoin.pdf"&gt;this&lt;/a&gt; paper ("Knapsack") from 2017 tries to construct a framework for deliberately creating such obfuscation (with the same goal - unequal sized coinjoins, allowing payment).&lt;/p&gt;
&lt;p&gt;This deserves more argument and discussion, see e.g. &lt;a href="https://www.mail-archive.com/bitcoin-dev@lists.linuxfoundation.org/msg08575.html"&gt;this&lt;/a&gt; discussion on the bitcoin mailing list from February this year. But we are going to move on to other elements of this story.&lt;/p&gt;
&lt;p&gt;&lt;a name="wabisabi-from-the-ground-up"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Wabisabi, from the ground up.&lt;/h3&gt;
&lt;p&gt;The paper is &lt;a href="https://github.com/zkSNACKs/WabiSabi/releases/download/build-70d01424bbce06389d2f0536ba155776eb1d8344/WabiSabi.pdf"&gt;here&lt;/a&gt; for those who don't need context. I suspect that group is quite small though!&lt;/p&gt;
&lt;p&gt;With respect the previous section, the plan for Wabisabi is &lt;strong&gt;not to use unconstrained random input and output sizes&lt;/strong&gt;, as I understand it from the developers, but to use sophisticated ideas based partly on the "Knapsack" style approach mentioned above, but &lt;strong&gt;this is a topic for another blog post&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;But let's say we buy into the basic idea: a large coinjoin, we'll say for simplicity, 50 inputs and 50 outputs, where there may be a complex ruleset about the values of those inputs and outputs, which we aren't specifying here. Some users will just be mixing and some may be paying someone for a specific good or service, with the output. Probably rarer, but particularly cool, will be if Alice is paying Bob but Bob also participates in the coinjoin, i.e. he is also contributing input utxos to the coinjoin, but gets more out and Alice gets less, effecting a payjoin.&lt;/p&gt;
&lt;p&gt;Scenario #1 : Server as coordinator, meaning a server-defined schedule, and no privacy for users w.r.t. server&lt;/p&gt;
&lt;p&gt;If we don't care if the server knows everything, each user can just securely connect and pass (set of inputs, set of outputs); they can be random amounts as per the preamble, and the server will accept if the inputs are verifiable on the blockchain, and if the total payment balances. This would be tricky for the payjoin style payments as that means interaction between the users, but in principle that could work too.&lt;/p&gt;
&lt;p&gt;Note how this is hardly a new idea, even the earliest implementation SharedCoin did something similar to this (it's a long story! but let's say).&lt;/p&gt;
&lt;p&gt;However this SPOF scenario seems unacceptable to anybody. The server could be keeping a record of &lt;em&gt;every&lt;/em&gt; linkage, ever, of the coinjoins created in this system. Ultimately this level of centralization breaks, anyway, via external pressure or otherwise.&lt;/p&gt;
&lt;p&gt;Scenario #2: Taker as coordinator, meaning taker chooses time of event, and privacy only for takers, not for makers&lt;/p&gt;
&lt;p&gt;The description of what is done is exactly as above, except substitute Taker for server. The outcome is practically different: at least one user (who likely pays for it) gets a privacy guarantee. How is this different from Joinmarket today? First, it hasn't been considered seriously to use randomized amounts; second, 50 party joins have not been at all practical (until recently it was not very practical, due to low participation rate (unless you chose a narrow range of amount), however that has increased; but, the IRC message channel used is not really able to handle the traffic needed for 50 party joins, see &lt;a href="https://joinmarket.me/blog/blog/oct-2020-update/"&gt;this&lt;/a&gt; earlier blog post for some thoughts on that). But if you take away those issues, this scenario is &lt;em&gt;possible&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;But notice something - exactly what makes this new "random payments, large numbers of counterparties" paradigm attractive &lt;strong&gt;is the possibility of multiple payments going on at once&lt;/strong&gt; - and that's counter to Joinmarket's original concept of "there is a guy paying for the privilege of controlling everything". More on this later.&lt;/p&gt;
&lt;p&gt;Scenario #3: Current Wasabi, Chaumian coinjoin&lt;/p&gt;
&lt;p&gt;I have only passing familiarity with the technical underpinnings of Wasabi as is, but essentially it is based on blinded signatures of a coinjoin output (see &lt;a href="https://github.com/nopara73/ZeroLink/#a-simplified-protocol"&gt;Chaumian coinjoin&lt;/a&gt; for a pretty intuitive diagrammatic explanation). This fairly simple cryptographic primitive (the blinded signature) is in itself enough, because Wasabi currently is only blinding the specific set of outputs (utxos-to-be) which all have equal size and are indistinguishable. As long as the Wasabi coordinating server is prevented from knowing those linkages, due to the blinding, then the later full construction of the transaction will not expose ownership of the equal-sized outputs ("coinjoin outputs").
On the other hand, let's not have &lt;em&gt;too&lt;/em&gt; simple of a mental model of Wasabi - it's crucial in this that the users make separate network connections (effectively, have separate pseudonyms) for when they present their cleartext outputs, and when they earlier presented their inputs (and change)); otherwise the cryptography would be sidestepped and the server would know all the mappings.&lt;/p&gt;
&lt;p&gt;Can you get the same protection, i.e. keeping the linkages private from the server, in a big-and-randomized model, using current Wasabi blind signatures?&lt;/p&gt;
&lt;p&gt;It's easy to see the problem: when the user comes along with a new identity and says "here are my outputs: 0.29511342 BTC and 0.01112222 BTC' the server has no way of knowing that these amounts correspond to anything in the inputs. If the blind signature is being used as a token to say "I am entitled to add outputs to this coinjoin", fine, but in this scenario: a token of &lt;em&gt;what&lt;/em&gt;, exactly?&lt;/p&gt;
&lt;p&gt;The difference is clear: in equal-output coinjoin there is only one kind of thing you could be entitled to: a single output of the prescribed amount ("denomination"); typically it's things like 0.1BTC.&lt;/p&gt;
&lt;p&gt;Here, if we were to preserve the tokenization approach, we'd have to have a more sophisticated object ... something similar to a supermarket gift card : it gives you the right to have a certain amount of stuff, restricted perhaps in time and space, but quantified. It's something that's issued to you, which you can use under the given conditions, but which does not have your name attached. I realise the analogy is a bit of a stretch, but you can see that gift cards have divisibility, which is crucial here in our big-and-randomized model. They usually also have anonymity which is clearly necessary.&lt;/p&gt;
&lt;p&gt;What we need here is a homomorphic anonymous credential with attributes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;homomorphic - here it means we could linearly split and combine credentials. Take a credential for 10 and turn it into two credentials for 3 and 7, for example.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;anonymous - if the credential presented could be linked to the one issued earlier, the coordinating entity can see all the linkages in the coinjoin&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;credential - this term is used in cryptography for any of a number of schemes that give rights to holders. The rights are usually &lt;em&gt;with respect to&lt;/em&gt; some centralized entity, usually holding a private key that allows them to create such credentials (modulo a nuance about who is verifying them; we'll get in to that).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;attributes - a credential could in its simplest form be simply binary: you are allowed to do X if you have the credential, and not otherwise. But sometimes attaching metadata inside the credential (think of e.g. a signature from a server that proved you should have access, but also that you are a level 3 user not a level 1 user, by including the level in the message that was signed).
&lt;a name="do-not-cover"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;What the Wabisabi paper, and this article, do not cover&lt;/h4&gt;
&lt;p&gt;What follows is a detailed review of the crypto constructions leading to the possibility of building a coinjoin system, with such a credential system. A full protocol however must cover other things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The rules for transaction construction&lt;/li&gt;
&lt;li&gt;Valid choices of amounts for inputs and outputs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is not covered here, other than some general thoughts as outlined above.
&lt;a name="signatures-keyed-macs-and-credentials"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Signatures, keyed MACs and credentials&lt;/h3&gt;
&lt;p&gt;Digital signatures are probably very familiar to any reader of this blog, and there is a detailed discussion of some fundamentals in &lt;a href="https://joinmarket.me/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/"&gt;this&lt;/a&gt; post. MACs, or Message Authentication Codes can be thought of as the symmetric crypto equivalent. In symmetric crypto, there is only a secret key, no public key, and that means there is no such thing as "public verification". The owner or owners of such a secret key can create a (probably unique; this is a nuance of the theory) "tag" on a message, which only a holder of the same key can verify.&lt;/p&gt;
&lt;p&gt;On its face, such tagging might seem pointless without public verifiability, but the classic use case is for point to point communications over the public internet, in which both endpoints of the communication hold the secret key; by tagging messages in this way, integrity is assured, and the message is authenticated as coming from the intended source. Such secret keys can be pre-shared over a public communication channel using techniques like &lt;a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman"&gt;ECDH&lt;/a&gt;.
&lt;a name="creating-a-mac"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Creating a MAC&lt;/h4&gt;
&lt;p&gt;A simple and currently very common way of making a MAC is to use a cryptographic hash function as a PRF: just hash the key &lt;em&gt;and&lt;/em&gt; message together (&lt;a href="https://en.wikipedia.org/wiki/HMAC"&gt;HMAC&lt;/a&gt; is a bit more complicated than this, but that's the basic idea): H(message || key).&lt;/p&gt;
&lt;p&gt;At first sight it may seem weird that I'm talking about this construct - how is this related to credentials?&lt;/p&gt;
&lt;p&gt;The most natural way to create a credential of the type described above, is to use a signature, which simply signs the rights of the holder. That's effectively what Wasabi's original design ("Chaumian coinjoin") does, but with the crucial extra feature that the signature is &lt;em&gt;blind&lt;/em&gt;, so that the credential's redemption is not linked to its creation. Early ecash designs (indeed, from David Chaum as well as others) were heavily sophisticated variants of that basic idea. Just as original Wasabi uses fixed denominations, so did those ecash designs.&lt;/p&gt;
&lt;p&gt;This is where we get some interesting twists, which bring in MAC as an alternative to signatures, here.&lt;/p&gt;
&lt;p&gt;First, traditionally, MACs were preferable to signatures for performance reasons: they use hash functions, not expensive crypto math operations like RSA or - less expensive but still a lot more so than hashes - elliptic curve calculations. This is less a consideration today, but still relevant. Second, the more restrictive model of the MAC w.r.t. verification does create a different effect: such MACs are repudiable, whereas digital signatures are not repudiable (if you think about it, this is the same property as transferrability, which is of course a key property of signatures).&lt;/p&gt;
&lt;p&gt;This plain vanilla style of MAC though (hash based), trades off functionality in favour of performance - hashes like SHA256 are intrinsically black boxy and not "algebraic". They are functions which do not allow composition; as I've had occasion to remark many times before, there is no such formula as \(H(a+b) = H(a) + H(b)\) for these traditional hash functions.
&lt;a name="algebraic-macs"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Algebraic MACs&lt;/h4&gt;
&lt;p&gt;The &lt;em&gt;other&lt;/em&gt; approach to building a MAC might be to use discrete log or elliptic curve hardness assumptions, for example in the crudest case take \(\textrm{MAC}_{k}(m) = m^{k} \textrm{mod} p\) for the discrete log case. Comparing the two approaches, Dodis et al in &lt;a href="https://eprint.iacr.org/2012/059"&gt;Mesage Authentication, Revisited&lt;/a&gt; have this to say:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The former have the speed advantage, but cannot be reduced to simple number-theoretic hardness assumptions (such as the DDH assumption for NR-PRF), and are not friendly to efficient zero-knowledge proofs about authenticated messages and/or their tags, which are needed in some important applications, such as compact e-cash [12]. On the other hand, the latter are comparably inefficient due to their reliance on number theory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here NR-PRF refers to the &lt;a href="https://en.wikipedia.org/wiki/Naor%E2%80%93Reingold_pseudorandom_function"&gt;Naor-Reingold&lt;/a&gt;. construction for a pseudorandom function.&lt;/p&gt;
&lt;p&gt;The point about zero knowledge proofs is the trump card though: in building something like a &lt;em&gt;anonymous credential with attributes&lt;/em&gt;, you are perforce required to be able to make attestations, using such proofs, in zero knowledge.
&lt;a name="security-notions"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Security notions needed for algebraic MACs used for anonymous credentials&lt;/h4&gt;
&lt;p&gt;MACs generally want to have something called UF-CMA (unforgeability under chosen message attack) ; something we already discussed for signatures &lt;a href="https://joinmarket.me/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/"&gt;here&lt;/a&gt;. There are several nuances that are MAC-specific but we won't delve into too much detail (I recommend Section 6.1, 6.2 of &lt;a href="https://toc.cryptobook.us/"&gt;Boneh and Shoup&lt;/a&gt; for an excellent rigorous description); the bottom line is that MACs must not be forgeable by a non-key holders, just like signatures.&lt;/p&gt;
&lt;p&gt;For our use case (and some others), such a MAC will also need to have a kind of "hiding" property : &lt;em&gt;indistinguishability&lt;/em&gt; (under chosen message attack, or IND-CMA) - the tags output should not allow an attacker to guess anything about the message being tagged.&lt;/p&gt;
&lt;p&gt;So concretely how can we use simple discrete log to build a MAC? Let's use an elliptic curve group of the type we're familiar with, generator \(G\), order \(p\). We'll try the simplest versions first and see what we need to do to make it secure:
&lt;a name="mac-1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;Algebraic MAC attempt 1&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Keygen: choose a scalar \(k\) at random&lt;/li&gt;
&lt;li&gt;Tag: given a message \(m\), set the tag to \(T = mkG\).&lt;/li&gt;
&lt;li&gt;Verify: not a relevant definition for such a deterministic MAC; we didn't add randomness so it's the same calculation as "Tag".&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note how this "determinism" is the same for familiar existing MAC functions like &lt;a href="https://en.wikipedia.org/wiki/HMAC"&gt;HMAC&lt;/a&gt;. Since it's the same information needed (the secret key \(k\)) and the same calculation, the distinction is not interesting. Shortly we'll be looking at probabilistic MACs.&lt;/p&gt;
&lt;p&gt;Attempt 1 clearly fails, and here's one reason why: if the attacker gets to query the algorithm and ask for any MAC it likes it can choose to ask for the MAC of the message 1. That MAC is \(kG=K\). It can then take that curve point and create forgeries on any message m' it likes: \(m'K\). Secondly this kind of deterministic MAC clearly can't have the kind of hiding property we want, since it's like a commitment without any blinding factor: if you guess the value of \(m\) correctly, you can verify your guess.
Thirdly, extend the above case of message '1' and we can see that it's non-resistant to forgery more generally: whenever you know the message that was tagged, you can take the output tag given by the signer,  \(T = mkG\) and multiplicatively tweak the message to \(m_2 = a \times m\) by just outputting \(aT\) as the new tag. So this is very insecure.
&lt;a name="mac-2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;Algebraic MAC attempt 2&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Keygen: choose a scalar \(k\) at random&lt;/li&gt;
&lt;li&gt;Tag: choose a curve point \(U\) at random, and message \(m\), output \((U, T = mkU)\)&lt;/li&gt;
&lt;li&gt;Verify: Given \((U, T)\) and message \(m\), check if \(T == mkU\)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This addresses the second part of our complaint with Attempt 1, by making the MAC "probabilistic". Each new MAC is generated with a fresh random curve point (or equivalently a scalar \(u\)).&lt;/p&gt;
&lt;p&gt;Unfortunately, Attempt 2 fails just as Attempt 1 did, when it comes to preventing forgeries (bearing in mind the previous sentence), because we can still tweak created tags in the same way. Perhaps slightly less obvious is that we can not just tweak \(T\) but also \(U\). (But it's important to bear in mind that our security game is also concerned with whether an attacker can do something clever with re-used values of that U.)
&lt;a name="mac-3"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;Algebraic MAC attempt 3&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Keygen: choose a scalar \(k\) at random&lt;/li&gt;
&lt;li&gt;Tag: choose a curve point \(U\) at random, and message \(m\), output \((U, T = (m+k)U)\)&lt;/li&gt;
&lt;li&gt;Verify: Given \((U, T)\) and message \(m\), check if \(T == (m+k)U\)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This prevents the multiplicative tweaking which killed our first two attempts; even supposing the attacker has a given \(T\) on a given, known message \(m\), multiplying \(T\) by any constant \(a\), will create \(T^{*} = aT = (am + ak) U\) which is not a tag on any message he can state (it is a tag on \(am + (a-1)k\) but he doesn't know \(k\), so even if he knows, or guesses, \(m\), he is stuck).
However this construction still allows trivial forgery, (and fundamentally for the same reason: the additive homomorphism of the group). Here, because the key is "additively separate" from the message, you can just insert new messages using addition. If you happen to know \(m\) and you want a tag on \(m_2\) instead, just make \(T_2 = T + m_2 U - m U\) (see previous note : reusing \(U\) is in-scope for our attacker).&lt;/p&gt;
&lt;p&gt;So if we review these first 3 attempts, it's fairly clear what's going on; it's a paradigm we've seen before in the Schnorr protocol. If you only &lt;em&gt;add&lt;/em&gt; a random secret, you allow additive forgery, while if you only &lt;em&gt;multiply&lt;/em&gt; a random secret, you allow multiplicative forgery, but if we add both ...
&lt;a name="mac-4"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;Algebraic MAC attempt 4&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;Keygen: choose two scalars \(k_1, k_2\) at random&lt;/li&gt;
&lt;li&gt;Tag: choose a curve point \(U\) at random, and message \(m\), output \((U, T = (mk_1+k_2)U)\)&lt;/li&gt;
&lt;li&gt;Verify: Given \((U, T)\) and message \(m\), check if \(T == (mk_1+k_2)U\)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To expand on the Schnorr analogy, it's as if one of the keys were the randomizing nonce, and the other were the private key (the analogy is not exact, to be clear). Now neither the additive nor the multiplicative tweak gives the attacker a way to forge new tags on messages that the genuine key holder never created.&lt;/p&gt;
&lt;p&gt;The construction in attempt 4 is one of several elucidated by Dodis et al in their 2012 paper &lt;a href="https://eprint.iacr.org/2012/059"&gt;"Symmetric Key Authorization, revisited"&lt;/a&gt;. They identify exponentiation in a group of prime order as an example of a "weak PRF", and moreover, specifically a &lt;em&gt;key-homomorphic weak PRF&lt;/em&gt;, and build the above construction in abstract from such a function. Then they prove by quite sophisticated arguments (see 4.3 of the full paper), that this construction has "suf-CMA" (or "suf-CMVA" with a transformation) where the "s" refers to &lt;em&gt;selective&lt;/em&gt; security. This is a weaker notion of security; the idea is that we only defend against the attacker who has to choose the message he will forge on, before he gets to query the signer/tagger to see a bunch of other messages. Their proof strategy is basically to show that with clever use of linear transformations you can reduce the security argument to that of the underlying weak PRF; its randomness gives you both the unforgeability and the hiding (indistinguishability) properties that we want.
&lt;a name="mac-ggm"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;MAC-GGM - a vector of messages; different security arguments&lt;/h4&gt;
&lt;p&gt;In 2013 Zaverucha, Chase and Meiklejohn described, in &lt;a href="https://eprint.iacr.org/2013/516"&gt;this paper&lt;/a&gt; (which we will sometimes abbreviate to CMZ13), a small but meaningful finesse on the above construction from 2012, which they call "MAC-GGM" (they also describe MAC-DDH in the same paper, which we won't cover here):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Instead of a MAC on a single message, the MAC is designed to support multiple distinct messages, and this is specifically to allow the credentials we'll describe next, to support &lt;em&gt;attributes&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The paper gives an argument in the so-called "generic group model" (GGM) that this construction has the full UF-CMVA security property (the original argument for only &lt;em&gt;selective&lt;/em&gt; security is not really OK in any scenario where users can query verification on tags).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As is probably obvious, in this new construction, the tag is calculated by: \(T = (U, (k_1 m_1 + k_2 m_2 + \ldots + k_n m_n + k_0)U)\); it's easy to see that the "multiplicative and additive" arguments mentioned above still apply (note the presence of \(k_0\)) (although the security argument is very different, see Appendix A of the paper). This looks superficially similar to a vector Pedersen commitment of the form seen in constructions like Bulletproofs (only superficially: here also, the vector is blinded, but at the level of scalars; we don't use different base points).&lt;/p&gt;
&lt;p&gt;The main reason this is even interesting is how it naturally supports &lt;strong&gt;selective revelation&lt;/strong&gt; - zero knowledge proofs that certain of these messages have particular values or perhaps are in a range.
Other previous MAC constructions couldn't do this in any reasonable way (although there was a big literature of achieving similar properties using (blind) signatures).
&lt;a name="key-verified"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Key-Verified Anonymous Credentials (KVAC)&lt;/h3&gt;
&lt;p&gt;Now we have the theoretical basis, we can construct a credential system with two of the properties we want - anonymity, and attributes. And that's what the meat of the Chase et al. paper does. It describes a credential system, using MAC-GGM as a primitive. The functionality of this credential system can be boiled down to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Keygen: generate secret keys and public parameters for the protocol instance (called &lt;em&gt;iparams&lt;/em&gt;, short for issuer parameters). These parameters include public commitments to the secret keys.&lt;/li&gt;
&lt;li&gt;Blind Issuance: a user can request and the issuer can provide  credentials on a set of attributes (\(m_i\)) in the above, where some of the attributes are allowed to be hidden from the issuer.&lt;/li&gt;
&lt;li&gt;Show-Verification: a user can prove to the issuer (or, any other holder of the secret key material), in zero knowledge, that they possess a credential whose attributes satisfy a specific set of constraints.
&lt;a name="how-does-issuance-work"&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;How does issuance work?&lt;/h4&gt;
&lt;p&gt;Because we've laid the foundations, this is pretty easy to &lt;em&gt;describe&lt;/em&gt;, albeit the concrete steps of mathematically creating the credential, isn't.
&lt;a name="without-any-blinding"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;Without any blinding:&lt;/h5&gt;
&lt;p&gt;(From here the private key set of the issuer is denoted with \(x\) rather than \(k\).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Issuance&lt;/strong&gt; - We issue a credential consisting of a MAC-GGM style of MAC, combined with a proof of its validity. Form, on a set of messages \(m_i\): \((U, (x_1 m_1 + x_2 m_2 + \ldots + x_n m_n + x_0)U, \pi)\) - the proof \(\pi\) exists because the credential must be accompanied by a proof that it is correctly formed with respect to the issuer parameters that were decided at the start of the protocol, but without revealing the issuer's secret key material.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Show/Verify&lt;/strong&gt; - this is where it gets interesting. The user does not just "present his MAC" as that would violate our intention to make the credentials anonymous. Instead, he presents &lt;em&gt;commitments to his MAC&lt;/em&gt; along with a zero knowledge proof of correct formation. He presents \((U, {C_{m_i}}^{n}&lt;em u_="u^{'"&gt;{i=1}, C&lt;/em&gt;}, \Pi)\). Taking those elements in order:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\(U\) - this is the base point of the MAC which was issued as credential, but it will have been rerandomised as \(U = aU_0\) for some \(a\). (There is a point of confusion in the paper here; in Appendix E the detailed treatment correctly notes that \(U, U'\) must be re-randomised by multiplication with a random scalar, in order to prevent trivial linkability between the Issue and Show/Verify steps, but this is not mentioned in Section 4.2).&lt;/li&gt;
&lt;li&gt;\({C_{m_i}}^{n}_{i=1}\) - these are Pedersen commitments to the individual attribute messages (note - the plaintext messages can be sent instead for those messages which are not hidden/encrypted, to save communication - we will talk about hidden attributes next). The blinding value for each commitment is \(z_i\).&lt;/li&gt;
&lt;li&gt;\(C_{U'}\) is a single Pedersen commitment to the second element of the tag. The blinding value is \(r\).&lt;/li&gt;
&lt;li&gt;\(\Pi\) - as mentioned, we need a zero knowledge proof of correct formation - this consists of a proof that the commitments \(C_{m_i}\) and \(C_{U'}\), when combined with the secret keys that only the verifier holds, will give the same outpoint group element \(V\) from the calculation \(x_0U + \sum_{i} x_i C_{m_i} - C_{U'} = V\) as the prover obtained from the calculation with public issuer parameters \(X_i\), i.e. \(V = \sum_{i} z_i X_i - rG\).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That last point is very tricky so I'm going to expand on it. What makes this credential construction special is its requirement to hide something from both sides - the user wants to hide the attributes \(m_i\) (in general if not always) from the issuer, and the issuer of course wants to hide the secret keys from the user.&lt;/p&gt;
&lt;p&gt;This is dealt with algebraically by using something similar to ECDH keys, where \(S = pqG = pQ = qP\), i.e. both sides have their own secret they keep from each other, but still create a shared secret. The variable \(V\) represents this, but to keep the following simple we'll imagine \(n=1\), i.e. that there's only one message/attribute.&lt;/p&gt;
&lt;p&gt;On the user side, we are summing elements of the form \(z_i X_i = z_i x_i H\), but the blinding terms in the message commitments \(C_{m_i}\) are also \(z_i H\), so that they can be converted into part of a term \(x_i C_{m_i}\) that the issuer can verify using the secret keys. The remaining term in the commitments \(C_{m_i}\) is \(m_i U\) which is converted into part of \(U'\) by the same multiplication by the secret key: \(x_i C_{m_i} = x_i m_i U = U' - x_0 U\). This equality is worked through in detail in the paper, but notice that basically, the group homomorphism can be used to allow the issuer to verify, using his own secret values, what the user constructed as message commitments, with his secret values.
&lt;a name="side-note"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;Side note: what are these mysterious "zero knowledge proofs"?&lt;/h5&gt;
&lt;p&gt;The proof systems used for these kind of statements are all variants of the basic Schnorr protocol + Fiat-Shamir transform that I explained in great detail &lt;a href="https://github.com/AdamISZ/from0k2bp/blob/master/from0k2bp.pdf"&gt;here&lt;/a&gt; (Section 3), though I also strongly recommend &lt;a href="https://toc.cryptobook.us/"&gt;Boneh and Shoup&lt;/a&gt; Chapter 19 for more rigorous treatments. Note that very often we are using the "AND of sigma protocols" paradigm, in which multiple statements are proved concurrently, and this is achieved by committing to all the statements in the first step, including all those commitments in the hash challenge preimage before constructing the response. As well as the aforementioned links, you can see a good simple example of this paradigm in Appendix E of CMZ13, albeit there are two serious errors in the description of the verification algorithm, as I explained on stackexchange &lt;a href="https://crypto.stackexchange.com/a/85952/14985"&gt;here&lt;/a&gt;.
&lt;a name="with-blinding"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;With blinding of attributes:&lt;/h5&gt;
&lt;p&gt;These attributes can be encrypted using &lt;a href="https://en.wikipedia.org/wiki/ElGamal_encryption"&gt;El Gamal encryption&lt;/a&gt; in such a way that a credential can still be issued without revealing (some of) them. The mechanics of El Gamal are about as simple as an encryption scheme gets:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Key: a normal public/private key pair from the group, say \(P = pG\)&lt;/li&gt;
&lt;li&gt;Encrypt: take as message point \(M\), create new randomness r, output \((rG, rP + M)\) (remember, asymmetric encryption, so not necessarily private key holder)&lt;/li&gt;
&lt;li&gt;Decrypt: take ciphertext \(c_1, c_2\) as per above and note \(p(rG) = r(pG) = P\) (the Diffie Hellman shared secret primitive), so that \(c_2 - pc_1 = M\)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that this system encrypts and decrypts &lt;em&gt;group elements&lt;/em&gt; \(M\) rather than scalars, \(m\). In cases where it's the latter that needs to be encrypted, sometimes this hiccup can be circumvented with a ZKP of the underlying message scalar. However the next paper, CPZ19, addresses this point (see next section) along with a lot of other things.&lt;/p&gt;
&lt;p&gt;Now, how could this El Gamal scheme be used to aid getting credentials on hidden attributes?&lt;/p&gt;
&lt;p&gt;(EC) El Gamal encryption has an additive homomorphism (this was noted in one of my earlier blog posts &lt;a href="https://web.archive.org/web/20200428225915/https://joinmarket.me/blog/blog/finessing-commitments/"&gt;here&lt;/a&gt;. (additive here means for elliptic curve point &lt;em&gt;addition&lt;/em&gt;): \(E(A) + E(B) = E(A+B)\) (the notation is very poor here: encryptions have attached randomness, but anyway). Whenever you have this additive homomorphism, you also have the scalar multiply, trivially: \(aE(A) = E(aA)\). We can leverage this to pass the encryption "through" the MAC procedure.&lt;/p&gt;
&lt;p&gt;The user would give the El Gamal encryption of one or more attributes \(m_i\) to the issuer to be tagged. They would give \((P, (r_1 G, m_1 G + r_1 P))\) as the two elements of the ciphertext, where we stick with just one attribute index for simplicity. The issuer would pick \(U\) here as \(bG\) where \(b\) is a random scalar (we'll see why this is needed rather than NUMS in a moment), and create an &lt;em&gt;encrypted&lt;/em&gt; tag on the &lt;em&gt;encrypted&lt;/em&gt; attribute message: \(E(U') = E(x_0 U + m_1 x_1 U) = E(x_0 U) + x_1 E(m_1 U) = E(x_0 U) + x_1 b E(m_1 G)\) and \(E(m_1 G)\) is exactly what the user gave them. Thus they can easily create an encryption of \(U'\) on the message \(m_1\) *without ever seeing \(m_1\).
This encryption must then be blinded, but that's easy, by adding extra randomness in the form of an encryption of 0. Again a ZKP will need to be attached when the issuer returns this encryption to the user, but if it is valid, the user can know that when he decrypts \(E(U')\) to \(U'\), he will have a valid credential (tag) \((U, U')\) for his attribute/message.&lt;/p&gt;
&lt;p&gt;&lt;a name="CPZ19"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Chase-Perrin-Zaverucha 2019&lt;/h3&gt;
&lt;p&gt;The scope of this paper (CPZ19 for short), which is intended to provide a credential system for the Signal messenger system, is much larger, but part of it is creating a more powerful credential design (albeit an inheritor; the security proof for CPZ19 uses a reduction to CMZ13) than that found in CMZ13. These credentials support &lt;em&gt;both&lt;/em&gt; scalar attributes and group elements as attributes - the latter can be appealing for general purposes of creating efficient ZKPs (or a more elementary aspect of the same thing: easier El-Gamal encryption of the type described in the previous section - indeed having attributes encrypted in this way is a fundamental part of their design).&lt;/p&gt;
&lt;p&gt;The credential construction looks much more complicated as presented since it uses different &lt;a href="https://en.wikipedia.org/wiki/Nothing-up-my-sleeve_number"&gt;NUMS&lt;/a&gt; base points for multiple different components: the secret key elements (x_0, x_1) as before for the basic idea of the Dodis et al algebraic MAC, but there are then base points for each of a vector of secret keys, one per attribute (and more, see paper for full setup). Notably the construction of the MAC tag itself, looks quite different:&lt;/p&gt;
&lt;p&gt;\((t, U, (W + (x_0 +x_1 t)U + \sum_{i=1}^n y_i M_i )\)&lt;/p&gt;
&lt;p&gt;here \(t\) and \(U\) are generated by the issuer at random, while the \(y_i\) are the aforementioned vector of secret keys corresponding to each message/attribute.&lt;/p&gt;
&lt;p&gt;While the construction is significantly more complex, the basic principle of how crendentials are issued, and then show/verified, is essentially the same, and that encludes the idea of encrypting credentials using El Gamal. The same construct carries over as was described under "with blinding of attributes", but the authors have a slightly different approach in mind:&lt;/p&gt;
&lt;p&gt;Given an existing credential/MAC, you can quite elegantly prove that an ElGamal encryption of a specific attribute is in fact attested to by the MAC, using again a ZKP about a relationship between the MAC and the encryption. However the authors do caution:&lt;/p&gt;
&lt;p&gt;"We caveat that this is only a promising direction for a new (public-key) verifiable encryption scheme, since the above basic Elgamal scheme is not CCA secure, and we have not carefully analyzed its security."&lt;/p&gt;
&lt;p&gt;(here &lt;a href="https://en.wikipedia.org/wiki/Chosen-ciphertext_attack"&gt;CCA&lt;/a&gt; means "chosen ciphertext attack"; security under this condition is the main goal of provably secure encryption schemes).&lt;/p&gt;
&lt;p&gt;At the beginning of this section I mentioned that the security argument for this flavor of algebraic MAC is based on a reduction to the case of CMZ13 above, which was proven UF-CMVA secure in the generic group model. However this reduction only produces SUF-CMVA, which is to say 'selective security' - here, we only consider an attacker who specifies the message \(m^{*}\) in advance of their message tagging and verification queries. I'm not sure if this is sufficient.&lt;/p&gt;
&lt;p&gt;&lt;a name="wabisabi"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Wabisabi: credentials on amounts with splitting&lt;/h3&gt;
&lt;p&gt;Wabisabi uses basically exactly the CPZ19 construction for its credentials. The main "twist" is a simplification: only 'value' (value in BTC) attributes are needed, and they are of course integer values. These credentials will allow a coinjoin participant to follow the workflow mentioned at the start of this article:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As one pseudonym, register 1 or more inputs and request N credentials for the input, with the values of each &lt;em&gt;credential&lt;/em&gt; hidden, but accompanied with a zero knowledge proof that the sum of those values is as it should be (the input's value).&lt;/li&gt;
&lt;li&gt;As another pseudonym, present the credentials and the intended coinjoin outputs, with a proof that the sum of the redeemed credentials tallies up to the total of the outputs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Serial numbers are also used as part of the credential, to prevent double spend of the same credential (remember, the credentials are specifically designed to be &lt;em&gt;unlinkable&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;However the paper is careful to build up to what it calls a "unified registration protocol" where it generalises the whole process of both creating and redeeming these credentials, and makes the interaction more efficient.&lt;/p&gt;
&lt;p&gt;&lt;a name="range-proofs"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Range proofs&lt;/h4&gt;
&lt;p&gt;Any former student of the ideas behind &lt;a href="https://en.bitcoin.it/wiki/Confidential_transactions"&gt;Confidential Transactions&lt;/a&gt; will find this part obvious. Simply presenting &lt;em&gt;commitments&lt;/em&gt; to integer amounts (in satoshis, say) doesn't provide the intended security: since in modular arithmetic, a very large integer is mathematically equivalent to a small negative integer, it would be easy for users to cheat the amounts they get out by requesting commitments on (effectively) negative amounts. The way round this is again a ZKP, of a particular flavor known as a range proof: you prove that the integer \(a\) is between say 1 and \(2^{32}\) or whatever suits. This can be done e.g. with &lt;a href="https://eprint.iacr.org/2017/1066"&gt;Bulletproofs&lt;/a&gt; but also the range proof can be embedded as another statement in the overall ZKP provided by the user.&lt;/p&gt;
&lt;p&gt;A relevant question, though, and one worth pondering: are the range proofs actually necessary? As discussed in the next section, there isn't a risk of funds loss in the basic coinjoin construct, with or without this extra crypto magic of credentials. So a malicious user constructing credentials in invalid negative amounts is not going to be able to claim more money, but this does represent a DOS vector, one that is usually addressed just with the requirement of users to provide and sign off on a valid utxo.&lt;/p&gt;
&lt;p&gt;However there still may be further room for thought here; the range proof could be provided as part of a blame phase of a protocol, and avoided in the happy path of correct coinjoins being presented for signing. Apparently ZmnSCPxj has suggested this.&lt;/p&gt;
&lt;p&gt;&lt;a name="final-thoughts"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Final thoughts on the security and functionality proposed in Wabisabi&lt;/h3&gt;
&lt;p&gt;This article has just been a survey of some of the technical (cryptographic) underpinnings; the paper itself is specifically more about the theoretical construct, and not a fully fleshed out system spec as would be needed for a full software instantiation.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How secure is it?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As the paper notes in the final section 5, we should not forget the fundamental security inherent in Coinjoin, however it is coordinated: users only sign what does not rob them of money, and a single transaction does not suffer from anything related to blockchain mechanics (delays, reorgs etc). So what risks exist will be around DOS (inconvenience, lost time) and much more importantly, privacy loss:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How strong are the privacy guarantees?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;First, to state the obvious, there is a dependency on discrete log hardness, but that's just at basis, more exactly, there is a DDH hardness assumption (see 6.2 of CPZ19) underlying the security of this MAC construction. As mentioned in the previous bullet point, this is &lt;em&gt;effectively&lt;/em&gt; only relevant to the privacy of the users w.r.t. the issuer (here the coinjoin coordinator) of the credentials, although nominally a breakage of that security (assume in the worst case, ability forge MACs arbitrarily) would "allow the user to forge credentials for arbitrary bitcoin amounts", but that is a DOS vector only as it creates invalid coinjoins that won't be signed.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How much defence against the issuer is there, i.e. is trust in the coordinator required for privacy?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is actually a fairly tricky point. Restricting the coordinator's ability to tag (pun intended) or selectively censor is quite critical, and non trivial.&lt;/p&gt;
&lt;p&gt;The splitting into multiple credentials helps; it is less easy for the malicious coordinator to figure out how to jam individual participants if they are going through multiple rounds of credential issuance and redemption. From conversations with nothingmuch it appears that quite a lot of thought is being put into this aspect of the protocol; those interested may want to read &lt;a href="https://github.com/zkSNACKs/WabiSabi/blob/master/protocol.md"&gt;this&lt;/a&gt; protocol spec document for the latest. Also along the same lines, the paper notes:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A malicious coordinator may also tag users by providing them with different issuer parameters. When
registering inputs a proof of ownership must be provided. If signatures are used, by covering the issuer
parameters and a unique round identifier these proofs allow other participants to verify that everyone was
given the same parameters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basically what is going on here is that there is a kind of "public" aspect to input registration; users sign the issuer parameters for the round, and then these signatures, at a certain point in the negotiation, are broadcast to all participants (with encryption), so that a malicious coordinator can be prevented from tagging users by giving them all different round issuer parameters.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="cryptography"></category><category term="bitcoin"></category><category term="coinjoin"></category></entry><entry><title>Joinmarket update for Oct 2020</title><link href="https://joinmarket.me/blog/blog/oct-2020-update/" rel="alternate"></link><published>2020-10-25T00:00:00+02:00</published><updated>2020-10-25T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2020-10-25:/blog/blog/oct-2020-update/</id><summary type="html">&lt;p&gt;Joinmarket update Oct 2020&lt;/p&gt;</summary><content type="html">&lt;h2&gt;About this post&lt;/h2&gt;
&lt;p&gt;It seems like a good idea to start using this blog to spread a little bit more information
to users and other interested parties, about Joinmarket, in particular about how it might
change.&lt;/p&gt;
&lt;p&gt;First, please note this is a &lt;em&gt;personal&lt;/em&gt; blog, there is nothing "official" here (and the same
would go for anyone else's blog about Joinmarket! - this is an open source project).&lt;/p&gt;
&lt;p&gt;Second, please note that for years now I have been microblogging &lt;a href="https://x0f.org/web/accounts/1077"&gt;here&lt;/a&gt;; so,
if you're interested to keep in touch with what I'm doing (and often, reading, or just thinking) day by day,
you're welcome to follow that account. I personally like keeping track of people over RSS with &lt;a href="https://fraidyc.at"&gt;fraidyc.at&lt;/a&gt;,
but whatever suits you. Just know that Joinmarket related announcements are often made there first (I don't and will not use any corporate-owned social media sites).&lt;/p&gt;
&lt;h3&gt;Joinmarket status.&lt;/h3&gt;
&lt;p&gt;0.7.1 of Joinmarket was released 12 days ago, and introduced &lt;em&gt;receiving&lt;/em&gt; BIP78 payjoins, on the GUI and on command line.&lt;/p&gt;
&lt;p&gt;In the next few days 0.7.2 will be released. It is principally a bugfix release.&lt;/p&gt;
&lt;p&gt;(Although there will be one small
new feature - not-self broadcasting is finally reimplemented. You'll want to be careful about using it, especially
to start with (since it'll only work with counterparties that also have the latest release); there will of course
be advice about this in the release notes. Consider it an advanced feature, and consider using tor-only in your
Core node if the base level of privacy in broadcasting transactions isn't enough for you.)&lt;/p&gt;
&lt;p&gt;The bugs fixed are things that came out of interoperability tests on BIP78.&lt;/p&gt;
&lt;p&gt;Over the last few weeks I, Kristaps Kaupe and some people on other dev teams have been running a variety
of testnet, mainnet, regtest tests of Payjoin functionality between btcpayserver, Wasabi and Joinmarket.&lt;/p&gt;
&lt;p&gt;We found various edge cases, like hex instead of base64 being transferred (not in spec but people were doing
it anyway), incorrectly shuffled output ordering (my bad!), combinations of parameters in the HTTP request
that &lt;em&gt;I&lt;/em&gt; interpreted the BIP as saying was not allowed, but btcpayserver was sending anyway (but: not always! -
testing can be a real pain sometimes!) and a few more.&lt;/p&gt;
&lt;p&gt;Remember two things about Payjoin though:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It is a protocol designed to accept a failure to negotiate as a common event - &lt;em&gt;the payment goes through anyway, it's just not a coinjoin then&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The most common incompatibility between wallets will be different address types. Then nothing can be done, as it would be slightly silly to do a Payjoin like that - we fall back, as per (1).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So hopefully we will have some wallets that can send and receive Payjoins up and running by .. well, now actually! It is already possible and working, we are just smoothing out edge cases here.&lt;/p&gt;
&lt;p&gt;If you didn't get a chance, please watch this demo video of sending and receiving payjoins between Joinmarket wallets (note: the dialog is now improved, as I comment here):&lt;/p&gt;
&lt;p&gt;&lt;a href="https://video.autizmo.xyz/videos/watch/7081ae10-dce0-491e-9717-389ccc3aad0d"&gt;JM-JM Payjoin demo video&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It only has 31 views, many of which were me, so I guess not many people saw it :)&lt;/p&gt;
&lt;p&gt;About point (2) above, note that you'll probably need to be using a Joinmarket bech32 wallet (yes, we've had them for quite a while!) if you want to send or receive with Wasabi. So, more on that next:&lt;/p&gt;
&lt;h3&gt;Joinmarket future plans (tentative!)&lt;/h3&gt;
&lt;h4&gt;Bech32 in 0.8.0&lt;/h4&gt;
&lt;p&gt;We have &lt;a href="https://github.com/JoinMarket-Org/joinmarket-clientserver/pull/656"&gt;this&lt;/a&gt; PR open from jules23 and it represents a very impactful (but happily, not large technically) change that is proposed: to switch to a "bech32 orderbook", by which we mean making changes like this&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The default wallet changes to native segwit (bech32, bc1.. addresses)&lt;/li&gt;
&lt;li&gt;Joinmarket coinjoins (i.e. maker/taker coinjoins) are offered as &lt;code&gt;sw0reloffer&lt;/code&gt;, &lt;code&gt;sw0absoffer&lt;/code&gt; in the trading pit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both of these changes would not be "mandatory", just as when we switched to segwit in 2017, it was not mandatory, but would be default in the new version. The fees for coinjoins will be significantly reduced from the current "wrapped segwit" addresses, and we would gain better compatibility with Wasabi and a number of other modern wallets that default to bech32.&lt;/p&gt;
&lt;p&gt;The general problem with these updates (which we've only done once before) is that they cause a "liquidity split" temporarily, as not everyone migrates to the new address type at the same time. This is unfortunate, but I feel less concerned about it than last time, as the amount of maker liquidity is &lt;em&gt;much&lt;/em&gt; larger (more on that below, about IRC).
Another reason to be slightly unsure about this update is that taproot activation may be coming quite soon, but it seems unlikely that the real activation on the live network will take less than 1 year from now (does it)?, so probably we should do this anyway. That's my opinion.&lt;/p&gt;
&lt;p&gt;The general idea would be to make a new 0.8.0 version next after this, including this change. More testing is needed, but it's mostly ready. If you have opinions about the technical implementation of this, feel free to discuss on the above github PR thread. For more general discussion I'd suggest using #joinmarket on freenode.&lt;/p&gt;
&lt;h4&gt;New message channel implementations vs IRC&lt;/h4&gt;
&lt;p&gt;This part is far more speculative. We have had several discussions about message channels over the years. As early as 2016/17 I abstracted out the message channel "layer" so that IRC was just an implementation (see &lt;code&gt;jmclient/jmclient/message_channel.py&lt;/code&gt;) of a few key methods. Alternative implementations have always been possible, but nobody either found time, or found a practical way, to make an alternative implementation. This issue is becoming more pressing. As a simple example, only this week we had IRC ops come to us complaining (very politely, it wasn't a disaster) that about 450 bots had suddenly shown up in our joinmarket test pit. This is in some ways less interesting than the real scalability problem: Joinmarket uses broadcast for offers, but also a sort of "anti-broadcast" mechanism: when a new Taker shows up, they ask &lt;em&gt;every&lt;/em&gt; Maker for their current offers, and the Makers &lt;em&gt;all&lt;/em&gt; send them at the same time, to that one Taker. So this doesn't scale very well and IRC as a messaging layer doesn't like it; this is the main reason negotiation of a Joinmarket coinjoin takes ~ 1 minute instead of 1-5 seconds (we have to deliberately throttle/slow down messages).&lt;/p&gt;
&lt;p&gt;We rather badly need a more scalable messaging layer. I'd appeal for help on this, and I'd also appeal for public discussion of ideas on github (we've had such threads in the past, but nothing really happened).&lt;/p&gt;
&lt;p&gt;Let's not forget that related to all that is DOS. Depending on implementation, DOS attacks can be a real problem. Chris Belcher's fidelity bond wallets were implemented within Joinmarket's code already, earlier this year, see &lt;a href="https://github.com/JoinMarket-Org/joinmarket-clientserver/blob/c1f34f08c52452c229319e7421bfd930f8d70a7c/docs/fidelity-bonds.md"&gt;here&lt;/a&gt; for documentation explaining this, but implementing it as a requirement for Makers is another step, and it might be an important part of the puzzle of getting a scalable messaging layer right.&lt;/p&gt;
&lt;p&gt;Getting this right won't just help Joinmarket coinjoins, but also various other systems we might want to integrate over time (SNICKER? CoinjoinXT? CoinSwap? something else?).&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="joinmarket"></category></entry><entry><title>The 445BTC gridchain case</title><link href="https://joinmarket.me/blog/blog/the-445-btc-gridchain-case/" rel="alternate"></link><published>2020-06-15T00:00:00+02:00</published><updated>2020-06-15T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2020-06-15:/blog/blog/the-445-btc-gridchain-case/</id><summary type="html">&lt;p&gt;analysis of gridchain blockchain analysis and implications for Joinmarket usage.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;The 445 BTC gridchain case&lt;/h3&gt;
&lt;p&gt;For those time-constrained or non-technical, it may make sense to read
only the &lt;a href="index.html#summary"&gt;Summary&lt;/a&gt; section of this article. It goes
without saying that the details do matter, and reading the other
sections will give you a much better overall picture.&lt;/p&gt;
&lt;h2&gt;Contents&lt;/h2&gt;
&lt;p&gt;&lt;a href="index.html#background"&gt;Background - what is the "gridchain case"?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#change-peeling"&gt;Toxic change and peeling chains&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#change-joinmarket"&gt;Change outputs in a Joinmarket context&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#toxic-recall"&gt;The toxic recall attack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#size-factor"&gt;The size factor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#sudoku"&gt;Joinmarket sudoku&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#maker-taker"&gt;Reminder on the maker-taker tradeoff&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#address-reuse"&gt;Address reuse&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#summary"&gt;Summary; lessons learned; advice to users&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#already"&gt;Already implemented improvements&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#still-needed"&gt;Still needed improvements&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="index.html#recommendations"&gt;Recommendations for users&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="background"&gt;Background - what is the "gridchain case"?&lt;/h2&gt;
&lt;p&gt;This is a reflection on a case of reported theft as outlined
&lt;a href="https://old.reddit.com/r/Bitcoin/comments/69duq9/50_bounty_for_anybody_recovering_445_btc_stolen/"&gt;here&lt;/a&gt;
on reddit in early 2017 by user 'gridchain'.&lt;/p&gt;
&lt;p&gt;What I won't do here is discuss the practical details of the case;
things like, whether it was a hack or an inside job, nor anything like
network level metadata, all of which is extremely important in an actual
criminal investigation. But here I'm only focusing on the role played
by Joinmarket specifically and blockchain level activity of the coins,
generally.&lt;/p&gt;
&lt;p&gt;The reason for this blog post was
&lt;a href="https://research.oxt.me/the-cold-case-files/1"&gt;this&lt;/a&gt;
recent report by OXT Research - specifically by analyst
&lt;a href="https://bitcoinhackers.org/@ErgoBTC"&gt;ErgoBTC&lt;/a&gt;
(they require an email for signup to read the full report, otherwise you
only see the summary).&lt;/p&gt;
&lt;p&gt;A short note of thanks here to ErgoBTC and LaurentMT and others
involved, since this kind of detailed analysis is badly needed, I hope
will we see more, specifically in public, over time (we cannot hope for
such from the deeply unethical blockchain analysis companies).&lt;/p&gt;
&lt;p&gt;I'm [not]{style="text-decoration: underline;"} going to assume here
that you've read that report in full, but I am going to be referring to
its main set of conclusions, and analyzing them. Obviously if you want
to properly assess my statements, it's rather difficult - you'd need
full knowledge of Joinmarket's operation &lt;em&gt;and&lt;/em&gt; full details of the OXT
Research analysis - and even then, like me, you will still have some
significant uncertainties.&lt;/p&gt;
&lt;p&gt;So the case starts with the claimed theft in 2 parts: 45 BTC in &lt;a href="https://blockstream.info/tx/2f9bfc5f23b609f312faa60902022d6583136cc8e8a0aecf5213b41964963881"&gt;this
txn&lt;/a&gt;
(note I will use blockstream.info for my tx links because I find their
presentation easiest for single txs specifically; note that oxt.me 's
research tool is of course a vastly superior way to see a large network
of txs, which plays a crucial role in this analysis), and a
consolidation of 400BTC in &lt;a href="https://blockstream.info/tx/136d7c862267204c13fec539a89c7b9b44a92538567e1ebbce7fc9dd04c5a7f0"&gt;this other
txn&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;We'll assume that both of these utxos are under the control of a single
actor/thief, henceforth just &lt;em&gt;A&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Setting aside the (in some ways remarkable) timing - that &lt;em&gt;A&lt;/em&gt; did not
move the coins for about 2 years - let's outline roughly what happened,
and what the report tells us:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The 400BTC went into joinmarket as a maker, and did a bunch (11 to
    be precise) of transactions that effectively "peeled down" (more
    on this later) that 400 to perhaps 335 BTC (with the difference
    going into coinjoins).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;A&lt;/em&gt; then switched to a taker role for a while, focusing on higher
    denominations, ranging from \~ 6BTC to as high as \~58BTC. Many of
    these coinjoins had very low counterparty numbers (say 3-5 being
    typical).&lt;/li&gt;
&lt;li&gt;At some point some maker activity is seen again in this same
    "peeling chain"; the report terms this phase as "alternating",
    but it's hard to say for sure whether some particular script is
    running, whether&lt;em&gt;A&lt;/em&gt; is just randomly switching roles, or what.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Be aware that this simplified narrative suggests to the careless reader
that one can easily trace all the coins through all the coinjoins, which
of course is not true at all - each subsequent transaction moves some
portion into a "mixed state", but (a) we'll see later that just
"moved into mixed state" is not the end of the story for some of those
coins and (b) while this narrative is misleading for Joinmarket in
general, it is not &lt;em&gt;as&lt;/em&gt; misleading in this particular case.&lt;/p&gt;
&lt;p&gt;The distinction between the "second" and "third" phase as listed in
those bullet points is pretty much arbitrary, but what is not in doubt
as important is: that second phase marks a clear jump in coinjoin amount
average size (this could be read as impatience on &lt;em&gt;A&lt;/em&gt;'s part - but
that's just speculation), and this resulted in small anonymity sets in
some txs - 4 and 3 in two txs, in particular. Let's continue:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Within the second regime, the OXT analysis narrows in on those small
    anon set, large denomination txs - can they figure out which equal
    sized output belongs to &lt;em&gt;A&lt;/em&gt; here? The "toxic replay attack"
    (explained below) allows them to identify one coinjoin output
    unambiguously - but that goes into another coinjoin. But in a
    second case it allows them to reduce the anonymity set (of the equal
    sized coinjoin outputs) to 2, and they trace forwards both of those
    outputs.&lt;/li&gt;
&lt;li&gt;One of those 2 coinjoin outputs (&lt;a href="https://blockstream.info/tx/2dc4e88685269795aafe7459087ab613878ce7d857dd35760eefeb9caf21371b"&gt;this
    txn&lt;/a&gt;
    , output index 2) pays, after several hops, into a Poloniex deposit
    address in &lt;a href="https://blockstream.info/tx/ab1e604cd959cc94b89ab02b691fe7d727d30637284e5e82908fb28b8db378f4"&gt;this
    txn&lt;/a&gt;
    ). Although this is several hops, and although it does not deposit
    all of that \~58BTC into Poloniex (only about half of it),
    nevertheless this can be (and is) treated as a significant lead.&lt;/li&gt;
&lt;li&gt;So the next step was to trace back from that specific Poloniex
    deposit address, which it turned out had a bunch of activity on it.
    See
    &lt;a href="https://blockstream.info/address/16vBEuZD54NzqnnSStPYxFF2aktGhhuaf1"&gt;16vBEuZD54NzqnnSStPYxFF2aktGhhuaf1&lt;/a&gt;
    . Indeed several other deposits to that single address are connected
    to the same Joinmarket cluster, and specifically connected to those
    smaller-anon set taker-side coinjoins. In total around 270BTC is
    eventually linked from &lt;em&gt;A&lt;/em&gt;'s joinmarket coinjoins to that deposit
    address. Even though some of those connections are ambiguous, due to
    address reuse the evidence of co-ownership appears very strong.&lt;/li&gt;
&lt;li&gt;Some further evidence is provided (though I am still fuzzy on the
    details, largely just because of the time needed to go through it
    all) linking more of the coins to final destinations, including some
    from the 45BTC original chunk. The claim is that 380BTC is linked at
    final destinations to the original 445BTC set. In the remainder
    I'll focus on what is already seen with this 270BTC set and only
    peripherally mention the rest - there is already a lot to chew on!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="change-peeling"&gt;Toxic change and peeling chains&lt;/h2&gt;
&lt;p&gt;The general idea of a "peeling chain" on the Bitcoin blockchain isn't
too hard to understand. Given 100 BTC in a single utxo, if I have to
make a monthly payment of 1 BTC and never use my wallet otherwise, then
clearly the tx sequence is (using (input1, input2..):(output1,
output2..)) as a rudimentary format): ((100):(1,99), (99):(1, 98),
(98:(1, 97)...). Ignoring fees of course. What matters here is that I
just always have a single utxo and that on the blockchain &lt;em&gt;my&lt;/em&gt; utxos
&lt;em&gt;may&lt;/em&gt; be linked as (100-99-88-97...) based on a &lt;a href="https://en.bitcoin.it/wiki/Privacy#Change_address_detection"&gt;change
heuristic&lt;/a&gt;
such as "round amount for payment". To whatever extent change
heuristics work, then to that extent ownership can be traced through
simple payments (especially and mostly if transactions have exactly two
outputs, so that the very &lt;em&gt;idea&lt;/em&gt; of change, let alone a change
heuristic, applies straightforwardly).&lt;/p&gt;
&lt;p&gt;&lt;img alt="peeling chain simple
example" src="https://web.archive.org/web/20200713230834im_/https://joinmarket.me/static/media/uploads/.thumbnails/PeelingChain1.png/PeelingChain1-418x296.png"&gt;{width="418"
height="296"}&lt;/p&gt;
&lt;p&gt;In peeling chains, sometimes, the primary heuristic is the &lt;strong&gt;size&lt;/strong&gt; of
the output. If you start with 1000 btc and you peel 0.1 btc hundreds of
times, it's obvious from the "size pattern" what the change is (and
indeed it's this case that gives rise to the name &lt;em&gt;peel chain&lt;/em&gt; because
"peel" refers to taking off a &lt;em&gt;small&lt;/em&gt; part of something, usually its
surface). The above diagram is more similar (but not the same, exactly)
as the initial flow in the gridchain case, with one very large utxo
gradually getting peeled off.&lt;/p&gt;
&lt;p&gt;In some cases timing may factor in; sometimes hackers will do hundreds
of such peels off a main originating utxo in a short time.&lt;/p&gt;
&lt;p&gt;You can think of a peeling chain as the lowest effort ownership
obfuscation out there. Notice how literally any, even the simplest,
Bitcoin wallet, has to offer the feature required to carry this out -
just make a vanilla payment, for which there is (almost always, but not
always) a change output, back to your wallet.&lt;/p&gt;
&lt;p&gt;So in Bitcoin's history, this technique has very often been seen used -
by hackers/thieves moving coins "away" from the original site of the
theft (I remember the &lt;a href="http://www.techienews.co.uk/973470/silk-road-like-sheep-marketplace-scams-users-39k-bitcoins-worth-40-million-stolen/"&gt;case of Sheep
Market&lt;/a&gt;
for example). Each "peel" raises additional uncertainty; the
non-change output is going somewhere, but who owns that? But the change
outputs represent a link allowing someone, in theory, to keep tracing
the activity of the original actor. Notice here how we talk about one
branch (our ((100):(1,99), (99):(1, 98), (98:(1, 97)...) example
illustrates it); but one could keep tracing the payment outputs (the
'1's in that flow) and see if they themselves form other peel chains,
leading to a tree.&lt;/p&gt;
&lt;p&gt;We mentioned a 'change heuristic' element to this - which is the
"main branch" if we're not sure which output is the change?&lt;/p&gt;
&lt;h3 id="change-joinmarket"&gt;Change outputs in a Joinmarket context&lt;/h3&gt;
&lt;p&gt;A reader should from this point probably be familiar with the basics of
Joinmarket's design. Apart from the
&lt;a href="https://github.com/Joinmarket-Org/joinmarket-clientserver"&gt;README&lt;/a&gt;
and &lt;a href="hhttps://github.com/JoinMarket-Org/joinmarket-clientserver/blob/master/docs/USAGE.md"&gt;usage
guide&lt;/a&gt;
of the main Joinmarket code repo, the diagrams showing the main
Joinmarket transaction types
&lt;a href="https://github.com/AdamISZ/JMPrivacyAnalysis/blob/master/tumbler_privacy.md#joinmarket-transaction-types"&gt;here&lt;/a&gt;
may be useful as a refresher or a reference point for the following.&lt;/p&gt;
&lt;p&gt;We have: \(N\) equal outputs and \(N\) or \(N-1\) non-equal change
outputs, where \(N-1\) happens when the taker does a "sweep",
emptying the mixdepth (= account; joinmarket wallets have 5 accounts by
default) without a change output. [This last feature is specific to
Joinmarket, and specific to the taker role: there's no other coinjoin
out there that provides the facility to sweep an arbitrary amount of
coins out to an equal-sized output, with no
change.]{style="text-decoration: underline;"} (I am emphasizing this not
for marketing, but because it's crucial to this topic, and not widely
understood I think).&lt;/p&gt;
&lt;p&gt;As an example of why it's important, here is one line from the OXT
Research article:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Fees taken directly in a mix transaction result in deterministic
links ("unmixed change").&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This is false as an absolute statement; fees can be paid by a taker,
inside the transaction, with no unmixed change for the taker (this is
the Joinmarket 'sweep'). Deterministic links between inputs and change
outputs &lt;em&gt;do&lt;/em&gt; result from change, and fees &lt;em&gt;do&lt;/em&gt; create an additional flag
that can help make those linkages, in cases where there would be more
ambiguity. But a zero fee coinjoin with change outputs still has
deterministic links, usually.&lt;/p&gt;
&lt;p&gt;Why does the OXT Research article heavily focus on &lt;em&gt;toxic unmixed
change&lt;/em&gt; as a concept and as a key weakness of such protocols as
Joinmarket, and why do I disagree?&lt;/p&gt;
&lt;p&gt;As we discussed peeling chains offer a low quality of obfuscation, and
to unpack that: the problem is that if you have any relatively viable
change heuristic (it doesn't &lt;em&gt;have&lt;/em&gt; to be large amounts as discussed),
it can let you keep knowledge of ownership of a whole chain of
transactions. That basically gives the blockchain analyst (we'll call
&lt;em&gt;B&lt;/em&gt;) a very large attack surface. He can look at &lt;em&gt;all&lt;/em&gt; the information
flowing out of, or associated with, a whole chain of transactions. Any
later recombination of outputs from that "large attack surface" is
either a coinjoin or a "smoking gun" that different outward paths were
actually under the control of one owner (this comes back to that central
heuristic - common input ownership, and all the nuance around that).&lt;/p&gt;
&lt;p&gt;In Joinmarket or any other coinjoin protocol that does allow change
outputs, "change heuristic" doesn't really apply, it kind of morphs
into something else: it's very obvious which outputs are change, but it
is only &lt;em&gt;in some cases&lt;/em&gt; easy to disentangle which change outputs are
associated to which inputs, and that's actually what you need to know
if you want to trace via the change (as per "peeling chains"
description above). In high anonymity sets, it starts to get difficult
to do that disentangling, but more on that ("sudoku") later.&lt;/p&gt;
&lt;p&gt;The analysis done in the OXT Research report smartly combines a long
peeling chain with other specific weaknesses in the way &lt;em&gt;A&lt;/em&gt; acted, which
we will discuss in the next section.. So all this is very valid in my
view.&lt;/p&gt;
&lt;p&gt;[But I think going from the above to the conclusion "coinjoins which
have unmixed change are fundamentally inferior and not viable, compared
to coinjoins without unmixed change" is just flat out
wrong]{style="text-decoration: underline;"}. Consider yourself in the
position of &lt;em&gt;A&lt;/em&gt;. You have let's say 400BTC in a single utxo. If you run
a coinjoin protocol that insists on no change always, and without a
market mechanism, you are forced to use a fixed denomination, say 0.1
BTC (an example that seems common), now across thousands of
transactions. In order to create these fixed denomination utxos you are
faced with the same problem of trying to avoid a trivial peeling chain.
By insisting on no deterministic links within the coinjoin, you simply
move the problem to an earlier step, you do not remove it.&lt;/p&gt;
&lt;p&gt;Fixed denomination does not solve the problem of having an unusually
large amount to mix compared to your peers.&lt;/p&gt;
&lt;p&gt;Having said that, fixed denomination with no change at all, does create
other advantages - I certainly don't mean to disparage that model!
Without going into detail here, consider that a large set or network of
all-equal-in all-equal-out coinjoins can create similar effects to a
single, much larger, coinjoin (but this is a topic for another article).&lt;/p&gt;
&lt;h2 id="toxic-recall"&gt;The toxic recall attack&lt;/h2&gt;
&lt;p&gt;Earlier we explained that one of the steps of the OXT Research analysis
was to identify a low liquidity regime where &lt;em&gt;A&lt;/em&gt; was acting as taker,
and we mentioned the "toxic recall attack" was used to reduce the
anonymity sets of the coinjoin outputs, during this, to a level low
enough that simple enumeration could find good candidates for final
destinations of those coins.&lt;/p&gt;
&lt;p&gt;Embedded in this was a crucial piece of reasoning, and I think this was
a both excellent, and very important idea:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Joinmarket does not allow co-spending of utxos from different
    accounts&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;That means that if a coinjoin output&lt;em&gt;X&lt;/em&gt; is spent along with a utxo
    from the "peeling chain" (i.e. they are both inputs to the same
    tx), then &lt;em&gt;X&lt;/em&gt; is not owned by &lt;em&gt;A&lt;/em&gt; (assuming correct identification
    of &lt;em&gt;A&lt;/em&gt;'s peeling chain)&lt;/li&gt;
&lt;li&gt;Every time such an event occurs, that &lt;em&gt;X&lt;/em&gt; can be crossed off the
    list of coinjoin outputs that &lt;em&gt;A&lt;/em&gt; might own, thus reducing the
    anonymity set of that earlier coinjoin by 1.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The reasoning is not perfectly watertight:&lt;/p&gt;
&lt;p&gt;First, as the report observes: the first assumption behind it is "A
user can only run one mixing client at a time." This is clearly not
literally true, but like many things here, a good-enough guess is fine,
if it eventually leads to outcomes that further strengthen the case. And
that is definitely true here: while a smart operator probably would be
running more than one instance of Joinmarket code, it is not default
behaviour and requires both a little coding and some careful thought.
Most people would not do this.&lt;/p&gt;
&lt;p&gt;(Second, nothing stops a user from making a coinjoin to an address in
the same mixdepth (at least in the current software). It's just that
(a) that is heavily discouraged and (b) it's not easy to see a good
reason why someone would &lt;em&gt;try&lt;/em&gt; to do that. Still it is possible as a
mistake. But I don't think this is a reason to doubt the effectiveness
of the "toxic recall attack", just, it should be noted.)&lt;/p&gt;
&lt;p&gt;So overall the bolded sentence is the most interesting - Joinmarket's
intention is to prevent co-spending outputs which would ruin the effect
of any single coinjoin - i.e. it tries (caveat: above parenthetical) to
prevent you using both a coinjoin output and the change output (or any
other utxo in the same account as the change output and the original
inputs) together. And this small element of 'rigidity' in how coins
are selected for spending is actually another 'bit' of information
that &lt;em&gt;B&lt;/em&gt; can use to make deductions, at least some of the time.&lt;/p&gt;
&lt;p&gt;The following diagram tries to illustrate how these conditions lead to
the possibility of the attack, to reduce the anonymity set of coinjoin
outputs:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Toxic recall attack
illustration" src="https://web.archive.org/web/20200713230834im_/https://joinmarket.me/static/media/uploads/.thumbnails/ToxicRecall1.png/ToxicRecall1-692x490.png"&gt;{width="692"
height="490"}&lt;/p&gt;
&lt;p&gt;So in summary we see 4 really important factors leading to the attack's
viability:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Joinmarket's strict account separation&lt;/li&gt;
&lt;li&gt;Linkability via change - as we'll describe in the next section
    "Joinmarket sudoku", this is &lt;em&gt;usually&lt;/em&gt; but not always possible, so
    while (1) was 99% valid this is more like 75% valid (entirely vague
    figures of course).&lt;/li&gt;
&lt;li&gt;Reusing the same peers in different coinjoin transactions&lt;/li&gt;
&lt;li&gt;Low number of peers&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Of course, 3 and 4 are closely tied together; reuse of peers happened a
lot precisely because there were so few peers available for large
coinjoin sizes (to remind you, it was between 6 and 58 BTC, and the
average was around 27, and there are/were few Joinmarket peers actually
offering above say 10BTC).&lt;/p&gt;
&lt;h2 id="size-factor"&gt;The size factor&lt;/h2&gt;
&lt;p&gt;This is a thread that's run through the above, but let's be clear
about it: in practice, typical Joinmarket coinjoins run from 0.1 to 10
BTC, which is unsurprising. There are a fair number of much smaller
transactions, many just functioning as tests, while &lt;em&gt;really&lt;/em&gt; small
amounts are not very viable due to the fees paid by the taker to the
bitcoin network. Larger than 10 BTC are certainly seen, including up to
50 BTC and even beyond, but they appear to be quite rare.&lt;/p&gt;
&lt;p&gt;The actions of &lt;em&gt;A&lt;/em&gt; in this regard were clearly suboptimal. They started
by taking 4 x 100 BTC outputs and consolidating them into 1 output of
400 BTC. This was not helpful, if anything the opposite should have been
done.&lt;/p&gt;
&lt;p&gt;Second, as a consequence, they placed the entirety of this (I'm
ignoring the 45 BTC output for now as it's not that crucial) in one
mixdepth. For smaller amounts where a user is just casually offering
coins for joining, one output is fine, and will rapidly be split up
anyway, but here this very large size [led to most of the large-ish
joining events forming part of one long peeling
chain&lt;em&gt;.&lt;/em&gt;]{style="text-decoration: underline;"} This part probably isn't
clear so let me illustrate. A yield generator/maker usually splits up
its coins into random chunks pretty quickly, and while as a maker they
do &lt;strong&gt;not&lt;/strong&gt; get the crucial "sweep, no change" type of transaction
mentioned above, they nevertheless do get fragmentation:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Initial deposit --&amp;gt; After 1 tx --&amp;gt; After 2 txs --&amp;gt; After many txs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0: 1BTC --&amp;gt; 0.800 BTC --&amp;gt; 0.800 BTC  --&amp;gt; 0.236 BTC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1: 0 BTC --&amp;gt; 0.205 BTC --&amp;gt; 0.110 BTC  --&amp;gt; 0.001 BTC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2: 0 BTC --&amp;gt; 0.000 BTC --&amp;gt; 0.100 BTC  --&amp;gt; 0.555 BTC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;3: 0 BTC --&amp;gt; 0.000 BTC --&amp;gt; 0.000 BTC  --&amp;gt; 0.129 BTC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;4: 0 BTC --&amp;gt; 0.000 BTC --&amp;gt; 0.000 BTC  --&amp;gt; 0.107 BTC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;(Final total is a bit more than 1BTC due to fees; the reason it gets
jumbled, with no ordering, is: each tx moves coinjoin output to &lt;em&gt;next&lt;/em&gt;
mixdepth, mod 5 (ie it wraps), but when a new tx request comes in it
might be for any arbitrary size, so the mixdepth used as &lt;em&gt;source&lt;/em&gt; of
coins for that next transaction, could be any of them. This is
illustrated in the 'after 2 txs' case: the second mixdepth was chosen
as input to the second tx, not the first mixdepth).&lt;/p&gt;
&lt;p&gt;This dynamic does &lt;strong&gt;not&lt;/strong&gt; remove the "peeling chain" or "toxic
change" dynamic emphasized in OXT Research's report - because every tx
done by the maker still has its change, [precisely because as maker you
don't have the privilege of choosing the
amount]{style="text-decoration: underline;"}.&lt;/p&gt;
&lt;p&gt;But it does result in more so to speak "parallelisation" of the mixing
activity, instead of the largest chunk all being in one long chain.&lt;/p&gt;
&lt;p&gt;A question remains, if we imagine that we use much smaller amounts - can
the analyst always follow the "peeling chain of each mixdepth" (to
coin a phrase which at this point hopefully makes sense)?&lt;/p&gt;
&lt;p&gt;I think actually the answer is more 'no' than you might at first
think. The next section will illustrate.&lt;/p&gt;
&lt;h2 id="sudoku"&gt;Joinmarket sudoku.&lt;/h2&gt;
&lt;p&gt;This concept including its origination is covered in some detail in my
earlier article
&lt;a href="https://github.com/AdamISZ/JMPrivacyAnalysis/blob/master/tumbler_privacy.md#jmsudoku-coinjoin-sudoku-for-jmtxs"&gt;here&lt;/a&gt;.
Essentially we are talking about making unambiguous linkages between
change outputs and the corresponding inputs in any given Joinmarket
coinjoin. I reproduce one transaction diagram from that article here to
help the reader keep the right idea in mind:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Coinjoin
canonical" src="https://web.archive.org/web/20200713230834im_/https://joinmarket.me/static/media/uploads/cjmtx.svg"&gt;{width="550"
height="389"}&lt;/p&gt;
&lt;p&gt;So to effect this "sudoku" or disentangling, let's suppose you don't
have any sophistication. You're just going to iterate over every
possible subset of the inputs (they're randomly ordered, of course) and
see if it matches any particular change output (you assume that there is
exactly one change output per participant). In case it wasn't obvious,
"matches" here means "that change output, plus the coinjoin size (3
btc in the diagram above), equals the sum of the subset of inputs".&lt;/p&gt;
&lt;p&gt;Now none of them will &lt;em&gt;actually&lt;/em&gt; match because there are fees of two
types being paid out of (and into) the change - the bitcoin network fees
and the coinjoin fees (which add to most and subtract from one, at least
usually). So since you don't know the exact values of those fees, only
a general range, you have to include a "tolerance" parameter, which
really complicates the issue.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/AdamISZ/15223a5eab940559e5cf55e898354978"&gt;This
gist&lt;/a&gt;
is a quick and dirty (in the sense it's barely a 'program' since i
just hardcoded the values of the transaction) example of doing such a
Joinmarket sudoku for one of the transactions in the OXT Research
analysis of flows for this case. The pythonistas out there might find of
interest particularly this code snippet for finding the "power set"
(the set of all subsets):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;def power_set(l):&lt;/code&gt;\
&lt;code&gt;iil = range(len(l))&lt;/code&gt;\
&lt;code&gt;return list(chain.from_iterable(combinations(iil, r) for r in range(len(iil)+1)))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;As per a very beautiful piece of mathematical reasoning, the power set
of a set of size \(N\) is \(2\^{N}\) (every member of set is either
in, or not in, each subset - think about it!). So this matters because
it illustrates, crudely, how we have here an exponential blowup.&lt;/p&gt;
&lt;p&gt;That particular transaction had 24 inputs, so the power set's
cardinality would be \(2\^{24}\) - but the beginning of the analysis
is to take a subset, of size 4, you already conclude to be linked, thus
reducing the size of the search space by a factor of 16. Now, there's a
lot more to it, but, here's what's interesting: &lt;strong&gt;depending on the
tolerance you choose, you will often find there are multiple sudoku
solutions&lt;/strong&gt; if the size of the set of inputs is reasonably large (let's
say 20 and up, but it isn't possible to fix a specific number of
course). In the first couple of attempts of finding the solution for
that transaction, I found between 3 and 7 different possible ways the
inputs and outputs could connect; some of them involve the pre-grouped 4
inputs acting as taker (i.e. paying fees) and some involve them acting
as maker.&lt;/p&gt;
&lt;p&gt;Now, if this ambiguity isn't enough, there's another significant
source of ambiguity in these sudokus: previous equal-sized coinjoin
outputs. For example take &lt;a href="https://blockstream.info/tx/5f8747a3837a56dd2f422d137b96b1420fd6885be6d1057f3c4dca102a3138b6?output:5"&gt;this
txn&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="un-sudoku-able
tx" src="https://web.archive.org/web/20200713230834im_/https://joinmarket.me/static/media/uploads/.thumbnails/tx5f8747.png/tx5f8747-849x617.png"&gt;{width="849"
height="617"}&lt;/p&gt;
&lt;p&gt;There are 21 inputs, which is already in the "problematic" zone for
sudoku-ing, as discussed, in that it will tend to lead to multiple
possible solutions, with a reasonable tolerance parameter. But in this
case a full sudoku is fundamentally impossible: notice that inputs index
7 and 21 (counting from 0) both have amount 6.1212 . This means that any
subset that includes the first is identical to a subset that includes
the second. Those two outputs are, unsurprisingly, from the same
previous Joinmarket coinjoin (they don't have to be, though).&lt;/p&gt;
&lt;p&gt;In any long "peeling chain" these ambiguities will degrade, perhaps
destroy, the signal over time - unless there is some very strong
watermark effect - such as huge size, which is precisely what we see
with &lt;em&gt;A&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To summarize, we these key points about the Sudoku concept for
identifying chains of ownership:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As long as you don't sweep, a Joinmarket account, thus not emptied,
    will keep creating this chain of ownership via change - though the
    size of that linked amount dwindles over time.&lt;/li&gt;
&lt;li&gt;Thus makers (who cannot sweep) have no guarantee of not having that
    specific ownership trace persist, for each of their 5 accounts (but
    &lt;em&gt;not&lt;/em&gt; across them - the 5 accounts will not be connected on chain,
    at least not in a trivial way).&lt;/li&gt;
&lt;li&gt;If you use a very large size then this acts as a strong enough
    watermark that such tracing is pretty much guaranteed to work (i.e
    the Sudoku works much more reliably if you put in a 400BTC utxo and
    everyone else in the coinjoin only uses 10BTC at max).&lt;/li&gt;
&lt;li&gt;Otherwise, and in general, such tracing is a bit unreliable, and
    over a long series of transactions it becomes very unreliable (but
    again - this is no kind of privacy guarantee! - we just observe that
    there will be increasing uncertainty over a long chain, including
    really fundamental ambiguities like the transaction above).&lt;/li&gt;
&lt;li&gt;Whenever you &lt;em&gt;do&lt;/em&gt; sweep, you create what I called in the previous
    article a &lt;a href="https://github.com/AdamISZ/JMPrivacyAnalysis/blob/master/tumbler_privacy.md#joinmarket-wallet-closures"&gt;"completed mixdepth
    closure"&lt;/a&gt;;
    there is no change for you as taker, and so an end to that
    "chain". This only exists for takers. (you can of course sweep
    &lt;em&gt;without&lt;/em&gt; coinjoin at all, also).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="maker-taker"&gt;Reminder on the maker-taker tradeoff&lt;/h3&gt;
&lt;p&gt;This illustrates another aspect of the more general phenomenon -
Joinmarket almost by definition exists to serve takers. They pay for
these advantages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;As coordinator, they do not reveal linkages to their counterparties.
    Makers must accept that the taker in each individual coinjoin &lt;em&gt;does&lt;/em&gt;
    know &lt;em&gt;their&lt;/em&gt; linkages (the maker's), even if they're OK with that
    over a long period because there are many disparate takers; that's
    a weakness.&lt;/li&gt;
&lt;li&gt;They choose the time when the coinjoin happens (within a minute or
    so, it's done, if all goes well)&lt;/li&gt;
&lt;li&gt;They choose the amount of the coinjoin, so can have a payment as a
    coinjoin outpoint.&lt;/li&gt;
&lt;li&gt;Corollary of the above: they can control the size of their change,
    in particular, reducing it to zero via a "sweep"&lt;/li&gt;
&lt;li&gt;Since they run only when they want to coinjoin, they have a smaller
    time footprint for attackers (makers have an "always on hot
    wallet"&lt;em&gt;which responds to requests rather than initiates them&lt;/em&gt; ,
    so it's more like a server than a client, which is by definition
    difficult to keep properly secure).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These 4+ advantages are what the Taker pays for, and it's interesting
that in practice that the&lt;em&gt;coinjoin&lt;/em&gt; fee has fallen to near-zero
&lt;strong&gt;except for larger sizes&lt;/strong&gt; .I will point to my earlier thoughts on low
fees
&lt;a href="https://x0f.org/web/statuses/104123055565241054"&gt;here&lt;/a&gt;
to avoid further sidetrack.&lt;/p&gt;
&lt;p&gt;Therefore the cool sounding idea "oh I have this bunch of bitcoin
sitting around, I'll just passively mix it for a while and actually get
paid to do it!" (I have noticed people &lt;em&gt;mostly&lt;/em&gt; get interested in
Joinmarket from this perspective) is more limited than it seems.&lt;/p&gt;
&lt;h2&gt;Address reuse&lt;/h2&gt;
&lt;p&gt;This will probably be the shortest section because it's so obvious.&lt;/p&gt;
&lt;p&gt;The fact that 270BTC of the 445 BTC going "into" Joinmarket ended up
at &lt;code&gt;16vBEuZD54NzqnnSStPYxFF2aktGhhuaf1&lt;/code&gt;is kind of a big facepalm moment;
I don't think anyone reading this blog would have trouble understanding
that.&lt;/p&gt;
&lt;p&gt;I don't dismiss or ignore that such things happen for a reason, and
that reason is mainly actions of centralized exchanges to deliberately
reduce the privacy of their customers ("KYC/AML"). Sometimes, of
course, sheer incompetence is involved. But it's the exception rather
than the rule, since even the most basic consumer wallets do not
generally reuse addresses nowadays. I'll consider these real world
factors out-of-scope of this article, although they will matter in your
practical real life decisions about keeping your privacy (consider &lt;em&gt;not&lt;/em&gt;
using such exchanges).&lt;/p&gt;
&lt;p&gt;What has to be said though: 270 does not equal 445 (or 400); it is not
impossible to imagine that such a set of deposits to one address may not
be traced/connected to the original deposit of 400 (+) into Joinmarket
(although it would really help if that total wasn't so very large that
there are only a few Joinmarket participants in that range anyway). And
indeed, my own examination of the evidence tells me that the connections
of each individual final deposit to
`16vBEuZD54NzqnnSStPYxFF2aktGhhuaf1```back to that original 445 is &lt;em&gt;not&lt;/em&gt;
unambiguous. The problem is of course the compounding effect of
evidence, as we will discuss in the next, final section.&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary; lessons learned; advice to users&lt;/h2&gt;
&lt;p&gt;So we've looked into details, can we summarize what went wrong for &lt;em&gt;A&lt;/em&gt;?
Albeit we don't actually know with certainty how much of the
attributions in the OXT Research are correct, they appear to be &lt;em&gt;broadly
correct&lt;/em&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;400 BTC is a very large amount to move through a system of perhaps
    at best a couple hundred users (100 makers on the offer at once is
    typical), most of whom are not operating with more than 10 BTC.&lt;/li&gt;
&lt;li&gt;One large chunk of 400 is therefore a way worse idea than say 10
    chunks of 40 across 10 Joinmarket wallets (just common sense really,
    although starting with 400 is not in itself a disaster, it just
    makes it harder, and slower). This would have been more hassle, and
    more fees, but would have helped an awful lot.&lt;/li&gt;
&lt;li&gt;Running passively as a maker proved too slow for &lt;em&gt;A&lt;/em&gt; (this is an
    assumption that the report makes and that I agree with, but not of
    course a 'fact'). This is Joinmarket's failing if anything; there
    are just not enough people using it, which relates to the next
    point:&lt;/li&gt;
&lt;li&gt;When switching to a taker mode (which in itself was a very good
    idea), &lt;em&gt;A&lt;/em&gt; decided to start doing much larger transaction sizes, but
    found themselves unable to get more than a few counterparties in
    some cases. This should have been a sign that the effect they were
    looking for might not be strong enough, but it's very
    understandable that they didn't grok the next point:&lt;/li&gt;
&lt;li&gt;The "toxic replay attack" very heavily compounds the low anonymity
    set problem mentioned above - reuse of the same counterparties in
    successive transactions reduced the anonymity set from "bad" to
    "disastrously low" (even down to 1 in one case).&lt;/li&gt;
&lt;li&gt;Even with the above failings, all needn't really be lost; repeated
    rounds are used and the '1' anonymity set mentioned output was
    sent to another coinjoin anyway. The first chunk of coins identified
    to be sent to Poloniex address (first to be identified, not first in
    time) was in an amount of about 28 BTC via several hops, then part
    of the 76 BTC in &lt;a href="https://web.archive.org/web/20200713230834/https://joinmarket.me/blog/blog/the-445-btc-gridchain-case/%22https://blockstream.info/tx/ab1e604cd959cc94b89ab02b691fe7d727d30637284e5e82908fb28b8db378f4"&gt;this
    txn&lt;/a&gt;,
    and even the first hop only had a 50% likelihood assigned. So it's
    a combination of (a) the address being marked as in the POLONIEX
    cluster, the size of the deposit and then the reuse allowing tracing
    back to other transactions, that caused a "high-likelihood
    assignment of ownership", which leads into ...&lt;/li&gt;
&lt;li&gt;Address reuse as discussed in the previous section is the biggest
    failing here. If all the deposits here were to different exchange
    addresses, these heuristics would not have led to any clear
    outcomes. A few guesses here and there would exist, but they would
    remain guesses, with other possibilities also being reasonable.&lt;/li&gt;
&lt;li&gt;Circling back to the beginning, notice how making educated guesses
    about deposits on exchanges a few hops away from Joinmarket might
    already be enough to get some decent guesses at ownership, if the
    sizes are large enough compared to the rest of the Joinmarket usage.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So overall the post mortem is: &lt;strong&gt;a combination of at least three
different things leads to a bad outcome for &lt;em&gt;A&lt;/em&gt; : large (much bigger
than typical JM volume) size not split up, heavy address reuse (on a
centralized exchange) and a small anonymity set portion of the
sequence.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This issue of "combination of factors" leading to a much worse than
expected privacy loss is explained well on the bitcoin wiki Privacy page
&lt;a href="https://en.bitcoin.it/wiki/Privacy#Method_of_data_fusion"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="already"&gt;Already implemented improvements&lt;/h3&gt;
&lt;p&gt;When running as a taker and using the so-called &lt;a href="https://github.com/JoinMarket-Org/joinmarket-clientserver/blob/master/docs/tumblerguide.md"&gt;tumbler
algorithm&lt;/a&gt;
users should note that in 2019 a fairly meaningful change to the
algorithm was implemented - one part was to start each run with a sweep
transaction out of each mixdepth containing coins as the first step
(with longer randomized waits). This makes a peeling chain direct from a
deposit not possible (you can always try to guess which coinjoin output
to hop to next of course, with the concomitant difficulties).
Additionally average requested anonymity sets are increased, which, as
an important byproduct tends to create larger input sets which are
harder to sudoku (and more likely to have substantial ambiguity). There
are several other minor changes like rounding amounts, see &lt;a href="https://gist.github.com/chris-belcher/7e92810f07328fdfdef2ce444aad0968"&gt;Chris
Belcher's document on
it&lt;/a&gt;
for more details.&lt;/p&gt;
&lt;h3 id="still-needed"&gt;Still needed improvements&lt;/h3&gt;
&lt;p&gt;Clearly the toxic recall attack concept matters - it is going to matter
more, statistically, as the anonymity set (i.e. the number of coinjoin
counterparties) is reduced, but it matters per se in any context -
reusing the same counterparties &lt;strong&gt;&lt;em&gt;in a sequence of coinjoins from the
same mixdepth closure&lt;/em&gt;&lt;/strong&gt; reduces the anonymity set. Notice there are a
couple of ways that situation could be remediated:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reduce the number of coinjoin transactions within the same mixdepth
    closure - but this is not clear. If I do 1 coinjoin transaction with
    10 counterparties and it's a sweep, closing the mixdepth closure,
    is that better than doing 2 coinjoin transactions from it, each of
    which has 6 counterparties, if there is a 10% chance of randomly
    choosing the same counterparty and thus reducing the anonymity set
    of the second coinjoin by 1? That is pretty profoundly unclear and
    seems to just "depend". 1 transaction with 12 counterparties &lt;em&gt;is&lt;/em&gt;
    clearly better, but very large sets like that are very difficult to
    achieve in Joinmarket today (particularly if your coinjoin amount is
    large).&lt;/li&gt;
&lt;li&gt;Actively try to prevent reusing the same counterparty for multiple
    transactions in the same mixdepth closure (obviously this is for
    takers; makers are not choosing, they are offering). Identification
    of bots is problematic, so probably the best way to do this is
    simply for a taker to keep track of its earlier txs (especially
    within a tumbler run, say) and decide to not include makers when
    they provide utxos that are recognized as in that set. This is still
    a bit tricky in practice; makers don't want their utxos queried all
    the time, but takers for optimal outcomes would like full
    transparent vision into those utxo sets - see &lt;a href="https://web.archive.org/web/20200713230834/https://joinmarket.me/blog/blog/poodle/"&gt;earlier discussion of
    PoDLE&lt;/a&gt;
    and
    &lt;a href="https://web.archive.org/web/20200713230834/https://joinmarket.me/blog/blog/racing-against-snoopers-in-joinmarket-02/"&gt;here&lt;/a&gt;
    on this blog for the tricky points around this.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(2) is an example of ideas that were discussed by Joinmarket
developers years ago, but never really went anywhere. Takers probably
&lt;em&gt;should&lt;/em&gt; expand the query power given them by the PoDLE tokens to have a
larger set of options to choose from, to gauge the "quality" of what
their counterparties propose as join inputs, but it's a delicate
balancing act, as mentioned.&lt;/p&gt;
&lt;h3 id="recommendations"&gt;Recommendations for users&lt;/h3&gt;
&lt;p&gt;For the final section, some practical advice. Joinmarket can be a
powerful tool - but it's unfortunately not very easy to understand what
you &lt;em&gt;should&lt;/em&gt; do, precisely because there is a lot of flexibility.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The taker role, and in particular the tumbler role, are designed to
    be used to actively improve your privacy. We explain above that it
    gives certain advantages over the maker role. So: &lt;strong&gt;use it!&lt;/strong&gt; - with
    at least the default settings for counterparty numbers and
    transaction numbers, and long waits - in fact, increase these
    factors above the defaults. Note that tumbles can be safely
    restarted, so do it for a day, shut it down and then restart it a
    few days later - that's fine. See the docs for more on that. Be
    sensitive to bitcoin network fees - these transactions are very
    large so they'll be more palatable at times when the network is
    clearing 1-5 sats/byte. However ...&lt;/li&gt;
&lt;li&gt;... mixing roles definitely has advantages. The more people mix
    roles the more unsafe it is to make deductions about which coinjoin
    output belonged to the taker, after it gets spent (consider what you
    can deduce about a coinjoin output which is then spent via an
    ordinary wallet, say to a t-shirt merchant).&lt;/li&gt;
&lt;li&gt;The maker role isn't useless for privacy, it's rather best to
    think of it as (a) limited and (b) taking a long time to have an
    effect. It's most suitable if your threat model is "I don't want
    a clear history of my coins over the long term". It also costs
    nothing monetarily and brings in some very small income if your size
    is large (if small, it's likely not worth mentioning) - but in that
    case, take your security seriously.&lt;/li&gt;
&lt;li&gt;Consider sizing when acting as a taker. We as a project should
    perhaps create more transparency around this, but you can gauge from
    your success in arranging big size coinjoins: if you can't easily
    find 6+ counterparties to do a coinjoin at a particular size, it may
    not be a good idea to rely on the outcomes, as you may be mixing in
    too small of a crowd (whether that's at 10 BTC or 20 BTC or 50+ BTC
    just depends on market condition).&lt;/li&gt;
&lt;li&gt;Make good use of (a) the accounts (mixdepths) feature, (b) the coin
    freeze feature and (c) the sweep feature (taker only). These three
    things allow you to better isolate coins going to different
    destinations - your cold wallet, your mobile spending wallet, an
    exchange etc etc. Accounts let you have the assurance that coins in
    one aren't linked with coins in another; you can't accidentally
    co-spend them. The freeze feature (see the "Coins" tab on Qt) lets
    you spend individual utxos, where that's important to you for some
    reason, without connection to others. And the sweep feature lets you
    make a coinjoin without any change, breaking a link to future
    transactions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We soon (in 0.7.0; the code is basically already done) hope to have more
helpful features, in particular Payjoin as defined in BIP 78, along with
very basic PSBT support.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="coinjoin"></category><category term="joinmarket"></category><category term="bitcoin"></category></entry><entry><title>Schnorrless Scriptless Scripts</title><link href="https://joinmarket.me/blog/blog/schnorrless-scriptless-scripts/" rel="alternate"></link><published>2020-04-15T00:00:00+02:00</published><updated>2020-04-15T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2020-04-15:/blog/blog/schnorrless-scriptless-scripts/</id><summary type="html">&lt;p&gt;a new ECDSA single-signer adaptor signature construction.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Schnorrless Scriptless Scripts&lt;/h3&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The weekend of April 4th-5th 2020 we had a remote "Lightning
Hacksprint" organized by the ever-excellent Fulmo, one Challenge was
related to "Payment Points" (see
&lt;a href="https://wiki.fulmo.org/index.php?title=Challenges#Point_Time_Locked_Contracts_.28PTLC.29"&gt;here&lt;/a&gt;;
see lots more info about the hacksprint at that wiki) and was based
around a new innovation recently seen in the world of adaptor
signatures. Work was led by Nadav Kohen of Suredbits and Jonas Nick of
Blockstream; the latter's API for the tech described below can be seen
currently as a PR to the secp256k1 project
&lt;a href="https://github.com/jonasnick/secp256k1/pull/14"&gt;here&lt;/a&gt;.
The output from Suredbits was a demo as show
&lt;a href="https://www.youtube.com/watch?v=w9o4v7Idjno&amp;amp;feature=youtu.be"&gt;here&lt;/a&gt;
on their youtube, a PTLC (point time locked contract, see their
&lt;a href="https://suredbits.com/payment-points-part-1/"&gt;blog&lt;/a&gt;
for more details on that).&lt;/p&gt;
&lt;p&gt;I will not focus here on either the proof of concept code, nor the
potential applications of this tech (which are actually many, not only
LN, but also Discreet Log contracts, various design of tumbler and
others), but entirely on the cryptography.&lt;/p&gt;
&lt;h2&gt;What you can do with Schnorr adaptors&lt;/h2&gt;
&lt;p&gt;Previous blog posts have covered in some detail the concept of adaptor
signatures, how they are simply realizable using the Schnorr signature
primitive. Also noted here and elsewhere is that there are techniques to
create the same effect using ECDSA signature, but involving considerable
additional crypto machinery (Paillier homomorphic encryption and certain
zero knowledge (range) proofs). This technique is laid out in
&lt;a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/attachments/20180426/fe978423/attachment-0001.pdf"&gt;this&lt;/a&gt;
brief note, fleshed out fully in
&lt;a href="https://eprint.iacr.org/2017/552"&gt;this&lt;/a&gt;
cryptographic construction from Lindell, paired with
&lt;a href="https://eprint.iacr.org/2018/472"&gt;this&lt;/a&gt;
paper on multihop locks (which represents a very important theoretical
step forward for Lightning channel construction). The problem with that
"tech stack" is the complexity in the Lindell construction, as
mentioned.&lt;/p&gt;
&lt;p&gt;A recent
&lt;a href="https://github.com/LLFourn/one-time-VES/blob/master/main.pdf"&gt;paper&lt;/a&gt;
by Lloyd Fournier represents a very interesting step forward, at least
in a certain direction: it allows "single signer" ECDSA adaptor
signatures. The scare quotes in the previous sentence represent the fact
that the use of such adaptor signatures would not literally be single
signer - it would be in the context of Bitcoin's &lt;code&gt;OP_CHECKMULTISIG&lt;/code&gt;,
most typically 2 of 2 multisig, so the same as the current
implementation of the Lightning network, in which a contract is enforced
by having funds controlled by both parties in the contract. Here, what
is envisaged is not a cooperative process to construct a single
signature (aggregated), but each party can individually create adaptor
signatures with signing keys they completely control. That this is
possible was a big surprise to me, and I think others will be unclear on
it too, hence this blog post after a week or so of study on my part.&lt;/p&gt;
&lt;p&gt;Let's remember that the Schnorr adaptor signature construction is:&lt;/p&gt;
&lt;p&gt;\(\sigma'(T, m, x) = k + H(kG+T||xG||m)x\)&lt;/p&gt;
&lt;p&gt;where \(k\) is the nonce, \(x\) is the private (signing) key and
\(T\) is the 'adaptor point' or just adaptor. The left-hand-side
parentheses are important: notice that &lt;strong&gt;you don't need the discrete
log of the point T to construct the adaptor signature&lt;/strong&gt;. But you &lt;em&gt;do&lt;/em&gt;
need the signing key \(x\). Or wait .. do you?&lt;/p&gt;
&lt;p&gt;As I explained last year
&lt;a href="https://x0f.org/web/statuses/102897691888130818"&gt;here&lt;/a&gt;
it's technically not the case: you can construct an adaptor signature
for signing pubkey \(P\) for which you don't know \(x\) s.t.
\(P=xG\), with a fly in the ointment: you won't be able to predict
the adaptor \(T\) or know its discrete log either (this makes it
un-dangerous, but still an important insight; I was calling this
"forgeability" but more on that later).&lt;/p&gt;
&lt;p&gt;How you ask? To summarize the mastodon post:&lt;/p&gt;
&lt;p&gt;\(\stackrel{\$}{\leftarrow} q, Q=qG, \quad \mathrm{assume}\quad
R+T =Q\)&lt;/p&gt;
&lt;p&gt;\(\Rightarrow \sigma' G= R + H(P,Q,m)P\)&lt;/p&gt;
&lt;p&gt;\(\stackrel{\$}{\leftarrow} \sigma' \quad \implies R = s'G -
H(P,Q,m)P \implies T = Q-R\)&lt;/p&gt;
&lt;p&gt;Thus anyone can publish an adaptor signature \((T, \sigma')\) on any
message \(m\) for any pubkey \(P\) at any time. It&lt;em&gt;really&lt;/em&gt; isn't a
signature.&lt;/p&gt;
&lt;p&gt;And equally obvious is that this does not allow the "forger" to
complete the adaptor into a full signature (\(\sigma = \sigma' +
t\)) - because if he could, this would be a way to forge arbitrary
Schnorr signatures!&lt;/p&gt;
&lt;p&gt;With the caveat in the above little mathematical vignette aside, we note
that the bolded phrase above is the crucial point: adaptors can be
created by non-secret owners, for secret owners to complete.&lt;/p&gt;
&lt;h2&gt;Adaptors in ECDSA with less wizardry&lt;/h2&gt;
&lt;p&gt;I was alerted to this trick via &lt;a href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2019-November/002316.html"&gt;this mailing list
post&lt;/a&gt;
and the work of the Suredbits guys, in particular Nadav Kohen, who blogs
on payment points, DLCs and related topics
&lt;a href="https://suredbits.com/payment-points-part-1/"&gt;here&lt;/a&gt;.
The idea can be summarised as "tweak the nonce multiplicatively instead
of linearly". Take the following notation for the base (complete) ECDSA
signature:&lt;/p&gt;
&lt;p&gt;\(\sigma = k^{-1}\left(\mathbb{H}(m) + R_{\mathrm{x}}x\right)
\)&lt;/p&gt;
&lt;p&gt;Here we're using the most common, if sometimes confusing notation. As
usual \(k\) is the nonce (generated deterministically usually),
\(R=kG\), \(m\) is the message and \(x\) is the private signing
key whose public key by convention is \(P\). Meanwhile
\(R_{\mathrm{x}}\) indicates the x-coordinate of the curve point
\(R\), with the usual caveats about the difference between the curve
order and the order of the finite field from which the coordinates are
drawn (feel free to ignore that last part if it's not your thing!).&lt;/p&gt;
&lt;p&gt;Now clearly you cannot just add a secret value \(t\) to the nonce and
expect the signature \(\sigma\) to be shifted by some simple factor.
Multiplication looks to make more sense, since after all the nonce is a
multiplicative factor on the RHS. But it's not so simple, because the
nonce-&lt;em&gt;point&lt;/em&gt; appears as the term \(R_{\mathrm{x}}\) inside the
multiplied factor. The clever idea is how to get around this problem. We
start by defining a sort-of "pre-tweaked" nonce:&lt;/p&gt;
&lt;p&gt;\(R' = kG\)&lt;/p&gt;
&lt;p&gt;and then the real nonce that will be used will be multiplied by the
adaptor secret \(t\):&lt;/p&gt;
&lt;p&gt;\(R = kT = ktG\)&lt;/p&gt;
&lt;p&gt;Then the adaptor signature will be published as:&lt;/p&gt;
&lt;p&gt;\(\sigma' = k^{-1}\left(\mathbb{H}(m) + R_{\mathrm{x}}x\right)
\)&lt;/p&gt;
&lt;p&gt;... which may look strange as here the RHS is identical to what we
previously had for the &lt;em&gt;complete&lt;/em&gt; signature \(\sigma\). The
difference of course is that here, the terms \(k\) and \(R\) don't
match up; \(R\) has private key \(kt\) not \(k\). And hence we can
easily see that:&lt;/p&gt;
&lt;p&gt;\(\sigma = t^{-1} \sigma'\)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;will&lt;/em&gt; be a valid signature, whose nonce is \(kt\).&lt;/p&gt;
&lt;p&gt;However, we do not operate in a world without adversaries, so to be sure
of the statement "if I get given the discrete log of \(T\), I will be
able to construct a fully valid \(\sigma\)", we need a proof of that
claim. This is the key innovation, because this can be done &lt;em&gt;very&lt;/em&gt;
simply with a proof-of-discrete-log, or a "PoDLE" as was described in
one of the first &lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/poodle/"&gt;blog
posts&lt;/a&gt;
here. To prove that \(R'/G = R/T = k\), where we somewhat abuse / to
mean "elliptic curve discrete log", you just create an AND of two
\(\Sigma\)-protocols, using the same commitment (i.e., nonce), let's
call it \(k_2\) and output a schnorr style response \(s = k_2 +
ek\), where the hash e covers both points \(k_2 G\ ,\ k_2 T\) as
has been explained in the just-mentioned PoDLE blog post and also in a
bit more generality in the &lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/ring-signatures/"&gt;post on ring
signatures&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It's thus intuitive, though not entirely obvious, that an "adaptor
signature" in this context is really a combination of the same idea as
in Schnorr, but with additionally a PoDLE tacked-on:&lt;/p&gt;
&lt;p&gt;Input:&lt;/p&gt;
&lt;p&gt;an adaptor point \(T\), a message \(m\), a signing key \(x\)&lt;/p&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;p&gt;adaptor signature \((\sigma', R, R')\), adaptor signature PoDLE:
\((s, e)\)&lt;/p&gt;
&lt;p&gt;Verification for non-owner of adaptor secret \(T\):&lt;/p&gt;
&lt;p&gt;1. Verify the PoDLE - proves that \(R, R'\) have same (unknown)
discrete log w.r.t. \(T, G\) respectively.&lt;/p&gt;
&lt;p&gt;2. Verify \(\sigma' R' \stackrel{?}{=} \mathbb{H}(m) +
R_{\mathrm{x}} P\)&lt;/p&gt;
&lt;h2&gt;Swapping ECDSA coins with this method&lt;/h2&gt;
&lt;p&gt;Fundamentally, if not exclusively, adaptor signatures as originally
conceived, and still here, allow the swap of a coin for a secret (in
that broadcast of a spending transaction necessarily implies broadcast
of a signature which can be combined with a pre-existing adaptor
signature to reveal a secret), and the crudest example of how that can
be used is the coinswap or atomic swap, see
&lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/coinswaps/"&gt;these&lt;/a&gt;
&lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;previous&lt;/a&gt;
blog posts for a lot of detail on pre-existing schemes to do this, both
with and without the Schnorr signature primitive that was previously
thought to be near-required to do adaptor signatures.&lt;/p&gt;
&lt;p&gt;The ECDSA scheme above can be used in a slightly different way than I
had originally described for Schnorr adaptor signatures, but it appears
that was partly just oversight on my part: the technique described below
&lt;em&gt;can&lt;/em&gt; be used with Schnorr too. So the advantage here is principally
that we can do it right now.&lt;/p&gt;
&lt;p&gt;1. Alice spends into a 2/2 A1 B1 after first negotiating a timelocked
refund transaction with Bob, so she doesn't risk losing funds.&lt;/p&gt;
&lt;p&gt;2. Bob does the same, spending into a 2/2 A2 B2 after negotiating a a
timelocked refund tranasction with Alice, so he also doesn't risk, but
his timelock is closer.&lt;/p&gt;
&lt;p&gt;3. Alice creates an adaptor \(\sigma_{1}^{'}\) spending with key
A1 to Bob's destination and adaptor point \(T\) for which she knows
discrete log \(t\).&lt;/p&gt;
&lt;p&gt;4. Bob verifies \(\sigma_{1}^{'}\) and the associated data
mentioned above, including crucially the PoDLE provided.&lt;/p&gt;
&lt;p&gt;5. Bob creates an adaptor \(\sigma_{2}^{'}\) spending with key B2
to Alice's destination and adaptor point \(T\) for which he does
&lt;strong&gt;not&lt;/strong&gt; know the \(t\).&lt;/p&gt;
&lt;p&gt;6. Alice can now safely complete the adaptor she receives: \(\sigma_2
= t^{-1}\sigma_{2}^{'}\) and co-sign with A2 and broadcast,
receiving her funds.&lt;/p&gt;
&lt;p&gt;7. Bob can see on the blockchain (or communicated directly for
convenience): \(t = \sigma_{2}^{'}\sigma_{2}^{-1}\) and use it
to complete: \(\sigma_{1} = t^{-1}\sigma_{1}^{'}\), and co-sign
with B1 and broadcast, receiving his funds.&lt;/p&gt;
&lt;h3&gt;Comparisons to other coinswaps:&lt;/h3&gt;
&lt;p&gt;This requires 2/2 P1 P2 type scriptPubKeys; these can be p2sh multisig
or p2wsh multisig using, as mentioned, &lt;code&gt;OP_CHECKMULTISIG&lt;/code&gt;. Notice that
in a future Taproot/Schnorr world, this will still be possible, using
the linear style adaptor signatures previously described. However in
that case a musig-style combination of keys will almost certainly be
preferred, as it will create transaction styles that look
indistinguishable from single or any other script types. For now, the
system above does share one very valuable anonymity set: the set of
Lightning channel opens/closes, but doesn't share an anonymity set with
the full set of general single-owner ECDSA coins (which includes both
legacy and segwit).&lt;/p&gt;
&lt;p&gt;For now, this method has the principal advantage that the only failure
mode is the timelocked backout, which can be a transaction that looks
entirely normal - having a non-zero &lt;code&gt;nLockTime&lt;/code&gt; somewhere around the
current block is actually very normal. While the atomic enforcement part
is, just like Schnorr adaptors, entirely invisible. So apart from the
smaller anonymity set (2-2, so mostly LN), it has excellent privacy
properties.&lt;/p&gt;
&lt;h2&gt;Reframing adaptors \(\rightarrow\) otVES&lt;/h2&gt;
&lt;p&gt;The aforementioned
&lt;a href="https://github.com/LLFourn/one-time-VES/blob/master/main.pdf"&gt;paper&lt;/a&gt;
of 2019 by Lloyd Fournier is titled "&lt;em&gt;One Time Verifiably Encrypted
Signatures A.K.A. Adaptor Signatures&lt;/em&gt;" - at first this new name
(henceforth otVES) seemed a bit strange, but after reading the paper I
came away pretty convinced. Both the conceptual framework is very clean,
but also, this links back to earlier work on the general concept of
Verifiably Encrypted Signatures. Most particularly the work of the same
guys that brought us BLS signatures from bilinear pairing crypto, in
&lt;a href="http://crypto.stanford.edu/~dabo/papers/aggreg.pdf"&gt;this
paper&lt;/a&gt;
(namely, Boneh, Lynn, Shacham but also Gentry of FHE fame). The context
considered there was wildly different, as Fournier helpfully explains:
this earlier work imagined that Alice and Bob wanted to fairly exchange
signatures that might be useful as authorization for some purpose. To
achieve that goal, they imagined trusted third party acting between
them, and that an encrypted-to-third-party-adjudicator but still
&lt;em&gt;verifiable&lt;/em&gt; signature could serve as the first step of a fair protocol,
assuming honesty of that third party. However what makes the Bitcoin
use-case special is that signatures &lt;strong&gt;are useable if and only if
broadcast&lt;/strong&gt;&lt;em&gt;.&lt;/em&gt;All of this coinswap/HTLC/second layer stuff relies on
that property. In this scenario, having not only a VES but an otVES is
exactly desirable.&lt;/p&gt;
&lt;p&gt;Why is one-time desirable here? It's a little obtuse. For those
familiar with cryptography 101 it'll make sense to think about the &lt;a href="https://en.wikipedia.org/wiki/One-time_pad"&gt;one
time
pad&lt;/a&gt;.
The absolutely most basic concept of encryption (which also happens to
be perfectly secure, when considered in the most &lt;a href="https://en.wikipedia.org/wiki/Spherical_cow"&gt;spherical
cow&lt;/a&gt;
kind of way): take a plaintext \(p\) and a key \(k\), bitstrings of
the exact same length. Then make the ciphertext \(c\):&lt;/p&gt;
&lt;p&gt;\(c = p \oplus k\)&lt;/p&gt;
&lt;p&gt;and the thing about this that makes it perfect is exactly also something
that can be considered a "bug": the symmetry of the \(\oplus\)
(xor) operation is such that, given both the plaintext and the
ciphertext, the key can be derived: \(k = c \oplus p\). So any
broadcast of \(p\), after an earlier transfer of \(c\) (to Bob,
let's say), means that the secret key is revealed.&lt;/p&gt;
&lt;p&gt;The same is true in our adaptor signature or VES scenario: the adaptor
signature \(\sigma'\) is an "encrypted signature", and is
verifiable using the verification algorithm already discussed, by anyone
who has that encrypted signature and the adaptor "public key" which we
called \(T\). Notice how this is analogous to&lt;em&gt;public&lt;/em&gt; key encryption,
in that you only need a public key to encrypt; but also notice that the
one-time pad is&lt;em&gt;secret key&lt;/em&gt;encryption, which is why the plaintext and
ciphertext are enough to reveal the key (note: more developed secret key
algorithms than OTP handle this problem). This is some kind of hybrid of
those cases. Once the "plaintext" signature \(\sigma\) is revealed,
the holder of the "encrypted" signature \(\sigma'\) can derive the
private key: \(t\).&lt;/p&gt;
&lt;p&gt;So hopefully this makes clear why "one-time-ness" is not so much in
itself desirable, as what is implied by it: that the "private key"
(the &lt;em&gt;encryption&lt;/em&gt; key, not the &lt;em&gt;signing&lt;/em&gt; key, note!) is revealed on one
usage.&lt;/p&gt;
&lt;h2&gt;Security properties - deniability, forgeability, validity, recoverability ...&lt;/h2&gt;
&lt;p&gt;At a high level, what security properties do we want from these
"encrypted signatures''? I think there's a strong argument to focus
on two properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handing over such encrypted signatures should not leak any
    information to any adversary, including the recipient (it may or may
    not be needed to keep the transfer private, that is not considered
    in the model).&lt;/li&gt;
&lt;li&gt;Given an encrypted signature for a message and key, I should be able
    to convince myself that when the plaintext signature is revealed, I
    will get the secret key \(t\), or complementary: when the secret
    key \(t\) is revealed, I should be able to recover the plaintext
    signature.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll deal with both of these points in the following subsections.&lt;/p&gt;
&lt;h3&gt;Deniability&lt;/h3&gt;
&lt;p&gt;The Schnorr version of the otVES is deniable in the specific sense that
given an unencrypted signature, a corresponding encrypted signature for
any chosen key (\(t\)) can be claimed, as was explained
&lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;here&lt;/a&gt;
("Deniability" subsection). For anyone familiar with the basic
construction of zero knowledge proofs, this will be immediately
recognized as being the definition of a "Simulator", and therefore
proves that such an adaptor signature/encrypted signature leaks zero
information to recipients.&lt;/p&gt;
&lt;p&gt;It is interesting to observe that the same trick does &lt;strong&gt;not&lt;/strong&gt; work with
the ECDSA variant explained above:&lt;/p&gt;
&lt;p&gt;Given \(\sigma, R\) satisfying \(\sigma R = \mathbb{H}(m)G +
R_{\mathrm{x}}P\) for the verifying pubkey \(P\), you can try to
assert that \(k = tk_2\) but &lt;strong&gt;you have no way to generate a PoDLE for
\(R, R'\) if you don't know k&lt;/strong&gt; - this means that such a
"retrofitted" encrypted signature (which by definition&lt;em&gt;includes&lt;/em&gt; the
PoDLE) is not possible for a party not knowing the original secret
nonce, and thus the simulator argument (the argument that an external
observer &lt;em&gt;not knowing the secret&lt;/em&gt; can create fake transcripts with a
distribution indistinguishable from the real transcripts) is not
available, hence we cannot claim that such encrypted signatures are
fully zero knowledge. More on this shortly.&lt;/p&gt;
&lt;h3&gt;Forgeability&lt;/h3&gt;
&lt;p&gt;I am abusing terms here, because unforgeability is the central property
of a valid signature scheme, but here let's talk about the forgeability
of an &lt;em&gt;encrypted&lt;/em&gt; signature, so perhaps "adaptor forgeability". Here I
mean the ability to create arbitrary encrypted signatures &lt;em&gt;without&lt;/em&gt; the
signing key. This was demonstrated as possible for Schnorr in the first
section of this blog post (noting the obvious caveat!). For ECDSA, we
hit the same snag as for 'Deniability'. Without possessing the signing
key \(x\), you want to make the verification \(\sigma' R' =
\mathbb{H}(m)G + R_{\mathrm{x}}P\) pass for some \(R, R', T, R =
tR'\) such that you can prove DLOG equivalence w.r.t. \(G, T\). You
can do this by "back-solving" the same way as for Schnorr:&lt;/p&gt;
&lt;p&gt;\(\stackrel{\$}{\leftarrow} k^{*}, R=k^{*}G, \quad Q =
\mathbb{H}(m)G + R_{\mathrm{x}}P\)&lt;/p&gt;
&lt;p&gt;\(\stackrel{\$}{\leftarrow} \sigma', \quad \Rightarrow \sigma'
R' = Q \Rightarrow R' = (\sigma')^{-1}Q\)&lt;/p&gt;
&lt;p&gt;But since this process did &lt;em&gt;not&lt;/em&gt; allow you to deduce the scalar \(q\)
s.t. \(Q = qG\), it did not allow you to deduce the corresponding
scalar for \(R'\). Thus you can output a set \(\sigma', R, R'\)
but you cannot also know, and thus prove equivalence of, the discrete
logs of \(R\) and \(R'\).&lt;/p&gt;
&lt;p&gt;The previous two sections demonstrate clearly that the otVES
construction for ECDSA is fundamentally different from that for Schnorr
in that it requires providing, and proving a relationship between two
nonces, and this also impacts quite significantly the security arguments
that follow.&lt;/p&gt;
&lt;h3&gt;Validity, Recoverability&lt;/h3&gt;
&lt;p&gt;These are aspects of the same thing, so grouped together, and they talk
about the most central and unique property for an otVES scheme, but
fortunately it is almost tautological to see that they hold for these
schemes.&lt;/p&gt;
&lt;p&gt;The concern it addresses: what if Alice gave Bob an encrypted signature
to a key \(T\) but it turned out that when decrypted with the
corresponding key \(t\), a valid signature wasn't actually revealed.
That this is impossible is called &lt;strong&gt;validity&lt;/strong&gt;. The flip side is
&lt;strong&gt;recoverability&lt;/strong&gt;: if Alice gave Bob an encrypted signature and then
published the corresponding decrypted signature ("plaintext"), the
secret key for the encryption (\(t\)) must be revealed.&lt;/p&gt;
&lt;p&gt;The Schnorr case illustrates the point clearly, see Lemma 4.1 in
Fournier's paper; \(\sigma' = \sigma -t\) in our notation and we
can see by the definition of Schnorr signature verification that this
must hold, given there cannot be another \(t' \ne t\) s.t. \(t'G =
T\) (there is a one-one mapping between scalars mod n and group
points). Recoverability is also unconditionally true in the same way.&lt;/p&gt;
&lt;p&gt;For the ECDSA case, it is nearly the same, except: we rely on the PoDLE
between \(R, R'\), which has the same properties itself as a Schnorr
signature, and so the properties hold conditional on the inability to
break ECDLP (because that would allow Schnorr forgery, and thus PoDLE
forgery).&lt;/p&gt;
&lt;p&gt;Note how a ECDLP break can obviously destroy the usefulness of all these
schemes, in particular the underlying signature schemes, but even that
does not alter the fact that the Schnorr encrypted signature is valid
and recoverable (though it becomes a mere technicality in that case).&lt;/p&gt;
&lt;h3&gt;EUF-CMA for otVES using Schnorr&lt;/h3&gt;
&lt;p&gt;EUF-CMA was discussed in the previous blogs on the Schnorr signature and
on ring signatures, in brief it is a technical term for "this signature
scheme is secure in that signatures cannot be forged by
non-secret-key-owners under this specific set of (fairly general)
assumptions".&lt;/p&gt;
&lt;p&gt;Proving this for the Schnorr otVES turns out to be a fairly standard
handle-cranking exercise. This is essentially what I have focused on in
previous work as "proving soundness by running an extractor",
including patching up the random oracle. See the above linked post on
the Schnorr signature for more detail.&lt;/p&gt;
&lt;p&gt;Note that unforgeability referred to here &lt;strong&gt;is not the same as "adaptor
forgeability" discussed above&lt;/strong&gt;. Here we are specifically trying to
prove that access to such encrypted signatures does not help the
adversary in his pre-existing goal of forging &lt;em&gt;real&lt;/em&gt;signatures.&lt;/p&gt;
&lt;p&gt;So the handle-cranking simply involves adding an "encrypted signature
oracle" to the attacker's toolchest. EUF-CMA[VES] basically refers
to the inability to create signatures on new messages even when you have
access to arbitrary encrypted signatures, as well as arbitrary earlier
&lt;em&gt;complete&lt;/em&gt; signatures, again, on different messages.&lt;/p&gt;
&lt;p&gt;As Fournier points out here:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;EUF-CMA[VES] says nothing about the unforgeability of signature
encryptions. In fact, an adversary who can produce valid VES
ciphertexts without the secret signing key is perfectly compatible. Of
course, they will never be able to forge a VES ciphertext under a
particular encryption key. If they could do that, then they could
trivially forge an encrypted signature under a key for which they know
the decryption key and decrypt it.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;... which is the reason for my (I hope not too confusing) earlier
section on "adaptor forgeability". It &lt;em&gt;is&lt;/em&gt; actually possible, for
Schnorr, but not ECDSA, to do what is mentioned in the second sentence
above.&lt;/p&gt;
&lt;h3&gt;EUF-CMA[VES] for ECDSA&lt;/h3&gt;
&lt;p&gt;Here is the most technical, but the most important and difficult point
about all this. In producing an encrypted ECDSA signature you output:&lt;/p&gt;
&lt;p&gt;\((\sigma', R, R', m, P), \quad \textrm{DLEQ}(R, R')\)&lt;/p&gt;
&lt;p&gt;(while \(m, P\) may be implicit of course), and this means you output
one piece of information in addition to the signature: that two nonce
points are related in a specific way. It turns out that this can be
expressed differently as the Diffie Hellman key of the key pair \((P,
T)\) (or, in Fournier's parlance, the signing key and the encryption
key). That DH key would be \(tP = xT = xtG\). Here's how; starting
from the verification equation for a published encrypted signature,
using the notation that we've used so far:&lt;/p&gt;
&lt;p&gt;\(s'R' = \mathbb{H}(m) + R_{\mathrm{x}}P\)&lt;/p&gt;
&lt;p&gt;isolate the public key P (this is basically "pubkey recovery"):&lt;/p&gt;
&lt;p&gt;\(P = R_{\mathrm{x}}^{-1}\left(s'R' - \mathbb{H}(m)G\right)\)&lt;/p&gt;
&lt;p&gt;\(\Rightarrow tP = R_{\mathrm{x}}^{-1}\left(s'tR' -
\mathbb{H}(m)tG\right)\)&lt;/p&gt;
&lt;p&gt;\(\Rightarrow xT = tP = R_{\mathrm{x}}^{-1}\left(s'R -
\mathbb{H}(m)T\right)\)&lt;/p&gt;
&lt;p&gt;Notice how we - a verifier, not possessing either the nonce \(k\) nor
the secret \(t\) - were able to deduce &lt;em&gt;this&lt;/em&gt; DH key because we knew
the DH key of the key pair \((R', T)\) - it's \(R\), which we were
explicitly given. So this, in some sense "breaks" the &lt;a href="https://en.wikipedia.org/wiki/Computational_Diffie%E2%80%93Hellman_assumption"&gt;CDH
assumption&lt;/a&gt;:
that given only points on the curve \(A=aG, B=bG\) you should not be
able to calculate the third point \(abG\) (but "breaks" - because
actually we were given a related DH key to start with).&lt;/p&gt;
&lt;p&gt;Fournier addresses this point in two ways. First, he argues that
requirement of the CDH problem being hard is not part of the protocols
for which this scheme is useful and that keys are by design one-time-use
in these applications. The more important point though, is that an
attempt is made to show the scheme secure &lt;strong&gt;if the CDH problem is
easy&lt;/strong&gt;. A classic example of backwards cryptography logic ;)&lt;/p&gt;
&lt;p&gt;The framework for this is non-trivial, and it is exactly the framework
developed by Fersch et al that was discussed in the section on ECDSA in
&lt;a href="https://web.archive.org/web/20200803123741/https://joinmarket.me/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/"&gt;this&lt;/a&gt;
earlier blog post (subsection "What about ECDSA?"). I have not studied
this framework in any detail, only cursorily, and would encourage anyone
interested to at least watch the linked video of Fersch's talk on it,
which was quite interesting. With the addition of the assumption "CDH
is easy", Fournier claims that ECDSA can be said to have this
EUF-CMA[VES] security guarantee, which is intended to prove,
basically, that &lt;strong&gt;the leak of the DH key is the only leak of information
and that the scheme is secure against forgery&lt;/strong&gt;. I can't claim to be
able to validate this; I can only say the argument appears plausible.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="cryptography"></category><category term="bitcoin"></category></entry><entry><title>Avoiding Wagnerian Tragedies</title><link href="https://joinmarket.me/blog/blog/avoiding-wagnerian-tragedies/" rel="alternate"></link><published>2019-12-15T00:00:00+01:00</published><updated>2019-12-15T00:00:00+01:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2019-12-15:/blog/blog/avoiding-wagnerian-tragedies/</id><summary type="html">&lt;p&gt;Wagner's attack&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Avoiding Wagnerian tragedies&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;This blog post is all about
&lt;a href="https://people.eecs.berkeley.edu/~daw/papers/genbday.html"&gt;this&lt;/a&gt;
paper by David Wagner from 2002.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;It is a personal investigation; long, mainly because I wanted to answer
a lot of questions for myself about it. If you are similarly motivated
to understand the algorithm, this may provide useful guideposts. But
there are no guarantees of accuracy.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;_________________________________________________________________________&lt;/p&gt;
&lt;p&gt;In the Berlin Lightning Conference, Jonas Nick gave a short talk (slides
&lt;a href="https://nickler.ninja/slides/2019-tlc.pdf"&gt;here&lt;/a&gt;)
that included a topic that had been on my "TODO list" for some
considerable time - the so-called Wagner attack. The talk was concise
and well thought out, and for me it made a lot of sense, but I suspect a
lot of the audience lost the key point, as indeed was evidenced by the
only audience question at the end, which was something along the lines
of "but doesn't the birthday attack mean you can only find a hash
collision in \(\sqrt{N}\) time, where \(N\) is the size of the hash
output?" - the questioner had, quite understandably, misunderstood
exactly what the attack does, and remembered what he (and most people
who take an interest in these things) saw as the key security property
that protects how SHA2 and similar are used in cryptocurrency.&lt;/p&gt;
&lt;p&gt;So .. should you care? If so, why? I think the main value of this
&lt;em&gt;practically&lt;/em&gt;, if, as likely, you're reading this from the perspective
of Bitcoin, is that it matters to various non-vanilla signing protocols:
it can matter to blind signatures, and multisignatures, and very likely
a whole slew of different complex contracts that might be based on such
things. And unfortunately, it is &lt;strong&gt;not intuitive&lt;/strong&gt;, so it would be very
easy to miss it and leave a security hole.&lt;/p&gt;
&lt;p&gt;My goal in this blog post will be to try to provide some intuition as to
what the hell Wagner's attack is, and why it could be dangerous.&lt;/p&gt;
&lt;h2&gt;The Birthday Attack .. or Paradox ... (or just Party?)&lt;/h2&gt;
&lt;p&gt;Just as the famous &lt;a href="https://en.wikipedia.org/wiki/Twin_paradox"&gt;Twin
Paradox&lt;/a&gt;
is not actually a paradox, nor is the perhaps even more famous &lt;a href="https://en.wikipedia.org/wiki/Birthday_problem"&gt;Birthday
Paradox&lt;/a&gt;.
The result shown in both of these thought experiments (and actual
experiments - the former &lt;em&gt;has&lt;/em&gt; actually been done with atomic clocks and
small fractions of \(c\)) is just surprising, that's all. It violates
some simple intuitions we have. Here is it stated simply in words:&lt;/p&gt;
&lt;p&gt;Given a set of 23 people (such as children in a classroom), it is a
&lt;strong&gt;better than 50-50 chance&lt;/strong&gt; that at least some pair of them will share
the exact same birthday.&lt;/p&gt;
&lt;p&gt;The simple argument is: the probability of at least one such pair
existing is \(1 - \) the probability \(p\) of there being &lt;em&gt;no&lt;/em&gt; such
pair, which is the case exactly, and only, when &lt;em&gt;every child has a
different birthday.&lt;/em&gt; Now we can easily see that \(p = 0\) when there
are 366 children (ignore leap years), and \(p=\frac{364}{365}\) when
there are only 2 children. The case for \(N\) children would be \(p =
\frac{364 \times 363 \times \ldots (365-N)}{ 365 \times 365 \times
\ldots 365}\) where here, we're using the fact that probabilities
multiply when we want the AND of different events. This \(1 - p\),
where \(p\) is a function of \(N\), just happens to be \(\simeq
0.5\) when \(N=23\), hence the result.&lt;/p&gt;
&lt;h3&gt;Why intuitions about birthdays are (slightly) wrong.&lt;/h3&gt;
&lt;p&gt;The 23 datapoint does surprise people, usually, but it doesn't shock
them. It just seems low. Why does it seem low? Is it because when we
hear the problem statement, we naturally think in more specific terms:
usually, when I am trying to make a match of two things, I am trying to
make a match from &lt;em&gt;one specific thing&lt;/em&gt; against some other set of
comparable things. In case of birthdays, we might look for someone with
the same birthday as &lt;em&gt;us&lt;/em&gt;, which is a very different problem to finding
&lt;em&gt;any pairwise match&lt;/em&gt;, as here.&lt;/p&gt;
&lt;p&gt;Also, it's probabilistic, and people don't have good intuitions about
probability generally.&lt;/p&gt;
&lt;p&gt;But let's delve a little deeper than that. We're going to need to, to
understand the meat of this blogpost, i.e. Wagner's algorithm.&lt;/p&gt;
&lt;p&gt;To &lt;em&gt;very roughly&lt;/em&gt; quantify why there's a bit more of a chance of success
in getting a match, than you'd expect, imagine a square grid. Every new
child we add to the list adds another row *and* column; because this
is a &lt;em&gt;square&lt;/em&gt;, this is a &lt;strong&gt;quadratic&lt;/strong&gt;function, or effect, or scaling.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://web.archive.org/web/20200428222140im_/https://joinmarket.me/static/media/uploads/.thumbnails/simplesquare5.png/simplesquare5-300x367.png" width="300" height="367" alt="Simple illustration of search space for birthday matches" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(Pictured above: simple example assuming only 3 children. The blue
stars represent possible matches; there are 3 choose 2 for 3 children,
i.e. 3. The lines illustrate that this is the same as 3x3/2 - 3/2. The
bottom left squares are redundant, and those on the diagonal don't
apply.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If the set of children is \(\{L\}\), and we denote the size of the
set (number of elements) as \(|L|\), then we can see that the size
of the &lt;a href="https://en.wikipedia.org/wiki/Cartesian_product"&gt;&lt;strong&gt;Cartesian
product&lt;/strong&gt;&lt;/a&gt;
of the set with itself, is \(|L|^{2}\). Since in the problem
statement - getting a single match - we only need one of the elements of
this set to be a match. But let's qualify/correct a &lt;em&gt;little&lt;/em&gt; bit so our
toy example is a little bit better defined. If Alice matches Carol on
the top row, she'll also match in the first column (A = C means also C =
A). Further the squares on the main diagonal don't count, A=A is not a
solution to the problem. So for a set \(\{L\}\), if we want the
number of chances of a 'hit' to be about the same as the number of
possible values (the 'sample space' - which for birthdays has size 365),
then we have this very rough approximation:&lt;/p&gt;
&lt;p&gt;\(\frac{|L|^{2}}{2} - \frac{|L|}{2} \simeq 365\)&lt;/p&gt;
&lt;p&gt;Notice this is a very artificial equation: there's no guarantee that
anything magical happen exactly when the size of the sample space of
each event (the 365) is equal to the number of 'events' (pairs of
children, in this case, that might have the same birthday). But it does
give us the right order of magnitude of &lt;span
style="text-decoration: underline;"&gt;roughly how many children would be
needed for the probability to get at least one match in the set to be
'appreciable'&lt;/span&gt; . Clearly if \(|L|\) was &lt;em&gt;much&lt;/em&gt; bigger than the
positive solution to the above quadratic equation, the probability is
going to become overwhelming; eventually once it reaches 365 we must
have a solution, by the pigeonhole principle, and the probability will
be very close to 1 way before that. And indeed the positive solution is
\(\simeq 28\), which is around the same as the exact answer 23, if
our exact question is how large the set should be to get a 50%
probability.&lt;/p&gt;
&lt;p&gt;So while as belaboured above, the calculation above is rough and
artificial, it conveys the key scaling information - &lt;strong&gt;the chance of
success scales with the square of the size of the set, because we are
comparing the set with itself&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;The birthday attack on hash functions&lt;/h3&gt;
&lt;p&gt;This line of thinking is commonly applied to the problem of finding
&lt;a href="https://en.wikipedia.org/wiki/Collision_(computer_science)"&gt;collisions in hash
functions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Suppose you had a hash function whose digests were of length 20 bytes
(SHA1 was of this type). This is 160 bits of 'entropy' - if you assume
it's doing a good job of producing unpredictably random output. However,
as a reminder, there is more than one attack against a hash function
that cryptographers worry about - finding a preimage for an output,
finding &lt;em&gt;another&lt;/em&gt; preimage, and the third one relevant to our discussion
- just finding &lt;strong&gt;any&lt;/strong&gt; collision, i.e. finding any two preimages giving
the same output hash. For this, the above "birthday paradox" scenario
applies exactly: we have a sample space of \(2^{160}\) possibilities,
and we're going to select a set \(\{L\}\) from it, with the
intention of finding at least one pair in the set with the same output
value. The mathematics is identical and we need something like
\(|L|^{2}\ \simeq 2^{160}\), or in other words, the size of the
set we'd have to generate to get a good chance of a collision in the
hash function, is \(\sqrt{2^{160}}=2^{80}\). Hence a common, if
approximate, statement, is that &lt;span
style="text-decoration: underline;"&gt;hash functions have security against
collision of only half the bits of the output&lt;/span&gt;. So here, SHA1
could crudely be considered as having 80 bits of security against
collisions ... unfortunately, this statement ignores the fact that
collisions in SHA1 have already been
&lt;a href="https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html"&gt;found&lt;/a&gt;.
This blog post is, however about non-broken cryptographic constructs;
collisions are supposed to not be possible to find other than by brute
force search, so that's a side story here.&lt;/p&gt;
&lt;h2&gt;Wagner's algorithm&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://people.eecs.berkeley.edu/~daw/papers/genbday.html"&gt;Wagner's
paper&lt;/a&gt;,
"A Generalised Birthday Problem", considers the question of what happens
if we don't just want a single match between items in a list like this,
but if we want, instead, &lt;em&gt;a relation between a set of items&lt;/em&gt;. The
relation considered in particular is applying bitwise XOR, hereafter
\(\oplus\), e.g. :&lt;/p&gt;
&lt;p&gt;\(a \oplus b \oplus c \oplus d = 0 \quad (1)\)&lt;/p&gt;
&lt;p&gt;(this equation is only "e.g.", because we are not restricted to 4; any
number more than 2 is considered by the paper, and for a number \(k\)
of items, this is referred to as the &lt;span
style="text-decoration: underline;"&gt;\(k\)-sum problem&lt;/span&gt;, but for
now we'll keep it simple and stick to 4).&lt;/p&gt;
&lt;p&gt;First, let's not forget the obvious: this is a trivial problem if we
just &lt;strong&gt;choose&lt;/strong&gt; \(a, b, c, d\); just choose the first 3 at random and
make the last one fit. What Wagner's algorithm is addressing is the
scenario where the numbers are all drawn from a uniformly random
distribution (this observation also applies to the children's birthdays;
we are not &lt;em&gt;choosing&lt;/em&gt; them but getting random ones), but we can generate
as many such randoms as is appropriate.&lt;/p&gt;
&lt;p&gt;Next observation: this "generalised" problem is intuitively likely to be
easier than the original problem of finding only &lt;em&gt;one&lt;/em&gt; pairwise match -
you can think of the original birthday problem of a match being the same
as: \(a \oplus b = 0\) (this means a perfect match between \(a\)
and \(b\)). There, we could think of ourselves as being constrained in
"roughly" one variable (imagine that \(a\) is fixed and you are
hunting for \(b\), with the caveat of course that it's crucial to the
argument of square-root scaling that that is &lt;em&gt;not&lt;/em&gt; the correct problem
statement!). If we extend to 4 items holding a relation, as above in
\((1)\), then we have "roughly" three degrees of freedom to work with.
It'll always tend to be easier to find solutions to puzzles when you
have more pieces available to play with.&lt;/p&gt;
&lt;p&gt;However, the meat of the paper is to explain just how much this problem
is easier than the original (pairwise) birthday problem to solve, and to
give an explicit algorithm for how to do so. Just like with the number
23, it is a bit surprising how effective this algorithm is.&lt;/p&gt;
&lt;h3&gt;The algorithm&lt;/h3&gt;
&lt;p&gt;To set the stage: suppose we are considering hash functions (so we'll
forget about birthdays now), and the values \(a, b, c, d\) in
\((1)\) are outputs of a hash function. Let's go with SHA256 for now,
so they will all be bit strings of length 256.&lt;/p&gt;
&lt;p&gt;We can generate an arbitrary number of them by just generating random
inputs (one particularly convenient way: start with random \(x\),
calculate \(y = \mathbb{H}(x)\), then calculate \(\mathbb{H}(y)
\ldots \); this 'deterministic random' approach, which should still
give a completely random sequence if the hash function is well behaved,
can be very useful in many search algorithms, see e.g. Chapter 3 and 14
of
&lt;a href="https://www.math.auckland.ac.nz/~sgal018/crypto-book/crypto-book.html"&gt;Galbraith&lt;/a&gt;).
As in earlier sections, we can call this list of such values
\(\{L\}\).&lt;/p&gt;
&lt;p&gt;Wagner's suggested approach is to break the problem up, in two ways:
first, take the list of items in \(L\) and split it into 4 (or
\(k\)) sublists \(L_1 , L_2, L_3, L_4\). Second, we will take 2
lists in pairs and then apply the birthday problem to each of them, but
with a twist: we'll only insist on a &lt;strong&gt;partial match&lt;/strong&gt;, not a full
match.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(Historical note: this idea of using a subset of values satisfying a
simple verifying criteria is also seen in discrete log find algorithms
as well as hash collision finding algorithms, and is often known as
"distinguished points"; the idea seems to go back as far as the early
80s and is due to Rivest according to 14.2.4 of
&lt;a href="https://www.math.auckland.ac.nz/~sgal018/crypto-book/crypto-book.html"&gt;Galbraith&lt;/a&gt;.
(Of note is that it's intriguingly analogous to Back's or Dwork's proof
of work computation idea).)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The following diagram to illustrate the idea is taken directly from the
Wagner paper:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://web.archive.org/web/20200428222140im_/https://joinmarket.me/static/media/uploads/.thumbnails/wagnerpic1.png/wagnerpic1-527x472.png" width="527" height="472" alt="Wagner algorithm schematic from paper" /&gt;&lt;/p&gt;
&lt;p&gt;The \(\bowtie\) symbol may not be familiar: it is here intended to
represent a
&lt;a href="https://www1.udel.edu/evelyn/SQL-Class2/SQLclass2_Join.html"&gt;join&lt;/a&gt;
operation; the non-subscripted variant at the top is what may be called
an 'inner join' (just, find matches between the two sets), whereas
\(\bowtie_{l}\) represents the novel part: here, we search not for
full matches, but only matches in the lowest \(l\) bits of the hash
values, and we store as output the \(\oplus\) of the pair (more on
this in a bit). A concrete example:&lt;/p&gt;
&lt;p&gt;\(L_1 = \{\textrm{0xaabbcc}, \textrm{0x112804}, \textrm{0x1a1dee}
\ldots \}, \quad L_2 = \{\textrm{0x8799cc}, \textrm{0x54ea3a},
\textrm{0x76332f} \ldots \}\)&lt;/p&gt;
&lt;p&gt;Here we're showing toy hash outputs of 3 bytes (instead of 32), written
in hexadecimal for ease of reading. We're going to use list lengths of
\(2^{l}\) (which will be justified later; we could have picked any
length). If \(l\) were 8 (and the lists length 256 therefore), then
we're searching for matches on the lowest 8 bits of the values, and we
have:&lt;/p&gt;
&lt;p&gt;\(L_1 \bowtie_{l} L_2 = \{(\textrm{0xaabbcc} \oplus
\textrm{0x8799cc} = \textrm{0x2d2200}) \ldots \}\)&lt;/p&gt;
&lt;p&gt;... plus any other matches if the lists are longer, so that the output
on doing the low-l-bit-join on these two lists of items, produced at
least this single item, which is the \(\oplus\) of the "partial
match", and perforce it will always have its lowest-\(l\) bits as zero
(because of the properties of \(\oplus\)).&lt;/p&gt;
&lt;p&gt;Having done this first step for \(L_1 , L_2\) we then do exactly the
same for \(L_3 , L_4\) (remember - we took an original large random
list and split it into 4 (equal-sized) sub-lists).&lt;/p&gt;
&lt;p&gt;That leaves us with two lists that'll look something like this:&lt;/p&gt;
&lt;p&gt;\(L_1 \bowtie_{l} L_2 = \{\textrm{0x2d2200}, \textrm{0xab3100},
\textrm{0x50a200}, \ldots\}\)&lt;/p&gt;
&lt;p&gt;... and the same for \(L_3 , L_4\). Wagner's idea is now to &lt;strong&gt;solve
the original birthday problem directly on this pair of lists&lt;/strong&gt; - this is
the simple \(\bowtie\) operator - and he knows it will be easier
precisely because he has reduced the number of bits to be attacked (in
this case, by 8, from 24 to 16). To repeat, this &lt;em&gt;isn't&lt;/em&gt; a way to solve
the original birthday problem (which we restated as \(a \oplus b = 0
\), but it &lt;em&gt;is&lt;/em&gt; a way to solve the generalised problem of \(a \oplus
b \oplus c \oplus d = 0\).&lt;/p&gt;
&lt;p&gt;To give concrete completeness to the above fictitious examples, we can
imagine:&lt;/p&gt;
&lt;p&gt;\(L_3 \bowtie_{l} L_4 = \{\textrm{0x2da900}, \textrm{0x896f00},
\textrm{0x50a200}, \ldots\}\)&lt;/p&gt;
&lt;p&gt;So we've found this one positive result of the join operation (ignoring
others from a longer list): \(\textrm{0x50a200}\). What can we deduce
from that?&lt;/p&gt;
&lt;h3&gt;From partial solutions to an overall solution&lt;/h3&gt;
&lt;p&gt;The reason the above steps make any sense in unison is because of these
key properties of the \(\oplus\) operation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Associativity: \(a \oplus (b \oplus c) = (a \oplus b) \oplus
    c\)&lt;/li&gt;
&lt;li&gt;\(a = b \Rightarrow a \oplus b = 0 \)&lt;/li&gt;
&lt;li&gt;The above two imply: \( a \oplus b = c \oplus d \Rightarrow a
    \oplus b \oplus c \oplus d = 0\)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I hope it's clear that the third of the above is the reason why finding:&lt;/p&gt;
&lt;p&gt;\((L_1 \bowtie_{l} L_2) \bowtie (L_3 \bowtie_{l} L_4)\)&lt;/p&gt;
&lt;p&gt;... means exactly finding sets of 4 values matching \(a \oplus b
\oplus c \oplus d = 0\).&lt;/p&gt;
&lt;h2&gt;Efficiency of the algorithm&lt;/h2&gt;
&lt;p&gt;Here's why the above idea even matters: it means that finding such
multi-value matches can be &lt;strong&gt;much&lt;/strong&gt; faster than finding pairwise
matches. Wagner goes through the reasoning as follows to give an
approximate feel for how much faster:&lt;/p&gt;
&lt;p&gt;First, we can observe that it's likely that the efficiency of following
the above algorithm will depend on the value \(l\). Second, because
it's hard to get it in abstract, let's stick to our concrete toy example
where the hash function has only three bytes in the output (so 24 bits),
and \(l=8\).&lt;/p&gt;
&lt;p&gt;The chance of a match on &lt;em&gt;any one pair&lt;/em&gt; of elements from \(L_1 ,
L_2\) respectively is about \(2^{-l}\) (they have to match in
\(l\) bits and each bit is a coin flip); the number of possible
matches is \~ \(|L_1| \times |L_2|\). But given that we
arbitrarily chose the length of the lists as \(2^{8}\) - then we
expect the number of matches in \(L_1 \bowtie_{l} L_2\) to be
around \((2^{8} \times 2 ^{8} \times 2^{-8}) = 2 ^{8}\). At first it
may sound strange to say we expect so many matches but consider a
smaller example and it's obvious: if there are 10 possible values, and
we have &lt;span style="text-decoration: underline;"&gt;two&lt;/span&gt; lists of 10
items, then there are 100 possible matches and a probability 1/10 for
each one (roughly), so we again expect 10 matches.&lt;/p&gt;
&lt;p&gt;To complete the analysis we only have to judge how many matches there
are likely to be between the output of \((L_1 \bowtie_{l} L_2)\)
and that of \((L_3 \bowtie_{l} L_4)\). As shown in our toy
example, all of those values have their lowest \(l\) bits zero; a full
solution of \(a \oplus b \oplus c \oplus d = 0\) will therefore be
obtained if the remaining bits of the \(\oplus\) of pairs of items
from the two lists are also zero (keep this deduction I just slid in
there, in mind! It will be crucial!); the probability of that for one
pair is clearly \(2^{-(n-l)}\) which in our toy case is
\(2^{-(24-8)}\), and since each of the lists is length
\(2^{l}=2^{8}\), we have finally that the expected number of solutions
from the whole process is around \(|L_{12}| \times |L_{34}|
\times 2^{-(24-8)} = 2^{8 + 8 - (24-8)} = 1\). This was not an
accident; we deliberately chose the lengths of the lists to make it so.
If we call this length \(2^{k}\), and generalise back to \(l\) bits
for the first partial match step, and \(n\) bits for the hash function
output, then we have an expected number of solutions of \(2^{2k}
\times 2^{-(n-l)}\). Clearly we have room for maneuver in what values
we choose here, but if we choose both \(l\) and \(k = f(l)\) so as
to make the expected number of matches around 1, then we can choose
\(k=l\) and \(l = \frac{n}{3}\), as the reader can easily verify.&lt;/p&gt;
&lt;p&gt;Note that that choice \(l=n/3\) and \(k=l\) (or, in words, have the
4 sublists of length \(2^{l}\), and have \(l\) be one third of the
size of the hash output) is not arbitrary, in fact: because we are
trying to optimise our space and time usage. We discuss how this
generalises to more than 4 items in the next section, but for 4, this
means that we need space to store lists of \(\simeq
2^{\frac{n}{3}}\).&lt;/p&gt;
&lt;p&gt;Compare this with the already-explained well-known scaling of the
original birthday problem: the time-space usage is of the order of
\(2^{\frac{n}{2}}\) for the same definition of \(n\). This
difference is big: consider, if a hash function had a 150 bit output
(let's forget that that's not a whole number of bytes!), then the
birthday problem is 'defended' by about 75 bits, whereas the 4-list
"generalised birthday problem" here is defended by only 50 bits (which
isn't a reasonable level of defence, at all, with modern hardware).&lt;/p&gt;
&lt;h3&gt;Bigger \(k\)-sum problems and bigger trees.&lt;/h3&gt;
&lt;p&gt;Clearly while the 4-sum problem illustrated above is already quite
powerful, it will be even more powerful if we can realise instances of
the problem statement with more lists. If we stick with powers of 2 for
simplicity, then, in the case of \(k=256\), we will be able to
construct a larger, complete binary tree with depth 8, combining pairs
of lists just as above and passing to the next level up the tree. At
each step, the number of bits matched increases until we search for full
matches (birthday) right at the top or root of the tree.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;This results in overall a time/space usage for these algorithms of
roughly \(O(2^{\frac{n}{log_{2}k+1}})\). So while for our earlier
\(k=4\) we had \(O(2^{\frac{n}{3}})\), for \(k=256\) we have
\(O(2^{\frac{n}{9}})\), i.e. the attack could be very powerful
indeed!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you're still a bit bewildered as how it might be possible to so
drastically reduce the difficulty of finding matches, just by
constructing a tree, note that it's part of a broader theme in much
mathematics: note what is sometime called the triangle inequality:&lt;/p&gt;
&lt;p&gt;\(|a| + |b| \ge |a+b|\)&lt;/p&gt;
&lt;p&gt;and in cases where a homomorphism applies, i.e. \(f(a+b) = f(a) +
f(b)\), it can sometimes be the case that the ability to shift from one
to the other - from "process each object individually" to "process the
combined object" allows one to collapse down the computational
difficulty of a problem. And that's what's happening here - the fact
that one can process &lt;em&gt;parts&lt;/em&gt; of these objects individually - i.e., find
matches on &lt;em&gt;subsets&lt;/em&gt; of the bits of the random numbers, and then combine
those linearly, gives a better outcome (performance wise) than if one
were to try to find total matches all at once.&lt;/p&gt;
&lt;p&gt;This is just a very vague musing though; feel free to ignore it :)&lt;/p&gt;
&lt;h2&gt;Generalising the algorithm&lt;/h2&gt;
&lt;p&gt;First let's briefly mention the important but fairly simple point: you
can generalise from \(a \oplus b \oplus c \oplus d = 0\) to \(a
\oplus b \oplus c \oplus d = c\) for some non-zero \(c\); just
replace one of the lists, e.g. \(L_4\) with a corresponding list
where all terms are xor-ed with the value \(c\), so that the final
result of xor-ing the 4 terms found by the above algorithm will now be
\(c\) instead of zero.&lt;/p&gt;
&lt;p&gt;Also let's note that we ended up finding solutions only from a small
set: those for which there was a match in the final \(l\) bits of
pairs of elements. This restriction can be changed from a match to an
offset in the bit values, but it's only of minor interest here.&lt;/p&gt;
&lt;p&gt;A far more important question though, which we will expand upon in the
next section: can we generalise from groups with the
\(\oplus\)-operation to groups with addition? Solving, say:&lt;/p&gt;
&lt;p&gt;\(a+b+c+d=0\ \textrm{mod}\ 2^{n}\)&lt;/p&gt;
&lt;p&gt;(it's a little easier mod \(2^{n}\) than for arbitrary sized additive
groups, but that's a detail, explained in the paper).&lt;/p&gt;
&lt;p&gt;The answer is yes, but it's worth taking a moment to consider why:&lt;/p&gt;
&lt;p&gt;We need to slightly alter the algorithm to make it fit the properties of
addition: to replicate the property \(a \oplus b = 0\) we replace
\(b\) with \(-b\), and we do this in both the two "layers" of the
algorithm for the 4 list case (see paper for details). Now what's
crucial is that, in doing this, we preserve the property that &lt;strong&gt;a match
in the lowest \(l\) bits in the first step is retained after
combination in the second step&lt;/strong&gt; (the way Wagner puts it is: "The reason
this works is that \(a \equiv b \ \textrm{mod} 2^{l}\) implies
\((a+c \ \textrm{mod}2^{n}) \equiv (b+c\ \textrm{mod}2^{n})\
(\textrm{mod}2^{l})\): the carry bit propagates in only one
direction."; in other words the match is not 'polluted' by the way in
which addition differs from xor, namely the carry of bits. This the
reader can, and probably should, verify for themselves with toy examples
of numbers written as bitstrings, using e.g. \(l=2, n=4\) or similar).&lt;/p&gt;
&lt;p&gt;Because of the carry of bits (or digits) when we add, this isn't
perfectly obvious, but in the \(\oplus\) case it really is: what
makes the algorithm works is the preservation of a distinguishing
property after multiple applications of the operation, to reduce a large
set into a smaller one.&lt;/p&gt;
&lt;h3&gt;Does it work for all groups?&lt;/h3&gt;
&lt;p&gt;Since the above algorithm seems to be kind of generic, it's natural to
start wondering (and worrying!) that it may apply also to other
apparently hard collision problems. In particular, couldn't you do
something similar with elliptic curve points?&lt;/p&gt;
&lt;p&gt;The main point of this blog post, apart from just trying to explain the
Wagner algorithm, was to answer this question in the negative. As we'll
see shortly, there is a concise academic argument that the answer
&lt;em&gt;should&lt;/em&gt; be no, but I want to give some insight as to &lt;em&gt;why&lt;/em&gt; it's no,
that is, why you cannot use this approach to find sets of scalars which,
when passed through the randomising function of elliptic curve scalar
multiplication to produce points on the curve, result in a sum to a
provided point, and thus solve the ECDLP.&lt;/p&gt;
&lt;h3&gt;Wei Dai's argument&lt;/h3&gt;
&lt;p&gt;Before we begin, an amusing piece of trivia: the long version of
Wagner's paper cites both Wei Dai and Adam Back, in a curious similarity
to ... another well known paper that came out 6 years later :)&lt;/p&gt;
&lt;p&gt;What is cited as coming from private correspondence with Wei Dai is the
following logic, which superficially appears fairly trivial. But it's
nonetheless crucial. It's a &lt;strong&gt;reduction argument&lt;/strong&gt; of the type we
discussed in some considerable detail in the last two blog posts (on
signatures):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the \(k\)-sum problem can be solved on any cyclic group \(G\)
in time \(t\), then the discrete logarithm problem on that group can
also be solved in time \(O(t)\).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The words are carefully chosen here. Note that both \((\mathbb{Z}_n ,
+)\) and \((\mathbb{Z}_n , \times )\) are cyclic groups of order
\(n\). In the former, we have already explained that the \(k\)-sum
problem can be solved efficiently; so this is really only an important
statement about the multiplicative group, not the additive group.&lt;/p&gt;
&lt;p&gt;And that makes sense, because the "discrete logarithm problem" (defined
in the broadest possible way) is only hard in the multiplicative group
(and even then, only if \(n\) has large/very large prime factors, or
ideally just is a prime) and not in the additive group. To illustrate:
take the group \(G = (\mathbb{Z}_{11} , +)\), and define a
'generator' element 3 (any element works as a generator if n is prime);
if I were to ask you for the 'discrete log' of 7 in this group, it would
really mean finding \(x \in G\) such that \(3x = 7\) which is
really just the problem of finding \(x = 7 \times 3^{-1} \
\textrm{mod} 11\), which is a trivial problem (see: the &lt;a href="https://en.m.wikipedia.org/wiki/Extended_Euclidean_algorithm"&gt;Extended
Euclidean
Algorithm&lt;/a&gt;),
even if you replace 11 with a very large prime. It's for this reason
that it would be a terribly naive error to try to do cryptography on an
additive group of integers; basically, division, being the additive
analog of logarithms for multiplication, is trivially easy.&lt;/p&gt;
&lt;p&gt;But Wei Dai's argument goes a bit further than that concrete reasoning,
because he's saying the "if-then" (which can also be reversed, by the
way - see the paper, "Theorem 3") can be applied to any, arbitrary
groups - and that includes elliptic curve groups. If the DLP is hard in
that group, the \(k\)-sum problem can't be solved easily, and vice
versa. The argument is something like (we use \(\cdot\) specifically
to indicate &lt;em&gt;any&lt;/em&gt; group operation):&lt;/p&gt;
&lt;p&gt;If you can find a solution to:&lt;/p&gt;
&lt;p&gt;\(x_1 \cdot x_2 \cdot \ldots x_k = y\)&lt;/p&gt;
&lt;p&gt;..using an efficient \(k\)-sum problem algorithm applied to uniformly
randomly generated \(x_i\)s, and if the group's generator is written
as \(g\), and the dlog of \(y\) in this group is \(\theta\), i.e.
\(y=g^{\theta}\), then you can use that solution to find
\(\theta\):&lt;/p&gt;
&lt;p&gt;\(w_1 + w_2 + \ldots w_k = \theta\)&lt;/p&gt;
&lt;p&gt;Thus, we have, essentially, a &lt;span
style="text-decoration: underline;"&gt;reduction of the discrete logarithm
problem to the k-sum problem&lt;/span&gt;.&lt;/p&gt;
&lt;h3&gt;But why doesn't the algorithm work for DLP hard groups?&lt;/h3&gt;
&lt;p&gt;We've already seen the key point in "Generalising the algorithm" above,
so if you skipped the last part of that section, do read it!&lt;/p&gt;
&lt;p&gt;To reiterate, notice that the main description of solving this problem
with groups using \(\oplus\) or just addition required finding
partial matches and then preserving the features of partial matches
through repeated operations. It's precisely this that does not work in a
multiplicative group.&lt;/p&gt;
&lt;p&gt;Here's a concrete example of doing that, with an additive group of the
simplest type, where we are working modulo a power of 2, let's say
\(n=4\) and \(l=2\) so we are examining the lowest 2 bits, in
numbers of 4 bits (i.e. modulo 16):&lt;/p&gt;
&lt;p&gt;Take \(a=17, \ b=41\) which are both 1 mod 4. Now we apply an offset
value \(c=9\) (can be anything). We find:&lt;/p&gt;
&lt;p&gt;\((a+c)_{16} = 26_{16}=10,\quad (b+c)_{16}=50_{16} = 2\)&lt;/p&gt;
&lt;p&gt;and both the answers (10 and 2) are 2 mod 4, which verifies the point:
equality in the lowest order bits can be preserved when adding members.
This is what allows Wagner's trick to work.&lt;/p&gt;
&lt;p&gt;If we talk about multiplication, though, particularly in a group of
prime order, we find we don't get these properties preserved; in such a
group, multiplication has a strong &lt;strong&gt;scrambling effect&lt;/strong&gt;. We'll take one
concrete example: \((\mathbb{Z}_{29}, \times)\). If I start with
any number and just keep multiplying by itself (this is basically how
'generators' work), we get this sequence:&lt;/p&gt;
&lt;p&gt;\(3,9,27,23,11,4,12,7,21,5,15,16,19,28,26,20,2,6,18,25,17,22,8,24,14,13,10,1,3,\ldots
\)&lt;/p&gt;
&lt;p&gt;(e.g. 4th element is 23 is because 27 times 3 mod 29 = 23).&lt;/p&gt;
&lt;p&gt;The pattern repeats after 29 steps as expected; but within the sequence
we have an entirely random ordering. This is a direct consequence of the
fact that the number 3 and 29 have no common factors, there's nowhere
they can "line up".&lt;/p&gt;
&lt;p&gt;To illustrate further, consider what happens with addition instead:
still working modulo 29, let's see what happens if we add a number to
itself repeatedly (note I chose 25 to be a slightly less obvious case -
but it's still obvious enough!):&lt;/p&gt;
&lt;p&gt;\(25,21,17,13,9,5,1,26,22,18,14,10,6,2,27,23,19,15,11,7,3,28,24,20,16,12,8,4,0,
\ldots \)&lt;/p&gt;
&lt;p&gt;Note that you're seeing it dropping by 4 each time because \(25 \equiv
-4\) in mod 29. There is always such a simple pattern in these
sequences in additive groups, and that's why division is trivial while
discrete logarithm is not.&lt;/p&gt;
&lt;p&gt;So, as a consequence of this scrambling effect, we also find that
Wagner's observation about adding integers and then taking modulo
\(l\) no longer works, in multiplicative groups, at least in general.
Again, a concrete example using \((\mathbb{Z}_{29}, \times)\):&lt;/p&gt;
&lt;p&gt;Let \(a=17,\ b=13\); both integers modulo 29. We'll, as before, check
the value modulo 4, both before and after adding an offset: they are
both 1 modulo 4. Let the offset we're going to apply to both, be 9. But
this time we're not going to &lt;em&gt;add&lt;/em&gt; 9 but multiply it, because that is
the group operation now; we get:&lt;/p&gt;
&lt;p&gt;\((17\times 9)_{29} = 153_{29} = 8_{29} \quad \rightarrow 0_{4}
\)&lt;/p&gt;
&lt;p&gt;but:&lt;/p&gt;
&lt;p&gt;\((13\times 9)_{29} = 117_{29} = 1_{29} \quad \rightarrow 1_{4}
\)&lt;/p&gt;
&lt;p&gt;and, so unlike in the additive group case, we failed (at least for this
example, and this group - I haven't &lt;span
style="text-decoration: underline;"&gt;proved&lt;/span&gt; anything!) to preserve
the two low order bits (or the value mod 4, equivalently).&lt;/p&gt;
&lt;p&gt;In summary, as far as the current state of mathematics goes, it is
believed that there is not a way to do such a property preservation
"through" multiplication - but specifically this statement only applies
in groups where the discrete log is &lt;em&gt;actually&lt;/em&gt; hard.&lt;/p&gt;
&lt;p&gt;All of the above cross-applies to elliptic curves: like in
multiplicative groups (certain of them), the DLP is hard because the
group operator is essentially a 'scrambler', so the preservation of
properties, that Wagner requires, doesn't work.&lt;/p&gt;
&lt;h2&gt;Applications to real systems&lt;/h2&gt;
&lt;h3&gt;The OR of sigma protocols.&lt;/h3&gt;
&lt;p&gt;This is a topic that was covered in an earlier &lt;a href="https://joinmarket.me/blog/blog/ring-signatures/"&gt;blog
post&lt;/a&gt;,
so I will not give the outline here - but you'll need that context to
understand the following. But we see here a fascinating implication of
Wagner's idea to these protocols. Recall that the verification uses the
following equation:&lt;/p&gt;
&lt;p&gt;\(e_1 \oplus e_2 \ldots \oplus e_k = e\)&lt;/p&gt;
&lt;p&gt;... look familiar at all? This of course is &lt;em&gt;exactly&lt;/em&gt; the \(k\)-sum
problem that Wagner attacks! Therefore a dishonest prover has a much
better chance of fooling a verifier (by providing a valid set of
\(e_i\)-s) than one might expect naively if one hadn't thought about
this algorithm. Fortunately, there is a huge caveat: &lt;strong&gt;this attack
cannot be carried out if the protocol has special soundness&lt;/strong&gt;. Special
soundness is a technical term meaning that if an extractor can generate
two validating transcripts, it can extract the witness. In this case,
the Wagner algorithm could not be performed &lt;em&gt;without already knowing the
secret/witness&lt;/em&gt;(details: the attack would be to generate huge lists of
transcripts \(R, e, s\) (notation as per previous blogs), where \(e,
s\) are varied, keeping \(R\) fixed - but that's exactly how an
extractor works) - so in that sense it wouldn't be an attack at all.
However, not all zero knowledge protocols do have the special soundness
property. So while this is very in the weeds and I am not able to
illustrate further, it is certainly an interesting observation, and the
discussion in the full version of the Wagner paper is worth a read.&lt;/p&gt;
&lt;h3&gt;Musig&lt;/h3&gt;
&lt;p&gt;Obviously Wagner did not discuss this one :) This will be a very high
level summary of the issue in the context of
&lt;a href="https://eprint.iacr.org/2018/068"&gt;Musig&lt;/a&gt;,
the newly proposed scheme for constructing multisignatures via
aggregated Schnorr signatures. Read the Musig paper for more detail.&lt;/p&gt;
&lt;p&gt;Recall that the naive aggregation of Schnorr signatures is insecure in
the multisig context due to what can be loosely called "related key
attacks" or "key subtraction attacks":&lt;/p&gt;
&lt;p&gt;\(P_1 = x_1 G\quad P_2 =x_2G\)&lt;/p&gt;
&lt;p&gt;\(s_1 = k_1 + ex_1\ ,\ s_2 = k_2 + ex_2\quad
s_{\textrm{agg}} = k_1 + k_2 + e(x_1+x_2)\)&lt;/p&gt;
&lt;p&gt;fails in the multisig context of user-generated keys due to attacker
choosing:&lt;/p&gt;
&lt;p&gt;\(P_2 = P^{*}_2 - P_1\quad P^{*}_2 = x^{*}_2 G\)&lt;/p&gt;
&lt;p&gt;and then the attacker is able to construct a valid signature without
knowledge of \(x_1\).&lt;/p&gt;
&lt;p&gt;The paper explains that a naive fix for this problem &lt;span
style="text-decoration: underline;"&gt;is actually susceptible to Wagner's
attack!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;If you write each key as \(P^{*}_{i} = \mathbb{H}(P_i)P_i\), in
words, you (scalar) multiply each key by its hash, then you still know
the private key (just also multiply it by the same hash value), and you
might think you have removed the key subtraction attack, because an
attacker wants to create \(P_2\) such that it's the difference
between a key he knows and \(P_1\); but he can't know the hash value
before he computes it, so he will never be able to arrange for
\(\mathbb{H}(P_2)P_2\) to be a non-random value. This same logic is
seen in many places, e.g. in the fixing of public keys inside a basic
Schnorr signature challenge. But here, it's not enough, because there
are more degrees of freedom:&lt;/p&gt;
&lt;p&gt;Suppose the attacker is all \(n-1\) keys \(P_i\) except for the
first, \(P_1\), which the honest victim provides. Then the attacker's
goal is to make signing work without the honest victim's participation.
Now the aggregate key in this naive form of Musig is:&lt;/p&gt;
&lt;p&gt;\(P_{agg} = \sum\limits_{i=1}^{n} \mathbb{H}(P_i)P_i\)&lt;/p&gt;
&lt;p&gt;So the attacker's goal is to find all the other keys as offsets to the
first key such that the first key is removed from the equation. He sets:&lt;/p&gt;
&lt;p&gt;\(P_i = P_1 + y_iG \quad \forall i \in 2\ldots n\)&lt;/p&gt;
&lt;p&gt;i.e the \(y_i\) values are just linear tweaks. Then let's see what
the aggregated key looks like in this naive version of Musig:&lt;/p&gt;
&lt;p&gt;\(P_{agg} = \mathbb{H}(P_1)P_1 + \sum\limits_{i=2}^{n}
\mathbb{H}(P_1 + y_i G)(P_1 + y_i G) \)&lt;/p&gt;
&lt;p&gt;\(P_{agg} = \mathbb{H}(P_1)P_1 + \sum\limits_{i=2}^{n}
\mathbb{H}(P_1 + y_i G)(P_1) + \sum\limits_{i=2}^{n}
\mathbb{H}(P_1 + y_i G)(y_i G)\)&lt;/p&gt;
&lt;p&gt;Now, note that there are three terms and &lt;strong&gt;the last term is an
aggregated key which the attacker controls entirely&lt;/strong&gt;. Consequently, if
the attacker can arrange for the first and second terms to cancel out,
he will succeed in signing without the victim's assent. Luckily that's
exactly an instance of Wagner's \(k\)-sum problem!:&lt;/p&gt;
&lt;p&gt;\(\sum\limits_{i=2}^{n} \mathbb{H}(P_1 + y_i G) =
-\mathbb{H}(P_1) \)&lt;/p&gt;
&lt;p&gt;Notice crucially that we've reduced this to an equation in &lt;strong&gt;integers&lt;/strong&gt;
not elliptic curve points, as per the long discussions above about Wei
Dai's observation. This will be soluble, and it will be more soluble
(and more soluble than expected!) for arbitrarily chosen \(y_i\)-s,
as the value of \(n\) increases. The attack requires the attacker to
control some subset of keys (in this simple illustration, \(n-1\)
keys, but it can actually be fewer), but since the whole point is to
remove trust of other key-owners, this is certainly enough to reject
this construction.&lt;/p&gt;
&lt;p&gt;The solution is nearly obvious, if unfortunately it makes the equation a
little more complicated: &lt;strong&gt;fix the entire keyset, not just your own key,
in the hash&lt;/strong&gt; (notice an echo here to the discussion of ring signatures
in an earlier blog post). By doing so, you cannot separate out the
dependence in \(P_1\) and thus cancel it out. So replace
\(\mathbb{H}(P_1)P_1\) with \(\mathbb{H}(P_1, P_2, \ldots ,
P_n)P_1\). The authors of the musig construct tend to use the term
'delinearization' specifically to describe this.&lt;/p&gt;
&lt;h3&gt;Other examples&lt;/h3&gt;
&lt;p&gt;In fact, probably the most striking example of how Wagner's attack may
have implications for the security of real systems, is the attack he
describes against Schnorr blind signatures. But it is unfortunately also
the most complicated, so I will just briefly mention here that he shows
that a certain kind of such blind signatures can be forged given a
number \(k\) of parallel interactions with a signing oracle (which is
often a realised thing in systems that actually use blind signatures;
they are often used as kind of tokens/certificates), using the
corresponding \(k\)-sum problem.&lt;/p&gt;
&lt;p&gt;He shows that certain specialised hash constructions (which may well be
outdated now, nearly 20 years later) have weaknesses exposed by this
kind of attack.&lt;/p&gt;
&lt;p&gt;Curiously, he discusses the case of KCDSA, a Korean variant of DSA,
pointing out that it's possible to collide signatures (specifically the
\(s\) in an \(r, s\) pair), in the sense of having two different
messages with the same signature. A similar concept w.r.t. ECDSA can be
found in &lt;a href="https://link.springer.com/content/pdf/10.1007%2F3-540-45708-9_7.pdf"&gt;this
paper&lt;/a&gt;
- there it exploits a simple symmetry of the algorithm, but requires
that the public/private key pair be created as part of the 'stunt'.
Wagner on the other hand shows his algorithm can be used to find
"collisions" of this type in the KCDSA algorithm, but without the
restriction of having to create a key pair specially for the purpose
(i.e. it works for an existing key).&lt;/p&gt;
&lt;p&gt;Several other possible applications are listed in the long version of
the paper.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="cryptography"></category></entry><entry><title>Multiparty S6</title><link href="https://joinmarket.me/blog/blog/multiparty-s6/" rel="alternate"></link><published>2019-04-15T00:00:00+02:00</published><updated>2019-04-15T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2019-04-15:/blog/blog/multiparty-s6/</id><summary type="html">&lt;p&gt;multiparty symmetrical Schnorr signature scriptless script shuffle&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Multiparty S6&lt;/h3&gt;
&lt;h2&gt;The multiparty symmetrical Schnorr signature scriptless script shuffle&lt;/h2&gt;
&lt;p&gt;This blog is in the category of "a new-ish idea about privacy tech";
like similar previous ones (e.g.:
&lt;a href="https://web.archive.org/web/20200429002041/https://joinmarket.me/blog/blog/coinjoinxt/"&gt;CoinJoinXT&lt;/a&gt;)
it is little more than an idea, in this case I believe it is correct,
but (a) I could be wrong and there could be a flaw in the thinking and
(b) it's not entirely clear how practically realistic it will be. What I
do hope, however, is that the kernel of this idea is useful, perhaps in
Layer 2 tech or in something I haven't even thought about.&lt;/p&gt;
&lt;h2&gt;The Goal&lt;/h2&gt;
&lt;p&gt;As with similar writeups, I feel it's important that the reader has some
idea what the goal is. Here is the goal I &lt;em&gt;mostly&lt;/em&gt; had in mind when
thinking this through:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;11 (or 6, or 24...) anonymous users coordinate (on a lobby server,
    with a Joinmarket-style incentive, on a p2p network somehow -
    whatever). They each have 1 BTC utxos (put off denomination
    questions for later) and they want a very meaningful privacy
    increase.&lt;/li&gt;
&lt;li&gt;Instead of doing a CoinJoin which is obvious or a whole set of
    CoinSwaps (see
    &lt;a href="https://web.archive.org/web/20200429002041/https://joinmarket.me/blog/blog/coinswaps/"&gt;earlier&lt;/a&gt;
    &lt;a href="https://web.archive.org/web/20200429002041/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;posts&lt;/a&gt;)
    which could get complicated for 11 people, they want to kind of
    "permute" or "shuffle" all their utxos.&lt;/li&gt;
&lt;li&gt;It's a year or two from now and a Schnorr soft fork has gone through
    in Bitcoin mainchain; they're going to use the scriptless script
    primitive (see
    &lt;a href="https://web.archive.org/web/20200429002041/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;here&lt;/a&gt;
    or Poelstra and Nick's writeup
    &lt;a href="https://github.com/apoelstra/scriptless-scripts/blob/master/md/atomic-swap.md"&gt;here&lt;/a&gt;,
    or the following sections for more on this), to achieve the goal via
    multisig outputs that look like other outputs.&lt;/li&gt;
&lt;li&gt;They do effectively a "multiparty swap" or "shuffle" to achieve this
    goal. Each of the 11 participants funds a single prepared
    destination address, which is (though not seen because Schnorr) an
    11 of 11 multisig. Before they do so, they get hold of a presigned
    (by everyone) backout transaction to get their coins back if
    something goes wrong.&lt;/li&gt;
&lt;li&gt;They decide a shuffle/permutation: e.g. Alice is paying Bob 1,
    Charlie is paying Edward etc etc. ... we're talking here about a
    member of the set of permutations of 11 objects. Obviously the idea
    is that everyone pays in 1, everyone gets back 1. They prepare
    transactions for these payments.&lt;/li&gt;
&lt;li&gt;Once everything is set up they pass around &lt;strong&gt;adaptor signatures&lt;/strong&gt;
    which create the atomicity effect we want - when any 1 of the 11
    transactions goes through, all of them will go through.&lt;/li&gt;
&lt;li&gt;In a certain order, that we'll discuss, they can now pass real
    (Schnorr) signatures (note that even though "real" they are still
    "partial" signatures - they're 1 of 11 needed in the multisig) on
    the transactions such that one member of the group has a full set
    and can broadcast the transaction paying themselves. Everyone else
    sees this on the blockchain, and combining the signatures in this
    published transaction, with the earlier adaptor signatures, has
    enough information to broadcast the other transaction which pays
    themself.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's consider the advantages of doing this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shared with a 2 of 2 CoinSwap: there is no linkage on the blockchain
    between the 11 transactions. Effectively, Alice has swapped her coin
    history with Bob, Charlie with Edward etc..&lt;/li&gt;
&lt;li&gt;Big difference from the above: we can create, like a multiparty
    coinjoin, the highly desirable scenario that &lt;span
    style="text-decoration: underline;"&gt;individual participants do not
    know the linkages&lt;/span&gt; between inputs for transactions other than
    their own. As we know, there are various designs of CoinJoin
    metaprotocols that allow this to different extents, but if CoinSwap
    is restricted to 2 of 2 this is impossible (no cryptographic
    trickery prevents the deduction "if it's not mine, it's yours!").&lt;/li&gt;
&lt;li&gt;Biggest difference from CoinJoin is that CoinSwap transactions
    (whether 2-2 or 11-11) can look like ordinary payments on the
    blockchain, although there's meaningful wiggle room in how exactly
    they will look. If we manage to combine this with even slight
    variations in size of individual payments, and probably a little
    timing de-correlation too, the task of a blockchain analyst in
    identifying these is near impossible (&lt;strong&gt;notice that this hugely
    desirable steganographic feature is shared with PayJoin and
    CoinJoinXT, previous blog posts&lt;/strong&gt; - notice though, that it depends
    on Schnorr for indistinguishable multisig &lt;em&gt;and&lt;/em&gt; for adaptor
    signatures, unless ECDSA-n-party computation is a thing, which I
    doubt is currently a thing for more than 2 parties, but see e.g.
    &lt;a href="https://eprint.iacr.org/2018/987.pdf"&gt;this&lt;/a&gt;
    for recent research in this area.).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Illustrations comparing CoinJoin, CoinSwap and multiparty S6:&lt;/h3&gt;
&lt;p&gt;&lt;img src="../../../images/screenshot_from_2019-01-18_15-00-33-813x436.png" width="813" height="436" alt="Typical coinjoin" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Typical CoinJoin transaction - it's very obvious because of equal
output amounts; the histories of coins are not disconnected, but fused&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src="../../../images/realcoinswap2-792x65.png" width="792" height="65" /&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src="../../../images/realcoinswap1-799x67.png" width="799" height="67" /&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Typical 2-party CoinSwap transactions; they are entirely separate on
the blockchain, with different timestamps they could be extremely
difficult to find.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;*&lt;img src="../../../images/s6basic-1053x745.png" width="1053" height="745" /&gt;
*&lt;/p&gt;
&lt;p&gt;&lt;em&gt;A &lt;/em&gt;&lt;em&gt;very&lt;/em&gt;&lt;em&gt; simplified multiparty S6 as envisaged: note that Oscar to
Peter shows on a diagonal a simple transaction of the type used in
CoinSwap; in fact there is one such transaction for every red arrow;
i.e. each red arrow represents a payment from one of the group of 11 to
another, in a random permutation. All of these transactions will be
atomic; either they will all happen or none will. But none will be
linked on the blockchain.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Schnorr and adaptor signatures&lt;/h2&gt;
&lt;p&gt;Achieving the goals above is crucially dependent on the concept of an
adaptor signature as developed by Andrew Poelstra (see some detailed
descriptions as mentioned
&lt;a href="https://github.com/apoelstra/scriptless-scripts/blob/master/md/atomic-swap.md"&gt;here&lt;/a&gt;)
in his work on "scriptless scripts". A large part of the &lt;a href="https://web.archive.org/web/20200429002041/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;earlier blog
post&lt;/a&gt;
on the topic of the scriptless script based swap, was explaining this
concept. I want to write an explanation which is easier to understand. I
will try :)&lt;/p&gt;
&lt;p&gt;A basic Schnorr signature on a message \(m\) using a public key
\(P\) whose private key is \(x\), looks like this:&lt;/p&gt;
&lt;p&gt;\(\sigma = k + \mathbb{H}(P||R||m) x \quad, R = kG \quad
\textrm{Publish: }\ (R,\sigma)\)&lt;/p&gt;
&lt;p&gt;\(k\) is called the nonce, and \(R\) is the nonce point (point on
the curve corresponding). We shorten the hash function
\(\mathbb{H}(\ldots)\) to just \(e\), often.&lt;/p&gt;
&lt;p&gt;Schnorr signatures are linear in the keys, in that:&lt;/p&gt;
&lt;p&gt;\(\sigma_1 + \sigma_2 = (k_1 + k_2) + e (x_1+x_2)\)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Combining signatures in this way is unsafe in many contexts, in
particular multisignature in Bitcoin. See the &lt;a href="https://eprint.iacr.org/2018/068"&gt;paper on
Musig&lt;/a&gt;
and &lt;a href="https://github.com/ElementsProject/secp256k1-zkp/blob/secp256k1-zkp/src/modules/musig/musig.md"&gt;this
summary&lt;/a&gt;
for the details on how the weakness (basically, potential of key
subtraction) is addressed in detail, using interactivity between the
parties cooperating to create the agreggated Schnorr signature. &lt;span
style="text-decoration: underline;"&gt;As long as this is properly
addressed, though, the linearity property is retained&lt;/span&gt;.
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Let me emphasise that the rest of this post will ignore the correct
construction of keys and nonce points for safe Schnorr multisig; we will
just talk about Alice, Bob and Charlie adding keys together and adding
signatures together; the difference is crucial in practice but I believe
does not alter any of the concepts being outlined.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Partial Signatures&lt;/h3&gt;
&lt;p&gt;With the above bolded caveats in mind, it'll be important for the
following to understand the idea of a "partial signature" in a Schnorr
multisig context. What we're doing is to create a single signature
\(\sigma\) which represents, say, a 2 of 2 multisignature. Say it's
Alice and Bob (A, B). Then Alice would produce this &lt;strong&gt;partial
signature&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;\(\sigma_A = k_A + \mathbb{H}(P_A + P_B || R_A + R_B || m)
x_A\)&lt;/p&gt;
&lt;p&gt;Notice how it's not a valid signature according to the Schnorr
definition because the nonce \(k_A\) does not correspond to the nonce
point \(R_A + R_B\) &lt;em&gt;and&lt;/em&gt; because the private key does not
correspond to the public key \(P_A+P_B\).&lt;/p&gt;
&lt;p&gt;However when Bob adds his partial signature:&lt;/p&gt;
&lt;p&gt;\(\sigma_B = k_B + \mathbb{H}(P_A + P_B || R_A + R_B || m)
x_B\)&lt;/p&gt;
&lt;p&gt;... to Alice's, the sum of the two &lt;em&gt;is&lt;/em&gt; a valid signature on the
message, with the sum of the keys.&lt;/p&gt;
&lt;p&gt;We will make use of this shortly.&lt;/p&gt;
&lt;h3&gt;Adaptor Signatures&lt;/h3&gt;
&lt;p&gt;A creator of a signature can hide a verifiable secret value in a
signature, using simple addition. They can then pass across the
signature &lt;em&gt;without&lt;/em&gt; the secret value, making it not valid, but
verifiable as "a signature with the secret not included". This is what
Poelstra means by his concept "adaptor signature". It looks like this:&lt;/p&gt;
&lt;p&gt;\(\sigma' = k + \mathbb{H}(P||R+T||m) x \quad R=kG,\ T=tG \)&lt;/p&gt;
&lt;p&gt;(from now on, note that ' indicates adaptor signatures). To repeat, it's
not a valid signature, but: &lt;em&gt;it can be verified that adding the discrete
log of \(T\)&lt;/em&gt; &lt;em&gt;to \(\sigma'\) will yield a valid signature on the
message m and the public key \(P\)&lt;/em&gt;&lt;strong&gt;&lt;em&gt;.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Refer back to the &lt;a href="https://web.archive.org/web/20200429002041/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;earlier blog
post&lt;/a&gt;
if you want to check the mathematical details on that.&lt;/p&gt;
&lt;p&gt;The alert reader will notice how similar the "adaptor signature" and
"partial signature" concepts are - it's almost the same mathematical
change, but with a very different purpose/application, as we expand on
below:&lt;/p&gt;
&lt;h3&gt;Atomicity for two parties&lt;/h3&gt;
&lt;p&gt;This trick is already cool - if I ever pass you the secret value
\(t\), you'll be able to form a full valid signature. But with an
additional nuance it's possible to make this a two-way promise, so we
have the outline of an atomicity property, which can be very powerful.
If the contents of the thing being signed, including the nonce points
\(R\) and the public keys \(P\) are fixed in advance, we could
create a situation where the promise works both ways:&lt;/p&gt;
&lt;p&gt;\(P, R, m\) are known \(\therefore \sigma = k + t +
\mathbb{H}(P||R+T||m) x\) is fixed. If the adaptor is shared by
the owner of the private key \(x\), i.e. if he passes to a
counterparty the value \(\sigma' = k + \mathbb{H}(P||R+T||m)
x\), then either direction of publication reveals the other:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the full signature \(\sigma\) is revealed, the secret is
    revealed as \(t = \sigma - \sigma'\)&lt;/li&gt;
&lt;li&gt;If the secret \(t\) is revealed, the full signature is revealed:
    \(\sigma = t + \sigma'\)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This atomicity is the basic of the scriptless script atomic swap
published by Poelstra and explained in my earlier post.&lt;/p&gt;
&lt;h3&gt;Atomicity for N parties&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;This is the novel idea in this post.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Suppose we have fixed \(\Sigma P\), \(\Sigma R\) and a single
message \(m\). In other words several participants signing together
the same message (Bitcoin transaction).This is the scenario for Schnorr
aggregated multisig, modulo the complexity of Musig which as explained
above I'm deliberately ignoring. Without adaptors, each party will have
to produce a &lt;strong&gt;partial signature &lt;/strong&gt; as already described, and then they
can all be added together to create a fully valid Schnorr signature.&lt;/p&gt;
&lt;p&gt;Now suppose each of 3 parties (Alice, Bob, Charlie) makes an adaptor
signature for their partial signature:&lt;/p&gt;
&lt;p&gt;\(\sigma_A' = k_A + \mathbb{H}(\Sigma P || \Sigma R + \Sigma T
|| m) x_A\)&lt;/p&gt;
&lt;p&gt;Little explanatory note on this: each party will have to share their
public \(T\) values (which, remember are curve points corresponding to
the &lt;em&gt;adaptor secrets&lt;/em&gt; \(t\)), so they will all know how to correctly
calculate the hash preimage by "combining" (here just adding, but with
musig it's more complicated) their public keys, and then linearly adding
in all their \(T\) public values to the corresponding \(R\) nonce
points as for a normal Schnorr signature.&lt;/p&gt;
&lt;p&gt;Similarly for Bob, Charlie:&lt;/p&gt;
&lt;p&gt;\(\sigma_B' = k_B + \mathbb{H}(\Sigma P || \Sigma R + \Sigma T
|| m) x_B\)&lt;/p&gt;
&lt;p&gt;\(\sigma_C' = k_C + \mathbb{H}(\Sigma P || \Sigma R + \Sigma T
|| m) x_C\)&lt;/p&gt;
&lt;p&gt;These can then be shared (all with all) and are verifiable in the same
way as previously, e.g.:&lt;/p&gt;
&lt;p&gt;\(\sigma_A' G \stackrel{?}{=} R_A + \mathbb{H}(\Sigma P ||
\Sigma R + \Sigma T ||m) P_A \)&lt;/p&gt;
&lt;p&gt;But, it seems to get a bit confusing when you ask what happens if one
party reveals either a full \(\sigma\) value, or a secret \(t\).&lt;/p&gt;
&lt;p&gt;For example, what if Alice reveals her full partial signature (yes I
meant that!) \(\sigma_A =k_A + t_A + \mathbb{H}(...) x_A\)?&lt;/p&gt;
&lt;p&gt;One partial signature on its own is not enough for Bob or Charlie to do
anything. If Alice &lt;em&gt;and&lt;/em&gt; Bob do this, and pass these partials to
Charlie, then he can complete and publish. But we want atomicity. What
we want is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the complete transaction signature is ever published, all parties
    can learn the adaptor secrets \(t\).&lt;/li&gt;
&lt;li&gt;If any or all parties learn the adaptor secrets \(t\) they can
    publish the complete transaction.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It's clear why that's the desire: that would mean you could make
multiple different transactions, sharing the same set of adaptor
secrets, and have it so that &lt;span
style="text-decoration: underline;"&gt;if one transaction gets published
all the others do!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;But wait!&lt;/strong&gt; Something was horribly obfuscated in those bullet points.
"learn the adaptor secrets"? All of them, or which ones?&lt;strong&gt;&lt;span
style="text-decoration: underline;"&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;That this is crucial is easily seen by considering the following
"attack":&lt;/p&gt;
&lt;p&gt;Suppose Alice, Bob, Charlie make three transactions, each of which pays
out of a 3-of-3 Schnorr multisig, between them. The idea would be (as
you've probably gathered from the build-up) that if any 1 transaction,
say the first one paying Bob, gets broadcast, then both Alice and
Charlie could broadcast the other 2 transactions, paying each of them,
because they "learnt the adaptor secrets". But: if say Alice kicks off,
reveals her adaptor secret \(t_A\), then couldn't Bob and Charlie
collude? They could take the partial signature of Alice:&lt;/p&gt;
&lt;p&gt;\(\sigma_A = k_A + t_A + \mathbb{H}(\ldots)x_A\)&lt;/p&gt;
&lt;p&gt;and then between themselves share and construct their "joint" partial
signature:&lt;/p&gt;
&lt;p&gt;\(\sigma_{BC} = k_B + k_C + t_B + t_C
+\mathbb{H}(\ldots)(x_B+x_C)\)&lt;/p&gt;
&lt;p&gt;then add this to \(\sigma_A\). They could do this for the two
transactions paying &lt;em&gt;them&lt;/em&gt; and publish them to the blockchain. It may
seem at first glance that this is a problem, because in doing so they
haven't revealed their &lt;em&gt;individual&lt;/em&gt; adaptor secrets \(t_B, t_C\) but
have instead revealed their sum \(t_B+t_C\).&lt;/p&gt;
&lt;p&gt;However this is not a problem! One way of looking at it is &lt;strong&gt;adaptor
signatures are just as linear as proper Schnorr signatures&lt;/strong&gt;. They are
thus aggregatable. From Alice's point of view, although she is taking
part in a 3-of-3 Schnorr multisig, she may just as well be participating
in a 2-of-2 with a single party, if Bob and Charlie choose to collude
and combine in that way. What will Alice see on the blockchain?&lt;/p&gt;
&lt;p&gt;\(\sigma = k_A + k_B + k_C + t_A + t_B + t_C +
\mathbb{H}(\ldots)(x_A+x_B+x_C)\)&lt;/p&gt;
&lt;p&gt;But she already got adaptor signatures from Bob and Charlie, so she can
remove them:&lt;/p&gt;
&lt;p&gt;\(\sigma - \sigma_A - \sigma_B' - \sigma_C' = t_B + t_C\).&lt;/p&gt;
&lt;p&gt;Now possessing the value of the &lt;em&gt;sum&lt;/em&gt; \(t_B+t_C\), she can add this
to pre-existing adaptor signatures for the transaction paying &lt;em&gt;her&lt;/em&gt; and
get the complete multisignature on those!&lt;/p&gt;
&lt;p&gt;Unfairly linear signatures for the win!&lt;/p&gt;
&lt;h2&gt;Protocol Outline&lt;/h2&gt;
&lt;p&gt;We've now covered the meat of the concepts; so this instantiation phase
will either be easy to follow, or, if you found the above slightly
opaque, will hopefully make it clearer by being more concrete.&lt;/p&gt;
&lt;p&gt;We're now ready to outline this "multiparty SSSSSS" design :) We'll
break it into three phases.&lt;/p&gt;
&lt;p&gt;Because 11 party would be too tedious, we'll stick to Alice, Bob,
Charlie three party case as above.&lt;/p&gt;
&lt;p&gt;Getting clear on notation: \(D_x\) will be destination addresses,
transactions will be \(\tau_x\), adaptor secrets will be \(t_x\),
corresponding curve points: \(T_x\). Signatures will be
\(\sigma_x\) and adaptor signatures will be marked with a ', so
\(\sigma_{x}'\). The subscripts will almost always be one of \(A,
B, C\) for Alice, Bob, Charlie.&lt;/p&gt;
&lt;h2&gt;Phase 1 - Setup&lt;/h2&gt;
&lt;p&gt;We first negotiate three destination addresses: \(D_A, D_B, D_C\).
Here the subscripts denote the payer &lt;strong&gt;into&lt;/strong&gt; the address. So after the
end of the setup the first will contain a coin paid by Alice, the second
by Bob and the third by Charlie. The preparation of these addresses/keys
will of course be done with Musig but to reiterate, we are ignoring the
complexity there.&lt;/p&gt;
&lt;p&gt;The three parties then all provide signatures on backout transactions
such that each party gets their money back after a timeout. See the
section "Timing Controls" for more details on this.&lt;/p&gt;
&lt;p&gt;Once backouts are presigned, all parties pay into the destinations as
above and wait for confirms.&lt;/p&gt;
&lt;p&gt;Parties will agree in advance on the "shuffle"/permutation of coins,
i.e. who will be paying who; this is related to Timing Control, so
again, see that section. The exact negotiation protocol to decide the
permutation is left open here. Once agreed, we know that we are going to
be arranging three transactions paying out of \(D_A, D_B, D_C\),
we'll call these \(\tau_{AB}, \tau_{BC}, \tau_{CA}\)
respectively, where the second subscript indicates who receives the
coin.&lt;/p&gt;
&lt;h2&gt;Phase 2 - Adaptors&lt;/h2&gt;
&lt;p&gt;Each participant chooses randomly their adaptor secret \(t_A, t_B,
t_C\) and then shares \(T_A, T_B, T_C\) with all others
(&lt;em&gt;technical note: this might need to happen in setup phase&lt;/em&gt;). They then
also &lt;strong&gt;all&lt;/strong&gt; provide adaptor signatures on&lt;strong&gt;all&lt;/strong&gt; of three transactions
\(\tau_{AB}, \tau_{BC}, \tau_{CA}\) to each other. Note that
there is no risk in doing so; the adaptor signatures are useless without
receiving the adaptor secrets. Now each party must make two checks on
each received adaptor signature:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;That it correctly matches the intended transaction \(\tau\) and
    the set of agreed keys in the setup&lt;/li&gt;
&lt;li&gt;Crucially that &lt;em&gt;each&lt;/em&gt; of the adaptor signatures from any
    counterparty correctly matches the same adaptor secret point
    \(T\).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;("Crucial" of course because without using the same adaptor secrets, we
don't get our desired atomicity across a set of transactions).&lt;/p&gt;
&lt;p&gt;To be more concrete, here are the actions of Bob:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Generate a single adaptor secret randomly: \(t_B
    \stackrel{$}{\leftarrow} \mathbb{Z}_N\)&lt;/li&gt;
&lt;li&gt;Broadcast \(T_B = t_B G\) to Alice, Charlie&lt;/li&gt;
&lt;li&gt;Having agreed on all three payout transactions \(\tau_{AB},
    \tau_{BC}, \tau_{CA}\), generate three adaptor signatures:
    \(\sigma_{B\tau_{AB}}' = k_{B\tau_{AB}} +
    \mathbb{H}(\Sigma P_{AB} || \Sigma R_{AB} + \Sigma T ||
    m_{\tau_{AB}}) x_{B\tau_{AB}}\), \(\sigma_{B\tau_{BC}}'
    = k_{B\tau_{BC}} + \mathbb{H}(\Sigma P_{BC} || \Sigma
    R_{BC} + \Sigma T || m_{\tau_{BC}}) x_{B\tau_{BC}}\),
    \(\sigma_{B\tau_{CA}}' = k_{B\tau_{CA}} +
    \mathbb{H}(\Sigma P_{CA} || \Sigma R_{CA} + \Sigma T ||
    m_{\tau_{CA}}) x_{B\tau_{CA}}\).&lt;/li&gt;
&lt;li&gt;Broadcast these adaptors to Alice, Charlie.&lt;/li&gt;
&lt;li&gt;Receive the 2 x 3 = 6 corresponding adaptors from Alice and Charlie.
    Verify each one (note the above bullet points).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Assuming all parties accept the adaptor signatures, we are ready to
proceed to the last phase. If any communication or protocol failure
occurs, all parties must fall back to the backout transactions presigned
in the Setup phase.&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;Technical note: it is not necessary for all parties to share all
adaptors, in general, but for simplicity we use that model, since it
hurts nothing I believe)&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Phase 3 - Execution&lt;/h2&gt;
&lt;p&gt;The order of events in this final execution phase is important for
safety, but we defer that to the next section "Timing Controls". Here
we'll just show how events will proceed if everything goes correctly, in
a randomly chosen order.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alice and Charlie send full partial(! i.e. not adaptor) signatures
    on \(\tau_{AB}\) to Bob, i.e. the transaction that pays Bob. So
    they send \(\sigma_{A\tau_{AB}}\) and
    \(\sigma_{C\tau_{AB}}\), respectively.&lt;/li&gt;
&lt;li&gt;Bob can add this to his own full partial signature on the same
    transaction, constructing: \(\sigma_{\tau_{AB}}\) and using
    this to broadcast \(\tau_{AB}\) to the network, receiving his
    coin.&lt;/li&gt;
&lt;li&gt;Alice will read \(\sigma_{C\tau_{AB}} + \sigma_{B\tau_{AB}}
    = \sigma_{\tau_{AB}} - \sigma_{A\tau_{AB}}\) from this
    broadcast signature and from this deduce the value of \(t_B+t_C =
    \sigma_{C\tau_{AB}} + \sigma_{B\tau_{AB}} -
    \sigma_{C\tau_{AB}}' + \sigma_{B\tau_{AB}}'\).&lt;/li&gt;
&lt;li&gt;Alice can add this aggregated adaptor secret \(t_B+t_C\) to the
    pre-existing adaptors \(\sigma_{B\tau_{CA}}' +
    \sigma_{C\tau_{CA}}'\) to get \(\sigma_{B\tau_{CA}} +
    \sigma_{C\tau_{CA}}\), which she can then add to
    \(\sigma_{A\tau_{CA}}\) to get a fully valid
    \(\sigma_{\tau_{CA}}\) and broadcast this to the network to
    receive her 1 coin.&lt;/li&gt;
&lt;li&gt;Charlie can do exactly the same as Alice for the last transaction,
    \(\tau_{BC}\) and receive his coin.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thus both other parties, after the first spend, were able to claim their
coin by creating complete signatures through combining the adaptor
signatures with the revealed (possibly aggregated) adaptor secrets.
(&lt;em&gt;Technical note: in a protocol we can allow participants to share
adaptor secrets at the appropriate times instead of having it deduced
from transaction broadcasts, as in the case of CoinSwap, just as a kind
of politeness, but this is not important&lt;/em&gt;).&lt;/p&gt;
&lt;h2&gt;Timing Controls&lt;/h2&gt;
&lt;p&gt;In the 2 party scriptless script swap, as in earlier CoinSwap designs,
we simply account for the asymmetry of timing of revealing priviliged
information (e.g. signatures) using an asymmetry of timelocks. The one
who transfers something valuable first (a signature) must have an
earlier ability to refunds coins that are "stuck" due to protocol
non-completion, else the possessor of the adaptor secret / CoinSwap
secret, who does not reveal it first, may wait for the window where he
can reclaim and the other cannot, to both reclaim and use the secret to
steal the other's coins.&lt;/p&gt;
&lt;p&gt;Here we must follow a similar principle, just extended to multiple
parties.&lt;/p&gt;
&lt;p&gt;Suppose, naively, we just used the same locktime on each of the three
refund transactions.&lt;/p&gt;
&lt;p&gt;Now suppose Alice, at the start of Phase 3, reveals her full signature
first, on transaction \(\tau_{AB}\) which pays Bob. And suppose for
maximal pessimism that Bob and Charlie are colluding to defraud Alice.
They will simply wait until the moment of the timeout and attempt to
cheat Alice: try to broadcast both of their own refunds, while spending
the transaction for which Alice provided the full signature (having done
so, she has revealed her adaptor secret to the other two).&lt;/p&gt;
&lt;p&gt;Thus by instead making Alice's backout locktime the earliest, she is
safe in transferring her full signature, and thus her adaptor secret
first. In this case if Bob and Charlie collude, they can do no better
than publish this spend before that (earliest) timeout, and in so doing,
reveal the aggregate of their adaptor secrets atomically so Alice can
claim her money well before their backouts become active, as intended by
system design.&lt;/p&gt;
&lt;p&gt;Now let's consider the second sender of a full signature, say it's Bob.
Suppose we let Charlie's locktime be identical to Bob's. And for maximal
pessimism let's say Alice and Charlie collude. Here, Charlie could
refuse to pass his signature to Bob and attempt to reclaim his coin at
the exact moment of the timeout, while spending Bob's (depending on the
exact permutation of spends, but at least, it's possible). Even though
Alice didn't back out at her timeout in this scenario, which is weird,
clearly this scenario is not safe for Bob, he has passed across a
signature to Charlie with no time based defence against him.&lt;/p&gt;
&lt;p&gt;These considerations make it obvious, I think, that the obviously sound
way to do it is to stagger the locktime values according to the order in
which signatures, and therefore secrets, are revealed. If the order of
signature transfers is: first Alice, then Bob, then Charlie, then the
locktimes on the backouts which pay each must obey \(L_A &amp;lt; L_B
&amp;lt; L_C\).&lt;/p&gt;
&lt;p&gt;So I believe this ordering must be settled on in Phase 1 (because we
define these locktimes before signing the backout transactions).&lt;/p&gt;
&lt;h2&gt;Generalisation from 3-3 to N-N.&lt;/h2&gt;
&lt;p&gt;I believe this is trivial, modulo practicality.&lt;/p&gt;
&lt;h2&gt;Practical considerations, advantages&lt;/h2&gt;
&lt;p&gt;The scenario described is a multiparty coinswap in which essentially a
group of \(N\) parties could randomly shuffle history of their coins.
This could be done with or without a coordinator (either Joinmarket
style or server style), could possibly be done with a Coinshuffle++ type
coordination mechanism and/or blinding.&lt;/p&gt;
&lt;p&gt;Practicality: the biggest limitation is that of CoinSwap generally, but
extended further: using staggered locktime backouts means that in cases
of failure, participants may have to wait a long time for coin recovery.
This gets linearly worse with anonymity set, which is not good. Would
love to find a trick to avoid that.&lt;/p&gt;
&lt;p&gt;Expanding further on that same limitation, a larger number of
participants makes worse the problem that I've previously called "XBI",
or "cross block interactivity". There's a lot of exposure to DOS attacks
and simple network failure when participants not only have to
coordinate, but have to do so more than once. This could partially be
addressed with incentives, e.g. fidelity bonds, but I'm not convinced.&lt;/p&gt;
&lt;p&gt;On the positive side, there could be a tremendous boon over the 2-party
case in that it's possible here to have a group of anonymous
participants shuffle the history of their coins without any of the
parties knowing the others' linkages.&lt;/p&gt;
&lt;p&gt;Also positively, such larger group swaps may offer much larger privacy
improvements in a very economical way (a few hundred bytes on chain per
participant vs tens or hundreds of kilobytes via coinjoin? complete
finger in the air here of course).&lt;/p&gt;
&lt;p&gt;Leaving open: can amount decorrelation be achieved in a more powerful
way in this model? I believe so, for example by splitting amounts into
subsets across subsets of participants in interesting ways. Fees can
also be used for noise. I think the most powerful version of this model
would be very powerful indeed, but needs more detailed analysis, and
this blog post is already too long.&lt;/p&gt;
&lt;p&gt;Other applications: also leaving this open. Perhaps using adaptor
signatures in groups like this (exploiting the linearity of adaptor
signatures) has applications to second layer tech like Lightning or
similar contracting.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="cryptography"></category><category term="bitcoin"></category></entry><entry><title>Ring Signatures</title><link href="https://joinmarket.me/blog/blog/ring-signatures/" rel="alternate"></link><published>2019-02-28T00:00:00+01:00</published><updated>2019-02-28T00:00:00+01:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2019-02-28:/blog/blog/ring-signatures/</id><summary type="html">&lt;p&gt;construction of several different ring signatures relevant to Bitcoin.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Ring signatures&lt;/h3&gt;
&lt;h2&gt;Outline:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Basic goal of 1-of-\(N\) ring signatures&lt;/li&gt;
&lt;li&gt;Recap: the \(\Sigma\)-protocol&lt;/li&gt;
&lt;li&gt;OR of \(\Sigma\)-protocols, CDS 1994&lt;/li&gt;
&lt;li&gt;Abe-Ohkubo-Suzuki (AOS) 2002 (broken version)&lt;/li&gt;
&lt;li&gt;Security weaknesses&lt;/li&gt;
&lt;li&gt;Key prefixing&lt;/li&gt;
&lt;li&gt;Borromean, Maxwell-Poelstra 2015&lt;/li&gt;
&lt;li&gt;Linkability and exculpability&lt;/li&gt;
&lt;li&gt;AND of \(\Sigma\)-protocols, DLEQ&lt;/li&gt;
&lt;li&gt;Liu-Wei-Wong 2004&lt;/li&gt;
&lt;li&gt;Security arguments for the LWW LSAG&lt;/li&gt;
&lt;li&gt;Back 2015; compression, single-use&lt;/li&gt;
&lt;li&gt;Fujisaki-Suzuki 2007 and Cryptonote 2014&lt;/li&gt;
&lt;li&gt;Monero MLSAG&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Basic goal of 1-of-\(N\) ring signatures&lt;/h2&gt;
&lt;p&gt;The idea of a &lt;a href="https://en.wikipedia.org/wiki/Ring_signature"&gt;ring
signature&lt;/a&gt;
(the term itself is a bit sloppy in context, but let's stick with it
for now) is simple enough:&lt;/p&gt;
&lt;p&gt;An owner of a particular private key \(x\) signs a message \(m\) by
taking, usually without setup or interaction, a whole set of public
keys, one of which is his (\(P=xG\)), and forms a signature (exact
form unspecified) such that there is proof that &lt;strong&gt;at least one&lt;/strong&gt; of the
private keys is known to the signer, but which one was responsible for
the signature is not known by the verifier, and not calculatable.&lt;/p&gt;
&lt;p&gt;Obviously that's pretty vague but captures the central idea. We often
use the term "ring" because the construction must have some symmetry
over the entire set of \(n\) public keys, and a ring/circle represents
symmetry of an arbitrarily high order (limit of an \(n\)-gon). Less
abstractly it could be a good name because of some "loop"-ing aspect
of the algorithm that constructs the signature, as we'll see.&lt;/p&gt;
&lt;p&gt;What properties do we want then, in summation?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unforgeability&lt;/li&gt;
&lt;li&gt;Signer ambiguity&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We may want additional properties for some ring signatures, as we'll
see.&lt;/p&gt;
&lt;p&gt;In the following sections I want to cover some of the key conceptual
steps to the kinds of ring signatures currently used in cryptocurrency
protocols; most notably Monero, but also several others; and also in the
Confidential Transactions construction (see: Borromean ring signatures,
briefly discussed here). I will also discuss security of such
constructions, in much less detail than the &lt;a href="https://web.archive.org/web/20200713230948/https://joinmarket.me/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/"&gt;previous
blog&lt;/a&gt;
(on the security of Schnorr signatures), but showing how there are
several tricky issues to be dealt with, here.&lt;/p&gt;
&lt;h2&gt;Recap: the \(\Sigma\)-protocol&lt;/h2&gt;
&lt;p&gt;We consider a prover \(\mathbb{P}\) and a verifier \(\mathbb{V}\).&lt;/p&gt;
&lt;p&gt;A \(\Sigma\)-protocol is a three step game, in which the prover
convinces the verifier of something (it can be \(\mathbb{P}\)'s
knowledge of a secret, but it can also be something more complicated),
in zero knowledge. Readers interested in a much more detailed discussion
of the logic behind this and several applications of the idea can read
Sections 3 and 4 of my &lt;a href="https://github.com/AdamISZ/from0k2bp"&gt;From Zero (Knowledge) to
Bulletproofs&lt;/a&gt;
writeup, especially section 4.1.&lt;/p&gt;
&lt;p&gt;In brief, the three step game is:&lt;/p&gt;
&lt;p&gt;\(\mathbb{P} \rightarrow \mathbb{V}\):&lt;strong&gt;commitment&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\(\mathbb{V} \rightarrow \mathbb{P}\):&lt;strong&gt;challenge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\(\mathbb{P} \rightarrow \mathbb{V}\): &lt;strong&gt;response&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A few minor notes on this: obviously the game is not literally over with
the response step; the verifier will examine the response to establish
whether it is valid or invalid.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;commitment&lt;/strong&gt; will usually in this document be written \(R\) and
will here always be a point on an elliptic curve, which the prover may
(or may not! in these protocols) know the corresponding scalar multiple
(private key or nonce) \(k\) such that \(R=kG\).&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;challenge&lt;/strong&gt; will usually be written \(e\) and will usually be
formed as the hash of some transcript of data; the subtleties around
exactly &lt;em&gt;what&lt;/em&gt; is hashed can be vitally important, as we'll see. (This
is in the "Fiat-Shamir transform" case; we discussed the pure
interactive challenge case a bit in the previous blog and many other
places!)&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;response&lt;/strong&gt; will usually be a single scalar which will usually be
denoted \(s\).&lt;/p&gt;
&lt;p&gt;We will be playing with this structure a lot: forging transcripts \(R,
e, s\); running multiple instances of a \(\Sigma\)-protocol in
parallel and performing logical operations on them. All of this will
play out &lt;em&gt;mostly&lt;/em&gt; in the form of a Schnorr signature; again, refer to
previous blog posts or elementary explanations (including those written
by me) for more on that.&lt;/p&gt;
&lt;h2&gt;OR of \(\Sigma\)-protocols, CDS 1994&lt;/h2&gt;
&lt;p&gt;Let's start with the OR of \(\Sigma\)-protocols. I &lt;em&gt;believe&lt;/em&gt; this
solution is due to &lt;a href="https://link.springer.com/content/pdf/10.1007%2F3-540-48658-5_19.pdf"&gt;Cramer, Damgrd and Schoenmakers
'94&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(Historical note: the "believe" is because I've seen it cited to that
paper (which is famous for good reason, I guess); but in the paper they
actually attribute &lt;em&gt;this specific idea&lt;/em&gt; to "M. Ito, A. Saito, and T.
Nishizeki: Secret Sharing Scheme realizing any Access Structure, Proc.
Glob.Com. (1987)" ; unfortunately I can't find that on the 'net).&lt;/p&gt;
&lt;p&gt;It is also described, with a brief discussion of its security proof, in
&lt;a href="https://crypto.stanford.edu/~dabo/cryptobook/BonehShoup_0_4.pdf"&gt;Boneh-Shoup&lt;/a&gt;
Sec 19.7.2.&lt;/p&gt;
&lt;p&gt;This is not, as far as I know, used at all(?) nor that widely discussed,
but it is in some sense the most simple and logical way to get a 1 out
of \(N\) ring signature; use the XOR (\(\oplus\)) operation:&lt;/p&gt;
&lt;p&gt;We have in advance a set of public keys \(P_i\). We only know one
private key for index \(j\), \(x_j\).&lt;/p&gt;
&lt;p&gt;We'll now use a standard three move \(\Sigma\)-protocol to prove
knowledge of &lt;strong&gt;at least one key&lt;/strong&gt; without revealing which index is
\(j\).&lt;/p&gt;
&lt;p&gt;We're going to fake the non-\(j\)-index signatures in advance. Choose
\(s_i \stackrel{\$}{\leftarrow} \mathbb{Z}_N\ ,\ e_i
\stackrel{\$}{\leftarrow} \mathbb{Z}_N \quad \forall i \neq j\).&lt;/p&gt;
&lt;p&gt;Calculate \(R_i = s_iG - e_iP_i \quad \forall i \neq j\).&lt;/p&gt;
&lt;p&gt;For the real signing index, \(k_j \stackrel{\$}{\leftarrow}
\mathbb{Z}_N\ ,\quad R_j = k_jG\).&lt;/p&gt;
&lt;p&gt;We now have the full set of commitments: \((R_i \ \forall i)\)&lt;/p&gt;
&lt;p&gt;Now for the clever part. In an interactive \(\Sigma\)-protocol, we
would at this point receive a random challenge \(e \in
\mathbb{Z}_N\). For the Fiat Shamir transformed case,
noninteractively (as for a signature), we use the constructed
\(R\)-values as input to a hash function, i.e. \(e = H(m||R_i
\ldots)\). We have already set the non-signing index \(e\)-values,
for the signing index we set \(e_j = e \oplus (\bigoplus_{i \ne
j}{e_i})\).&lt;/p&gt;
&lt;p&gt;This allows us to calculate \(s_j = k_j + e_j x_j\), and we now have
the full set of 'responses' for all the \(\Sigma\)-protocols:
\(s_i \ \forall i\). (but here we are using Fiat Shamir, so it's
not actually a response).&lt;/p&gt;
&lt;p&gt;By working this way we have ensured that the signature verifier can
verify that the logical XOR of the three \(e\)-values is equal to the
Fiat Shamir based hash-challenge, e.g. for the case of three
"signatures", we will have:&lt;/p&gt;
&lt;p&gt;\(e = e_1 \oplus e_2 \oplus e_3 \stackrel{?}{=}
H(m||R_0||R_1||...)\)&lt;/p&gt;
&lt;p&gt;where the verifier would calculate each \(R_i\) as \(s_iG -
e_iP_i\).&lt;/p&gt;
&lt;p&gt;The excellent feature of this of course is that it is perfectly hidden
which of the three indexes was genuine. But the bad news is that the
protocol as stated, used let's say as a signature scheme, requires
about twice as many field elements as members of the group of signers.
The verifier needs to be given \((s_1, \ldots s_n),(e_1 \ldots
e_n)\).&lt;/p&gt;
&lt;p&gt;Another excellent feature: this is not restricted to the Schnorr ID
protocol. It can work with another identity protocol, and even better,
it could work with a &lt;em&gt;mix&lt;/em&gt; of them; they only have to share the one
challenge \(e\).&lt;/p&gt;
&lt;h2&gt;Abe-Ohkubo-Suzuki (AOS) 2002 (broken version)&lt;/h2&gt;
&lt;p&gt;This is an excellent
&lt;a href="https://www.iacr.org/cryptodb/archive/2002/ASIACRYPT/50/50.pdf"&gt;paper&lt;/a&gt;
generally, but its stand-out contribution, in this context, is a &lt;strong&gt;more
compact&lt;/strong&gt; version of the 1 of n ring signature above. To clarify here,
both this and the previous are \(O(n)\) where \(n\) is the group
size, so "much more compact" is about the constant factor (scale not
scaling!); we reduce it from roughly 2 to roughly 1.&lt;/p&gt;
&lt;p&gt;"Broken version" - here I'll present a slightly simpler form than the
one in the paper, and then explain the serious problem with it - which I
hope will be productive. &lt;strong&gt;Please don't mistake this as meaning that
the AOS design was broken, it was never presented like this in the
paper!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Anyway, I think the best explanation for what's going on here
conceptually is due to A. Poelstra in the &lt;a href="https://github.com/Blockstream/borromean_paper"&gt;Borromean ring signatures
paper&lt;/a&gt;,
particularly Section 2 ; the reference to time travel may seem whimsical
but it gets to the heart of what's going on here; it's about having a
simulated form of causality with one way functions, and then violating
that.&lt;/p&gt;
&lt;p&gt;In short: creating an ordinary Schnorr sig without the key (i.e.
forging) is impossible because, working at the curve point level of the
equation (\(sG = R + H(m||R)P\)), you need to know the hash value
before you can calculate \(R\), but you need to know the value of
\(R\) before you can calculate the hash. So we see that two one way
functions are designed to conflict with one another; only by removing
one of them (going from curve points to scalar eqn: (\(s = k +
H(m||kG)x\)), can we now create a valid \(s, R, m\) set.&lt;/p&gt;
&lt;p&gt;To achieve that goal over a set of keys, we can make that "simulated
causality enforcement" be based on the same principle, but over a set
of equations instead of one. The idea is to make the commitment
\(H(m||R)\) use the \(R\) value from the "previous"
signer/key/equation, where "previous" is modulo \(N\), i.e. there is
a loop of dependencies (a ring, in fact).&lt;/p&gt;
&lt;p&gt;[Quick description:]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;Our goal is a list of \(N\) correctly verifying Schnorr signature
equations, with the tweak as mentioned that each hash-value refers to
the "previous" commitment. We will work with \(N=4\) and index from
zero for concreteness. Our goal is:&lt;/p&gt;
&lt;p&gt;\(s_0 G = R_0 + H(m||R_3)P_0\)&lt;/p&gt;
&lt;p&gt;\(s_1 G = R_1 + H(m||R_0)P_1\)&lt;/p&gt;
&lt;p&gt;\(s_2 G = R_2 + H(m||R_1)P_2\)&lt;/p&gt;
&lt;p&gt;\(s_3 G = R_3 + H(m||R_2)P_3\)&lt;/p&gt;
&lt;p&gt;Again for concreteness, we imagine knowing specifically the private key
\(x_2\) for index 2, only. We can successfully construct the above,
but only in a certain sequence:&lt;/p&gt;
&lt;p&gt;Choose \(k_2 \stackrel{\$}{\leftarrow} \mathbb{Z}_N,\ R_2 =
k_2G\), choose \(s_3 \stackrel{\$}{\leftarrow} \mathbb{Z}_N\).&lt;/p&gt;
&lt;p&gt;\(\Rightarrow R_3 = s_3 G - H(m||R_2)P_3\). Now choose \(s_0
\stackrel{\$}{\leftarrow} \mathbb{Z}_N\).&lt;/p&gt;
&lt;p&gt;\(\Rightarrow R_0 = s_0 G - H(m||R_3)P_0\). Now choose \(s_1
\stackrel{\$}{\leftarrow} \mathbb{Z}_N\).&lt;/p&gt;
&lt;p&gt;\(\Rightarrow R_1 = s_1 G - H(m||R_0)P_1\).&lt;/p&gt;
&lt;p&gt;Last, do not choose but &lt;strong&gt;calculate&lt;/strong&gt; \(s_2\): it must be \(s_2 = k_2
+ H(m||R_1)x_2\).&lt;/p&gt;
&lt;p&gt;After this set of steps, the set of data: \(e_0, s_0, s_1, s_2, s_3\)
can be verified without exposing which private key was known. Here is
the verification:&lt;/p&gt;
&lt;p&gt;Given \(e_0, s_0\), reconstruct \(R_0 = s_0G -e_0P_0\).&lt;/p&gt;
&lt;p&gt;\(\Rightarrow e_1 =H(m||R_0)\ ,\ R_1 = s_1 G - e_1P_1\)&lt;/p&gt;
&lt;p&gt;\(\Rightarrow e_2 =H(m||R_1)\ ,\ R_2 = s_2 G - e_2P_2\)&lt;/p&gt;
&lt;p&gt;\(\Rightarrow e_3 =H(m||R_2)\ ,\ R_3 = s_3 G - e_3P_3\)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Check&lt;/strong&gt;: \(e_0 \stackrel{?}{=} H(m||R_3)\).&lt;/p&gt;
&lt;h3&gt;Security weaknesses&lt;/h3&gt;
&lt;p&gt;The description above can't be described as secure.&lt;/p&gt;
&lt;p&gt;To give a hint as to what I mean: is there something &lt;strong&gt;not completely
fixed&lt;/strong&gt; in the above construction? Maybe an issue that's not even
specific to the "ring" construction, but even for any one of the
signature equations?&lt;/p&gt;
&lt;p&gt;....&lt;/p&gt;
&lt;p&gt;The answer is the keys, \(P_i\). We can in the most general case
consider three scenarios, although there may be some gray areas between
them:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Key(s) fixed in advance: \(P_1 \ldots P_N\) are all specified
    before doing anything, and not allowed to change by the verifier.
    Every signature must be on that set of keys.&lt;/li&gt;
&lt;li&gt;The &lt;em&gt;set&lt;/em&gt; &lt;em&gt;of possible keys&lt;/em&gt; is fixed in advance exactly as
    described above, but the &lt;em&gt;set of keys used in the ring&lt;/em&gt; is chosen by
    the signer, dynamically, in signing oracle queries or forgery
    attempts.&lt;/li&gt;
&lt;li&gt;Even the set of possible keys is dynamic. That is to say, any valid
    curve point (for EC case) is a valid potential key in (ring)
    signature.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is not a full taxonomy of possible attack scenarios, either. Not
only must we consider the difference between EUF-CMA and SUF-CMA as was
discussed in the previous blog (a reminder: with SUF, a forger should
not be able to even create a second signature on the same message -
ECDSA doesn't have this in naive form), but much more: we must also
consider which of the above three key settings applies.&lt;/p&gt;
&lt;p&gt;Even outside of ring signature settings, just considering a large scale
deployment of a signature scheme across millions or billions of keys,
could mean that the difference between these cases really matters. In
&lt;a href="https://eprint.iacr.org/2015/996"&gt;this&lt;/a&gt;
paper by Dan Bernstein the term MU-UF-CMA is used to refer to the
"multi-user" setting for this, where only single-key signatures are
used but one must consider whether having billions of other keys and
signing oracles for them might impact the security of &lt;strong&gt;any one&lt;/strong&gt; key
(notice the huge difference between "I want to forge on \(P\)" and
"I want to forge on any existing key" is, in this scenario).&lt;/p&gt;
&lt;p&gt;So enough about settings, what exactly constitutes a security problem
with the above version of the AOS ring sig?&lt;/p&gt;
&lt;p&gt;Consider any one element in the ring like:&lt;/p&gt;
&lt;p&gt;\(s_0 = R_0 + H(m||R_3)P_0\)&lt;/p&gt;
&lt;p&gt;where, for concreteness, I choose \(n=4\) and look at the first of 4
signature equations. Because of Schnorr's linearity (see &lt;a href="https://web.archive.org/web/20200713230948/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;this earlier
blog
post&lt;/a&gt;
for some elucidations on the &lt;em&gt;advantage&lt;/em&gt; of this linearity, although it
was also noted there that it had concomitant dangers (worse,
actually!)), there are two obvious ways we could tweak this equation:&lt;/p&gt;
&lt;p&gt;(1) Tweaked \(s\) values on fixed message and tweaked keys:&lt;/p&gt;
&lt;p&gt;Choose \(\alpha \in \mathbb{Z}_N\) and set \(s' = s_0
+\alpha\). We will not alter \(R=kG\), but we alter \(P_0
\rightarrow P_0 + e_0\^{-1}\alpha G\). This makes the verification
still work &lt;strong&gt;without altering the fixing of the nonce in the hash value
\(e_0\):&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;\(s_0 G + \alpha G = R_0 + e_0 P_0 + \alpha G = R_0 + e_0\left(P_0 +
e_0\^{-1}\alpha G\right)\)&lt;/p&gt;
&lt;p&gt;So it's really not clear how bad this failing is; it's &lt;em&gt;kinda&lt;/em&gt; a
failure of strong unforgeability, but that notion doesn't precisely
capture it: we created a new, valid signature against a
[new]{style="text-decoration: underline;"} key, but with two severe
limitations: we weren't able to alter the message, and also, we
weren't able to &lt;em&gt;choose&lt;/em&gt; the new key \(P'\). That last is slightly
unobvious, but crucial : if I have a pre-prepared \(P\^{*}\), I
cannot choose \(\alpha\) to get \(P' = P\^{*}\) as that would
require a discrete logarithm break.&lt;/p&gt;
&lt;p&gt;A final statement, hopefully obvious: the above can apply to any and all
of the elements of the ring, so the forgery could consist of an entirely
different and random set of keys, not related to the starting set; but
the message would be the same, as would the \(R\) values.&lt;/p&gt;
&lt;p&gt;(2) Completely different messages on tweaked keys, with the same
signature&lt;/p&gt;
&lt;p&gt;This one is almost certainly more important. Algebraically, we here
allow alterations to the \(e\) values, using multiplication rather
than addition:&lt;/p&gt;
&lt;p&gt;Given the same starting \(s_0\) as in (1), we take a chosen new
message \(m\^{*}\) and calculate the new \(e\^{*} =
H(m\^{*}||R_3)\). If we likewise tweak the public key we get that
\(s_0, R_0\) is a valid signature on the new message, with the tweaked
key:&lt;/p&gt;
&lt;p&gt;\(s_0 G = R_0 + e_0\^{*}\left(\frac{e_0}{e_0\^{*}} P_0\right)\)&lt;/p&gt;
&lt;p&gt;We can see here that this produces a forgery with the same signature
values (but different hash values) on the new keys.&lt;/p&gt;
&lt;p&gt;Most definitions of security against forgery require the attacker to
create a signature on a not-previously-queried message - so this &lt;em&gt;is&lt;/em&gt; a
successful attack, by most measures.&lt;/p&gt;
&lt;p&gt;However it does share the same limitation with (1) mentioned above -
that you cannot "control" the keys on which you get a signature,
unless you know a relative discrete log between one of the existing keys
and your new key, which implies you knew the secret key of the first (in
which case all this is pointless; whenever you have a private key, there
is no forgery on it).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;All of this should make very clear the reason why the real AOS (see
Section 5.1 of the paper) discrete-log ring signature fixes the entire
set of keys inside the hash, i.e. \(e_i = H(m || R_{(i-1)\%n}||
P_0 \ldots P_{n-1})\).&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Key Prefixing&lt;/h3&gt;
&lt;p&gt;The method in the previous bolded sentence is sometimes called
"key-prefixing". One way of looking at it: the Fiat-Shamir transform
that takes the Identity Protocol into a signature scheme, should hash
the conversation transcript between the prover and verifier, previous to
the challenge step; by including the public keys in this hash, we are
treating the keyset as part of the conversation transcript, rather than
something ex-protocol-run.&lt;/p&gt;
&lt;p&gt;Also, the discussion above (both cases (1) and (2)) show clearly that
the same weakness exists for a single (\(n=1\)) key case.&lt;/p&gt;
&lt;p&gt;[And yet, for the single key case, it was not a done deal historically -
this caused real world arguments!]{style="text-decoration: underline;"}.
After all, there are many use cases where the key &lt;em&gt;is&lt;/em&gt; a given
ex-protocol-run, plus there may be some practical disadvantage to doing
the key-prefixing.&lt;/p&gt;
&lt;p&gt;In
&lt;a href="https://rd.springer.com/chapter/10.1007%2F978-3-662-53008-5_2"&gt;this&lt;/a&gt;
paper from CRYPTO-2016, the controversy arising out of this is
elucidated, showing that these theoretical concerns had very substantial
impact on arguably the largest real world crypto usage (TLS):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"Key-prefixing comes with the disadvantage that the entire public-key
has to\
be available at the time of signing. Specifically, in a CFRG message
from Sep-\
tember 2015 Hamburg [32] argues "having to hold the public key along
with\
the private key can be annoying" and "can matter for constrained
devices".\
Independent of efficiency, we believe that a cryptographic protocol
should be\
as light as possible and prefixing (just as any other component)
should only\
be included if its presence is justified. Naturally, in light of the
GMLS proof,\
Hamburg [32] and Struik [44] (among others) recommended against
key prefixing\
for Schnorr. Shortly after, Bernstein [10] identifies the error in
the GMLS theo-\
rem and posts a tight security proof for the key-prefixed variant of
Schnorr signa-\
tures. In what happens next, the participant of the CFRG mailing list
switched\
their minds and mutually agree that key-prefixing should be preferred,
despite of\
its previously discussed disadvantages. Specifically, Brown writes
about Schnorr\
signatures that "this justifies a MUST for inclusion of the public key
in the mes-\
sage of the classic signature" [16]. As a consequence, key-prefixing
is contained in\
the current draft for EdDSA [33]..."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Technical note: the "GMLS proof" mentioned in the above is the proof
given in
&lt;a href="https://www.researchgate.net/publication/256720499_Public_key_signatures_in_the_multi-user_setting"&gt;this&lt;/a&gt;
paper, that was intended to reduce the security of the multi-user
setting to that of the single-user setting, and that Dan Bernstein's
&lt;a href="https://eprint.iacr.org/2015/996"&gt;paper&lt;/a&gt;
previously mentioned proved to be invalid.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;What's the TLDR? Fix the keys in any group/ring/multisignature. And
even that may not be enough, see
&lt;a href="https://eprint.iacr.org/2018/068"&gt;MuSig&lt;/a&gt;
for details of why it really isn't, in the scenario of Bitcoin
aggregated multisig.&lt;/p&gt;
&lt;h2&gt;Borromean, Maxwell-Poelstra 2015&lt;/h2&gt;
&lt;p&gt;I covered this extensively (including description of AOS as above) in my
&lt;a href="https://github.com/AdamISZ/ConfidentialTransactionsDoc/"&gt;CT
writeup&lt;/a&gt;
section 3.2&lt;/p&gt;
&lt;p&gt;The idea of the construction as outlined in &lt;a href="https://github.com/Blockstream/borromean_paper"&gt;the paper by Maxwell,
Poelstra&lt;/a&gt;
is to increase the space-efficiency of the published proof even more. By
having several ring signatures joined at a single index we get a
reduction in the number of \(e\) values we publish. This is basically
the same idea as the "AND of \(\Sigma\)-protocols" discussed a
little later in this document (although here we will only be using it
for achieving a specific goal, "Linkability", see more on this next).&lt;/p&gt;
&lt;p&gt;For the real world context - Borromean ring signatures are used in
certain implementations of Confidential Transactions (e.g. Liquid by
Blockstream) today, and were previously used also in Monero for the same
goal of CT. They are a radically different use-case of ring signatures
to the one mostly described in the below; instead of using a ring
signature to hide the identity of a signer, they are used to hide which
exponent contains values in the encoding of a value committed to in a
Pedersen commitment. This allows arithmetic to be done on the
Pedersen-committed amount without worrying about overflow into negative
values modulo \(N\).&lt;/p&gt;
&lt;h2&gt;Linkability and Exculpability&lt;/h2&gt;
&lt;p&gt;In this section we'll briefly describe certain key features that turn
out to be useful in some real-world applications of a ring signature,
before in the following sections laying out how these features are, or
are not, achieved.&lt;/p&gt;
&lt;h3&gt;Linkability (and spontaneity)&lt;/h3&gt;
&lt;p&gt;At first glance, the idea "linkability" with a ring signature seems to
be a contradiction. Since we are trying to achieve signer
ambiguity/anonymity, we don't really want any "linking" being done.
But the idea is rather clever, and proves to be very interesting for
digital cash.&lt;/p&gt;
&lt;p&gt;In a &lt;strong&gt;linkable&lt;/strong&gt; ring signature, a participant with key \(P \in L\)
(i.e. \(L\) is a particular set of public keys), should be able to
produce one ring signature on a given message, but should not be able to
do so again without the two ring signatures being linked. Thus,
functionally, each participant can only make such a signature once
(note: they can still retain anonymity if double-signing).&lt;/p&gt;
&lt;p&gt;This restriction-to-one-signature-while-keeping-anonymity is easily seen
to be valuable in cases like electronic voting or digital cash, as well
as the oft-cited example explained in the next paragraph.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;spontaneity&lt;/strong&gt; property should be a lot more obvious. Consider the
example of a whistleblower. We would want individuals in some large
group (e.g. government bureaucrats) to attest to a statement, while only
revealing group membership and not individual identity. Clearly this is
not workable if it requires cooperation of other members of the group
(even in any setup phase), so it's necessary that the individual can
create the ring signature "spontaneously", knowing only the public key
of other participants.&lt;/p&gt;
&lt;p&gt;The paper uses the abbreviation LSAG for this type of signature:
"Linkable Spontaneous Anonymous Group" signature.&lt;/p&gt;
&lt;p&gt;Note that the previous two constructions (CDS, AOS) can also have this
spontaneity property; but not the linkability property.&lt;/p&gt;
&lt;h3&gt;Culpability, Exculpability and Claimability&lt;/h3&gt;
&lt;p&gt;A ring signature can be described as exculpable if, even given knowledge
of the signing private key, an adversary cannot deduce that that signing
key was the one used to create the ring signature.&lt;/p&gt;
&lt;p&gt;Notice that such a property may be immensely important in a range of
scenarios where a ring sig is useful - e.g. for a whistleblower whose
cryptographic keys were stolen or extracted by force, he could still
plausibly deny being the origin of a leak.&lt;/p&gt;
&lt;p&gt;The reader can easily verify that the AOS construction, for example, has
this exculpability. The fact that a particular key is released e.g.
\(x_2\) in our concrete example, does not allow inference of it having
been used to create that signature. Any other key could have created the
signature, using the same signing algorithm.&lt;/p&gt;
&lt;p&gt;The LWW LSAG, which we'll describe shortly, is on the other hand
&lt;strong&gt;culpable&lt;/strong&gt;, i.e. the opposite - because the key image can be verified
to be tied to one particular key.&lt;/p&gt;
&lt;p&gt;It's easy to see that the two properties &lt;strong&gt;exculpability&lt;/strong&gt; and
&lt;strong&gt;linkability&lt;/strong&gt; are somewhat in conflict, although I'm not aware of a
theorem that &lt;em&gt;absolutely requires&lt;/em&gt; linkability to somehow tag one key in
case it is leaked.&lt;/p&gt;
&lt;p&gt;Lastly, I'll mention &lt;strong&gt;claimability&lt;/strong&gt;, which is briefly described also
in the LWW paper (see below). It may be possible for the owner of a key
to independently/voluntarily prove that they were the source of a given
ring signature, which doesn't logically require culpability.
Claimability is generally easy to achieve with some proof of knowledge
technique.&lt;/p&gt;
&lt;h2&gt;AND of \(\Sigma\)-protocols, DLEQ&lt;/h2&gt;
&lt;p&gt;The thoughtful reader probably won't have much trouble in imagining
what it would mean to do the logical AND of 2 \(\Sigma\)-protocols.&lt;/p&gt;
&lt;p&gt;"AND" here just means you need to prove to the Verifier that you know
both secrets / both conditions are true. So this only requires that you
can answer both challenges (second step) with correct responses. Using
the standard notation, that means generating two transcripts:&lt;/p&gt;
&lt;p&gt;\((R_1, e, s_1) \quad (R_2, e, s_2)\)&lt;/p&gt;
&lt;p&gt;i.e. the same \(e\)-value is given to both protocol runs after
receiving the initial commitments from each. Fiat-Shamir-ising this
protocol will work the same as the usual logic; if considering a
signature scheme, we'll be hashing something like
\(H(m||R_1||R_2||P_1||P_2)\), if we include, as we have learnt
to, key-prefixing.&lt;/p&gt;
&lt;p&gt;As we already mentioned, the Borromean ring signature design uses this
idea to compactify a set of ring signatures, since only one
\(e\)-value is being published, rather than \(M\) for \(M\) ring
signatures.&lt;/p&gt;
&lt;p&gt;This much is not super-interesting; but we can tighten this up a bit and
only use &lt;strong&gt;one&lt;/strong&gt; commitment and response in a special case:&lt;/p&gt;
&lt;h3&gt;Proof of Discrete Log Equivalence (DLEQ, PoDLE)&lt;/h3&gt;
&lt;p&gt;See one of the first posts on this
&lt;a href="https://web.archive.org/web/20200713230948/https://joinmarket.me/blog/blog/poodle"&gt;blog&lt;/a&gt;
for a description of this technique; here we're giving a slightly
deeper look at the meaning.&lt;/p&gt;
&lt;p&gt;If you are proving not only knowledge of a secret \(x\), but also that
two curve points have the same discrete log \(x\) w.r.t. different
bases \(G\) and \(J\) (whose relative discrete log must not be
known; see earlier blog post etc.), you can condense the above AND by
reusing the commitment and challenge for the two bases:&lt;/p&gt;
&lt;p&gt;\(\mathbb{P} \rightarrow \mathbb{V}\): \(R_1= kG,R_2=kJ\)&lt;/p&gt;
&lt;p&gt;\(\mathbb{V} \rightarrow \mathbb{P}\): \(e =
H(m||R_1||R_2||P_1||P_2)\)&lt;/p&gt;
&lt;p&gt;\(\mathbb{P} \rightarrow \mathbb{V}\): \(s\), (in secret:
\(=k+ex\))&lt;/p&gt;
&lt;p&gt;Now, if the prover acted honestly, his construction of \(s\) will
correctly pass verification &lt;strong&gt;twice&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;\(sG \stackrel{?}{=}R_1 +e P_1 \quad sJ \stackrel{?}{=} R_2 +
eP_2\)&lt;/p&gt;
&lt;p&gt;... and notice that it would be impossible to make that work for
different \(x\)-values on the two bases \(G\) and \(J\) because
you would need to find \(k_1, k_2 \in \mathbb{Z}_N, x_1, x_2 \in
\mathbb{Z}_N\) such that, &lt;strong&gt;without knowing \(e\) in advance,&lt;/strong&gt;
\(s = k_1 + ex_1 =k_2 + ex_2\), which is clearly impossible.&lt;/p&gt;
&lt;p&gt;Proof of soundness is easy to see using the standard rewinding technique
(see e.g. previous blog post amongst many other places); after the two
upfront commitments are fixed and the \(e\)-values are "forked", we
will get two \(s\) values as usual and extract \(x\).&lt;/p&gt;
&lt;h2&gt;Liu-Wei-Wong 2004 LSAG&lt;/h2&gt;
&lt;p&gt;Shortly after the AOS paper, Liu, Wei and Wong published a
&lt;a href="https://www.researchgate.net/publication/220798466_Linkable_Spontaneous_Anonymous_Group_Signature_for_Ad_Hoc_Groups_Extended_Abstract"&gt;paper&lt;/a&gt;
outlining how the same basic idea could be extended to a slightly more
complex context of requiring &lt;strong&gt;linkability&lt;/strong&gt;, as earlier mentioned. It
uses a combination of the above: DLEQ via AND of
\(\Sigma\)-protocols, and OR of \(\Sigma\)-protocols for the ring
signature hiding effect. Detailed algorithm with commentary follows.&lt;/p&gt;
&lt;h3&gt;Liu-Wei-Wong's LSAG algorithm&lt;/h3&gt;
&lt;p&gt;We start with a keyset \(L = \{P_0 \ldots P_{n-1}\}\) chosen by
the signer, whose index will be \(\pi\) (note the ambiguities about
"what is the set of valid keys?" as was discussed under "Key
Prefixing"). We then form a special new kind of curve point that we'll
name from now on as the &lt;strong&gt;key image&lt;/strong&gt; (for reasons that'll become
clear):&lt;/p&gt;
&lt;p&gt;\(I =x_{\pi} \mathbb{H}(L)\)&lt;/p&gt;
&lt;p&gt;Here \(\mathbb{H}\) is a hash function whose output space is points
on the curve, rather than scalar numbers. (&lt;em&gt;The mechanical operation for
doing this is sometimes described as "coerce to point"; for example,
take the 256 bit number output by SHA256 and interpret it as an
\(x-\)coordinate on secp256k1, find the "next" valid point
\(x,y\), incrementing \(x\) if necessary, or whatever; just has to
be deterministic&lt;/em&gt;). \(\mathbb{H}(L)\) is therefore going to play the
same role as \(J\) in the previous section, and we assume
intractability of relative discrete log due to the hashing.&lt;/p&gt;
&lt;h3&gt;Signing LWW LSAG&lt;/h3&gt;
&lt;p&gt;The following steps are very similar "in spirit" to AOS; we still
"extend the causality loop" (bastardising Poelstra's description)
over the whole set of signatures instead of just one, but this time we
also "lift" the loop onto a base of \(\mathbb{H}(L)\) and replicate
the signatures there, too:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set \(k_{\pi} \stackrel{\$}{\leftarrow} \mathbb{Z}_N\)&lt;/li&gt;
&lt;li&gt;Form the hash-challenge at the next index: \(e_{\pi+1} =
    H(m||L||k_{\pi}G||k_{\pi}\mathbb{H}(L)||I)\)&lt;/li&gt;
&lt;li&gt;Note to the above: \(k_{\pi}G\) was previously called
    \(R_{\pi}\) in AOS; we are trying to preserve here, the same
    notation where possible; and of course it's the \(R\) value, not
    the \(k\)-value that will be known/calculated by the verifier. The
    same applies to the "lifted" nonce-point which follows it in the
    concatenation. With respect to the key image, note that it &lt;em&gt;will&lt;/em&gt; be
    published and known to the verifier; but he won't know which index
    it corresponds to.&lt;/li&gt;
&lt;li&gt;Pick \(s_{\pi+1} \stackrel{\$}{\leftarrow} \mathbb{Z}_N\);
    then we do as in AOS, but duplicated; we set:&lt;/li&gt;
&lt;li&gt;\(R_{\pi+1} = s_{\pi+1}G - e_{\pi+1}P_{\pi+1}\) and
    \(R\^{*}_{\pi+1} = s_{\pi+1}\mathbb{H}(L) - e_{\pi+1}I\)&lt;/li&gt;
&lt;li&gt;I realise the last line is pretty dense, so let's clarify: the
    first half is exactly as for AOS; calculate \(R\) given the random
    \(s\) and the just-calculated hash value \(e\). The &lt;em&gt;second&lt;/em&gt;
    half is &lt;strong&gt;the same thing with the base point \(G\) replaced with
    \(\mathbb{H}(L)\), and the pubkey replaced with \(I\) at every
    index&lt;/strong&gt;. We used a shorthand \(R\^{*}\) to mean
    \(k_{\pi+1}\mathbb{H}(L)\), because of course we don't
    actually &lt;em&gt;know&lt;/em&gt; the value \(k_{\pi+1}\).&lt;/li&gt;
&lt;li&gt;Calculate the next hash-challenge as \(e_{pi+2} =
    H(m||L||R_{\pi+1}||R\^{*}_{\pi+1}||I)\)&lt;/li&gt;
&lt;li&gt;Etc...&lt;/li&gt;
&lt;li&gt;As with AOS, we can now forge all the remaining indices, wrapping
    around the loop, by repeating the above operation, generating a new
    random \(s\) at each step, until we get back to the signing index
    \(\pi\), when we must calculate \(s_{\pi}\) as: \(s_{\pi}
    = k_{\pi} + e_{\pi}x_{\pi}\).&lt;/li&gt;
&lt;li&gt;Signature is published as \(\sigma_{L}(m) = (s_0 \ldots
    s_{n-1}, e_0, I)\). (As before, if the keyset \(L\) is not
    specified in advance, it will have to be published for the
    verifier).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So what we're doing here is OR(DLEQ(0), DLEQ(1),.... DLEQ(n-1)). And
as observed, each DLEQ is actually an AND: "AND(I know x for P, x for P
is same as x for P2)". Hence this represents a clever combination of
AND- and OR- of \(\Sigma\)-protocols.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;On a personal note, when I first saw something of this type (I think it
was Cryptonote, see below), I found it quite bewildering, and I'm sure
I'm not alone! But what partially saved me is having already studied
PoDLE/DLEQ as well as AOS ring sigs, so I could intuit that something
combining the two ideas was going on. I hope the previous painstaking
introductions make it all a lot clearer!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Note the key similarities and difference(s) in the published signature,
to the AOS case: you still only need to publish one hash \(e_0\) since
the others are determined by it, but you &lt;strong&gt;must&lt;/strong&gt; publish also the key
image \(I\); if another LWW LSAG is published using the same private
key, it will perforce have the same key image, and be recognized as
having come from the same key [without revealing which
key]{style="text-decoration: underline;"}.&lt;/p&gt;
&lt;p&gt;The protocol using the LSAG can thus reject a "double-sign", if
desired.&lt;/p&gt;
&lt;p&gt;Let's sanity check that we understand the verification algorithm, since
it is slightly different than AOS:&lt;/p&gt;
&lt;h3&gt;Verifying LWW LSAG&lt;/h3&gt;
&lt;p&gt;Start with the given keyset \(L\), the message \(m\) and the
signature \((s_0 \ldots s_{n-1}, e_0, I)\)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Construct \(e_{1} = H(m||L||R_{0}||R\^{*}_{0}||I)\)
    using \(R_0 = s_0G - e_0 P_0\) and \(R\^{*}_{0} = s_0
    \mathbb{H}(L) - e_0 I \)&lt;/li&gt;
&lt;li&gt;Repeat at each index using the new \(e_j\) until \(e_0\) is
    calculated at the last step and verify it matches: \(e_0
    \stackrel{?}{=} H(m||L||R_{n-1}||R\^{*}_{n-1}||I)\).
    Accept if so, reject if not.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(with the additional point mentioned: the protocol using the sig scheme
may also reject this as valid if \(I\) has already been used; this
additional protocol step is usually described as "LINK" in the
literature).&lt;/p&gt;
&lt;h3&gt;A brief note on the key image&lt;/h3&gt;
&lt;p&gt;Make sure you get the difference between this \(\mathbb{H}(L)\) and
the previous \(J\) as per the general DLEQ. In the latter case we can
(and should) choose an arbitrary globally-agreed NUMS point, for example
hashing the standard curve base point \(G\) (with the
"coerce-to-point" technique mentioned). In this case, we have chosen
something that both signer and verifier agree on, as part of the
&lt;strong&gt;setting&lt;/strong&gt; of this particular run of the protocol - it's
deterministically tied to the keyset \(L\). The key image\(I\) is
analogous to \(P_2\) in my PoDLE blog post; it's the signer's
"hidden", one-time key.&lt;/p&gt;
&lt;p&gt;This changes in the next construction, Back 2015. But first, a few words
on security.&lt;/p&gt;
&lt;h2&gt;Security arguments for the LWW LSAG&lt;/h2&gt;
&lt;p&gt;The general approach to proving &lt;strong&gt;unforgeability&lt;/strong&gt; of this ring
signature is the same as that for the basic Schnorr signature as
described in the previous blog post.&lt;/p&gt;
&lt;p&gt;A wrapper around an attacker \(\mathbb{A}\) who we posit to have the
ability to construct a forgery without knowing any private key
\(x_i\), will, as before, have to guess which random oracle query
corresponds to the forgery, and will want to provide two different
"patched" answers to the RO query at that point. As before, there will
be some reduced probability of success due to having to make this kind
of guess, and so the reduction will be even less tight than before.&lt;/p&gt;
&lt;p&gt;Also as before, in the EUF-CMA model, we must allow for an arbitrary
number of signing oracle as well as RO queries, which complicates the
statistical analysis considerably, but the basic principles remain the
same. If at some point forgery is successfully achieved twice at the
same index, we will have something like:&lt;/p&gt;
&lt;p&gt;\(x_{\pi} =
\frac{s\^{*}_{\pi}-s_{\pi}}{e\^{*}_{\pi}-e_{\pi}}\)&lt;/p&gt;
&lt;p&gt;where the * superscripts indicate the second run, and the
\(e\)-values being the patched RO responses.&lt;/p&gt;
&lt;p&gt;And as usual, with appropriate statistical arguments, one can generate a
reduction such that forgery ability with a certain probability \(p\)
implies thus ability to solve ECDLP with a related probability
\(p'\).&lt;/p&gt;
&lt;p&gt;For proving &lt;strong&gt;signer ambiguity&lt;/strong&gt; - for simplicity, we break this into
two parts. If &lt;em&gt;all&lt;/em&gt; of the private keys are known to the attacker (e.g.
by subpoena), then this property completely fails. This is what we
called &lt;strong&gt;culpability&lt;/strong&gt;. It's easy to see why - we have the key image as
part of the signature, and that is deterministically reproducible given
the private key. If &lt;em&gt;none&lt;/em&gt; of the private keys are known to the
attacker, the problem is reduced to the &lt;strong&gt;solution of the &lt;a href="https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption"&gt;Decisional
Diffie Hellman
Problem&lt;/a&gt;&lt;/strong&gt;,
which is considered computationally hard. The reduction is quite
complicated, but as in a standard zero knowledgeness proof, the idea is
that a Simulator can generate a transcript that's statistically
indistinguishable from a genuine transcript.&lt;/p&gt;
&lt;p&gt;For proving &lt;strong&gt;linkability &lt;/strong&gt; - in the LWW paper an argument is made that
this reduces to ECDLP in more or less the same was as for the
unforgeability argument, using two pairs of transcripts for two
different signatures which are posited to be based on the same private
key but having different key images. Examination of the two pairs of
transcripts allows one to deduce that the private key in the two cases
are the same, else ECDLP is broken.&lt;/p&gt;
&lt;p&gt;Notice that these security arguments are [much more complicated than for
the single Schnorr signature case]{style="text-decoration: underline;"}
and perhaps for two distinct reasons: one, because the ring signature is
a more complex algebraic construction, with more degrees of freedom, but
also, because we are asking for a significantly richer set of properties
to hold. In particular notice that even for unforgeability, the EUF-CMA
description is not good enough (we've already discussed this a bit); we
need to consider what happens when creating multiple signatures on
different keysets and how they overlap. Signer anonymity/ambiguity is
especially difficult for LWW and its postdecessors (see below), because
by design it has been weakened (culpability).&lt;/p&gt;
&lt;h2&gt;Back 2015; compression, single-use&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;This is a good place to note that the constructions starting with LWW
are described in some detail in the useful document
&lt;a href="https://ww.getmonero.org/library/Zero-to-Monero-1-0-0.pdf"&gt;Zero-To-Monero&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Adam Back
&lt;a href="https://bitcointalk.org/index.php?topic=972541.msg10619684#msg10619684"&gt;posted&lt;/a&gt;
in 2015 on bitcointalk about a potential space saving over the
cryptonote ring signature, based on using AOS and tweaking it to include
a key image.&lt;/p&gt;
&lt;p&gt;As was noted above, it's a space saving of asymptotically about 50% to
use a scheme like AOS that only requires publication of one hash
challenge as opposed to one for each index (like the CDS for example).&lt;/p&gt;
&lt;p&gt;He then followed up noting that a very similar algorithm had already
been published, namely the LWW we've just described in the above, and
moreover it was published three years before Fujisaki-Suzuki that was
the basis of cryptonote (see below). So it was &lt;em&gt;somewhat&lt;/em&gt; of an
independent re-discovery, but there is a significant tweak. I'll
outline the algorithm below; it'll look very similar to LWW LSAG, but
there's a difference.&lt;/p&gt;
&lt;h3&gt;Signing Back-LSAG&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Define key image \(I =x_{\pi}\mathbb{H}(P_{\pi})\);&lt;/li&gt;
&lt;li&gt;Set \(k_{\pi} \stackrel{\$}{\leftarrow} \mathbb{Z}_N\)&lt;/li&gt;
&lt;li&gt;Form the hash-challenge at the next index: \(e_{\pi+1} =
    H(m||k_{\pi}G||k_{\pi}\mathbb{H}(P_{\pi}))\)&lt;/li&gt;
&lt;li&gt;Pick \(s_{\pi+1} \stackrel{\$}{\leftarrow} \mathbb{Z}_N\);
    then:&lt;/li&gt;
&lt;li&gt;\(R_{\pi+1} = s_{\pi+1}G - e_{\pi+1}P_{\pi+1}\) and
    \(R\^{*}_{\pi+1} = s_{\pi+1}\mathbb{H}(P_{\pi+1}) -
    e_{\pi+1}I\)&lt;/li&gt;
&lt;li&gt;Calculate the next hash-challenge as \(e_{pi+2} =
    H(m||R_{\pi+1}||R\^{*}_{\pi+1})\)&lt;/li&gt;
&lt;li&gt;Etc...&lt;/li&gt;
&lt;li&gt;As with AOS and LWW, we can now forge all the remaining indices,
    wrapping around the loop, by repeating the above operation,
    generating a new random \(s\) at each step, until we get back to
    the signing index \(\pi\), when we must calculate \(s_{\pi}\)
    as: \(s_{\pi} = k_{\pi} + e_{\pi}x_{\pi}\).&lt;/li&gt;
&lt;li&gt;Signature is published as \(\sigma_{L}(m) = (s_0 \ldots
    s_{n-1}, e_0, I)\), as in LWW (\(L\) being the set of \(P\)s).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Verification for this is near-identical as for LWW, so is left as an
exercise for the reader.&lt;/p&gt;
&lt;h3&gt;What's the difference, and what's the purpose?&lt;/h3&gt;
&lt;p&gt;The tweak - which is very similar to Cryptonote (makes sense as it was
an attempt to improve that) - is basically this: by making each of the
signatures in the shifted base point version symmetrical (example:
\(s_2 \mathbb{H}(P_2) = k_2 \mathbb{H}(P_2) + e_2 I\)), it means
that a key image will be valid &lt;em&gt;independent of the set of public keys,
\(L\).&lt;/em&gt; This is crucial in a cryptocurrency application - we need the
key image to be a unique double spend signifier across many different
ring signatures with different keysets - the keys are ephemeral and
change between transactions.&lt;/p&gt;
&lt;p&gt;So it's a blend of the LWW LSAG, which has the advantage of space
compaction for the same reason as AOS - only one hash must be published,
the others can be deduced from the ring structure - with the
F-S-2007/Cryptonote design, which fixes the key image to the key and not
just the specific ring.&lt;/p&gt;
&lt;p&gt;However I have to here leave open whether the security arguments of LWW
carry across to this case. I note that the original description did
&lt;em&gt;not&lt;/em&gt; include the keyset in the hash challenge (notice absence of
\(L\)); but see the note on MLSAG below.&lt;/p&gt;
&lt;h2&gt;Fujisaki-Suzuki 2007 and Cryptonote&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://cryptonote.org/whitepaper.pdf"&gt;Cryptonote&lt;/a&gt;
was adapted from a paper of &lt;a href="https://eprint.iacr.org/2006/389.pdf"&gt;Fujisaki and
Suzuki&lt;/a&gt;
describing an alternate version of a linkable (here "traceable") ring
signature, in 2007. We won't dwell on these constructions here (except
inasmuch as we referred to them above), as they provide the same
linkability function as the above LSAG, but are less compact. Instead,
in the final section, I'll describe how Monero has applied LWW LSAG and
the Back LSAG to their specific requirements.&lt;/p&gt;
&lt;h2&gt;Monero MLSAG&lt;/h2&gt;
&lt;p&gt;For anyone paying close attention all the way through, there will be
nothing surprising here!&lt;/p&gt;
&lt;p&gt;For a cryptocurrency, we build transactions consisting of multiple
inputs. Each input in Monero's case uses a ring signature, rather than
a single signature, to authenticate the transfer, referring back to
multiple pubkeys possessing coins as outputs of earlier transactions.&lt;/p&gt;
&lt;p&gt;So here we need &lt;strong&gt;one ring signature per input&lt;/strong&gt;. Moreover, per normal
transaction logic, we obviously need &lt;em&gt;all&lt;/em&gt; of those ring signatures to
successfully verify. So this is another case for the "AND of
\(\Sigma\)-protocols". We just run \(M\) cases of Back's LSAG and
combine them with a single \(e\) hash challenge at each key index (so
the hash challenge kind of "spans over the inputs"). Additionally,
note that the hash challenge here is assumed to include the keyset with
a generic \(L\) (limiting tiresome subscripting to a minimum...).&lt;/p&gt;
&lt;p&gt;To sign \(M\) inputs each of which have \(n\) keys:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For each input, define key image \(I_i
    =x_{i,\pi}\mathbb{H}(P_{i,\pi}) \ \forall i \in 0 \ldots
    M-1\);&lt;/li&gt;
&lt;li&gt;Set \(k_{i, \pi} \stackrel{\$}{\leftarrow} \mathbb{Z}_N \
    \forall i \in 0 \ldots M-1\)&lt;/li&gt;
&lt;li&gt;Form the hash-challenge at the next index: \(e_{\pi+1} =
    H(m||L||k_{0, \pi}G||k_{0,
    \pi}\mathbb{H}(P_{0,\pi})||k_{1, \pi}G||k_{1,
    \pi}\mathbb{H}(P_{1,\pi}) ...)\)&lt;/li&gt;
&lt;li&gt;Pick \(s_{i, \pi+1} \stackrel{\$}{\leftarrow} \mathbb{Z}_N\
    \forall i \in 0 \ldots M-1\); then:&lt;/li&gt;
&lt;li&gt;\(R_{i, \pi+1} = s_{i, \pi+1}G - e_{\pi+1}P_{i, \pi+1}\)
    and \(R\^{*}_{i, \pi+1} = s_{i, \pi+1}\mathbb{H}(P_{i,
    \pi+1}) - e_{\pi+1}I_i \ \forall i \in 0 \ldots M-1\)&lt;/li&gt;
&lt;li&gt;Calculate the next hash-challenge as \(e_{\pi+2} =
    H(m||L||R_{0, \pi+1}||R\^{*}_{0,\pi+1}||R_{1,
    \pi+1}||R\^{*}_{2,\pi+1} ...)\)&lt;/li&gt;
&lt;li&gt;Etc...&lt;/li&gt;
&lt;li&gt;Logic as for AOS, LWW but duplicated at every input with single
    \(e\)-challenge, and at signing index for all inputs (\(\pi\)):
    \(s_{i, \pi} = k_{i, \pi} + e_{i, \pi}x_{i, \pi}\ \forall
    i \in 0 \ldots M-1\).&lt;/li&gt;
&lt;li&gt;Signature is published as \(\sigma_{L}(m) = (s_{0,0} \ldots
    s_{0,M-1}, \ldots, s_{n-1,0}, \ldots s_{n-1,M-1}, e_0, I_0
    \ldots I_{M-1})\).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;(1) This algorithm as described requires each input to have the genuine
signer at the same key-index in the set of pubkeys for each input, which
is a limitation.&lt;/p&gt;
&lt;p&gt;(2) Monero has implemented Confidential Transactions, and this is
folded in with the above into a new design which seems to have two
variants "RingCTFull" and "RingCTSimple". This can be investigate
further in the documents on RingCT as referenced in the previously
mentioned
&lt;a href="https://ww.getmonero.org/library/Zero-to-Monero-1-0-0.pdf"&gt;ZeroToMonero&lt;/a&gt;.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="cryptography"></category><category term="bitcoin"></category></entry><entry><title>Liars, cheats, scammers and the Schnorr signature</title><link href="https://joinmarket.me/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/" rel="alternate"></link><published>2019-02-01T00:00:00+01:00</published><updated>2019-02-01T00:00:00+01:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2019-02-01:/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/</id><summary type="html">&lt;p&gt;security arguments for Schnorr&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Liars, cheats, scammers and the Schnorr signature&lt;/h3&gt;
&lt;p&gt;How sure are &lt;em&gt;you&lt;/em&gt; that the cryptography underlying Bitcoin is secure?
With regard to one future development of Bitcoin's crypto, in
discussions in public fora, I have more than once confidently asserted
"well, but the Schnorr signature has a security reduction to ECDLP".
Three comments on that before we begin:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you don't know what "reduction" means here, fear not, we will
    get deeply into this here.&lt;/li&gt;
&lt;li&gt;Apart from simply &lt;em&gt;hearing&lt;/em&gt; this and repeating it, I was mostly
    basing this on a loose understanding that "it's kinda related to
    the soundness proof of a sigma protocol" which I discussed in my
    &lt;a href="https://github.com/AdamISZ/from0k2bp"&gt;ZK2Bulletproofs&lt;/a&gt;
    paper, which is true - but there's a lot more involved.&lt;/li&gt;
&lt;li&gt;The assertion is true, but there are caveats, as we will see. And
    Schnorr is different from ECDSA in this regard, as we'll also see,
    at the end.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But why write this out in detail? It actually came sort of out of left
field. Ruben Somsen was asking on slack about some aspect of Monero, I
forget, but it prompted me to take another look at those and other ring
signatures, and I realised that attempting to understand the
&lt;strong&gt;security&lt;/strong&gt; of those more complex constructions is a non-starter unless
you &lt;strong&gt;really understand why we can say "Schnorr is secure" in the
first place&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Liars and cheats&lt;/h3&gt;
&lt;p&gt;The world of "security proofs" in cryptography appears to be a set of
complex stories about liars - basically made up magic beans algorithms
that &lt;em&gt;pretend&lt;/em&gt; to solve things that nobody &lt;em&gt;actually&lt;/em&gt; knows how to
solve, or someone placing you in a room and resetting your clock
periodically and pretending today is yesterday - and cheats, like
"let's pretend the output of the hash function is \(x\), because it
suits my agenda for it to be \(x\)" (at least in this case the lying
is consistent - the liar doesn't change his mind about \(x\); that's
something!).&lt;/p&gt;
&lt;p&gt;I hope that sounds crazy, it mostly really is :)&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;Concepts I am alluding to include: the random oracle, a ZKP simulator,
extractor/"forking", an "adversary" etc. etc.&lt;/em&gt;)&lt;/p&gt;
&lt;h2&gt;Preamble: the reluctant Satoshi scammer&lt;/h2&gt;
&lt;p&gt;The material of this blog post is pretty abstract, so I decided to spice
it up by framing it as some kind of sci-fi :)&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://web.archive.org/web/20200428212652im_/https://joinmarket.me/static/media/uploads/cube-250082_6402.png"&gt;&lt;/p&gt;
&lt;p&gt;Imagine you have a mysterious small black cube which you were given by
an alien that has two slots you can plug into to feed it input data and
another to get output data, but you absolutely can't open it (so like
an Apple device, but more interoperable), and it does one thing only,
but that thing is astonishing: if you feed it a message and a &lt;strong&gt;public&lt;/strong&gt;
key in its input slot, then it'll &lt;em&gt;sometimes&lt;/em&gt; spit out a valid Schnorr
signature on that message.&lt;/p&gt;
&lt;p&gt;Well in 2019 this is basically useless, but after considerable
campaigning (mainly by you, for some reason!), Schnorr is included into
Bitcoin in late 2020. Delighted, you start trying to steal money but it
proves to be annoying.&lt;/p&gt;
&lt;p&gt;First, you have to know the public key, so the address must be reused or
something similar. Secondly (and this isn't a problem, but is weird and
will become relevant later): the second input slot is needed to pass the
values of the hash function sha2 (or whatever is the right one for our
signature scheme) into the black box for any data it needs to hash. Next
problem: it turns out that the device only works if you feed it a few
&lt;em&gt;other&lt;/em&gt; signatures of other messages on the same public key, first.
Generally speaking, you don't have that. Lastly, it doesn't &lt;em&gt;always&lt;/em&gt;
work for any message you feed into it (you want to feed in 'messages'
which are transactions paying you money), only sometimes.&lt;/p&gt;
&lt;p&gt;With all these caveats and limitations, you fail to steal any money at
all, dammit!&lt;/p&gt;
&lt;p&gt;Is there anything else we can try? How about we pretend to be someone
else? Like Satoshi? Hmm ...&lt;/p&gt;
&lt;p&gt;For argument's sake, we'll assume that people use the Schnorr Identity
Protocol (henceforth SIDP), which can be thought of as "Schnorr
signature without the message, but with an interactive challenge".
We'll get into the technicals below, for now note that a signature
doesn't prove anything about identity (because it can be passed
around), you need an interactive challenge, a bit like saying "yes,
give me a signature, but *I* choose what you sign".&lt;/p&gt;
&lt;p&gt;So to get people to believe I'm Satoshi (and thus scam them into
investing in me perhaps? Hmm sounds familiar ...) I'm going to somehow
use this black box thing to successfully complete a run of SIDP. But as
noted it's unreliable; I'll need a bunch of previous signatures
(let's pretend that I get that somehow), but I *also* know this thing
doesn't work reliably for every message, so the best I can do is
probably to try to &lt;strong&gt;scam 1000&lt;/strong&gt; &lt;strong&gt;people simultaneously&lt;/strong&gt;. That way
they might reasonably believe that their successful run represents
proof; after all it's supposed to be &lt;em&gt;impossible&lt;/em&gt; to create this kind
of proof without having the private key - that's the entire idea of it!
(the fact that it failed for other people could be just a rumour, after
all!)&lt;/p&gt;
&lt;p&gt;So it's all a bit contrived, but weirder scams have paid off - and they
didn't even use literally alien technology!&lt;/p&gt;
&lt;p&gt;So, we'll need to read the input to our hash function slot from the
magic box; it's always of the form:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;message || R-value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;... details to follow, but basically \(R\) is the starting value in
the SIDP, so we pass it to our skeptical challenger(s). They respond
with \(e\), intended to be completely random to make our job of
proving ID as hard as possible, then &lt;strong&gt;we trick our black box&lt;/strong&gt; - we
don't return SHA2(\(m||R\)) but instead we return \(e\). More on
this later, see "random oracle model" in the below. Our magic box
outputs, if successful, \(R, s\) where \(s\) is a new random-looking
value. The challenger will be amazed to see that:&lt;/p&gt;
&lt;p&gt;\(sG = R + eP_{satoshi}\)&lt;/p&gt;
&lt;p&gt;is true!! And the millions roll in.&lt;/p&gt;
&lt;p&gt;If you didn't get in detail how that scam operated, don't worry,
we're going to unpack it, since it's the heart of our technical story
below. The crazy fact is that &lt;strong&gt;our belief that signatures like the
Schnorr signature (and ECDSA is a cousin of it) is mostly reliant on
basically the argument above.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;But 'mostly' is an important word there: what we actually do, to make
the argument that it's secure, is stack that argument on top of at
least 2 other arguments of a similar nature (using one algorithm as a
kind of 'magic black box' and feeding it as input to a different
algorithm) and to relate the digital signature's security to the
security of something else which ... we&lt;em&gt;think&lt;/em&gt; is secure, but don't
have absolute proof.&lt;/p&gt;
&lt;p&gt;Yeah, really.&lt;/p&gt;
&lt;p&gt;We'll see that our silly sci-fi story has &lt;em&gt;some&lt;/em&gt; practical reality to
it - it really &lt;em&gt;is&lt;/em&gt; true that to impersonate is a bit more practically
feasible than to extract private keys, and we can even quantify this
statement, somewhat.&lt;/p&gt;
&lt;p&gt;But not the magic cube part. That part was not real at all, sorry.&lt;/p&gt;
&lt;h2&gt;Schnorr ID Protocol and signature overview&lt;/h2&gt;
&lt;p&gt;I have explained SIDP with reference to core concepts of Sigma Protocols
and Zero Knowledge Proofs of Knowledge in Section 3.2
&lt;a href="https://github.com/AdamISZ/from0k2bp"&gt;here&lt;/a&gt;
. A more thorough explanation can be found in lots of places, e.g.
Section 19.1 of &lt;a href="https://crypto.stanford.edu/~dabo/cryptobook/"&gt;Boneh and
Shoup&lt;/a&gt;.
Reviewing the basic idea, cribbing from my own doc:&lt;/p&gt;
&lt;p&gt;Prover \(\mathbf{P}\) starts with a public key \(P\) and a
corresponding private key \(x\) s.t. \(P = xG\).&lt;/p&gt;
&lt;p&gt;\(\mathbf{P}\) wishes to prove in zero knowledge, to verifier
\(\mathbf{V}\), that he knows \(x\).&lt;/p&gt;
&lt;p&gt;\(\mathbf{P}\)  \(\mathbf{V}\): \(R\) (a new random curve
point, but \(\mathbf{P}\) knows \(k\) s.t. \(R = kG\))&lt;/p&gt;
&lt;p&gt;\(\mathbf{V}\)  \(\mathbf{P}\): \(e\) (a random scalar)&lt;/p&gt;
&lt;p&gt;\(\mathbf{P}\)  \(\mathbf{V}\): \(s\) (which \(\mathbf{P}\)
calculated from the equation \(s = k + ex\))&lt;/p&gt;
&lt;p&gt;Note: the transcript of the conversation would here be: \((R, e,
s)\).&lt;/p&gt;
&lt;p&gt;Verification works fairly trivially: verifier checks sG
\(\stackrel{?}{=} R+eP\). See previously mentioned doc for details on
why this is supposedly &lt;em&gt;zero knowledge&lt;/em&gt;, that is to say, the verifier
doesn't learn anything about the private key from the procedure.&lt;/p&gt;
&lt;p&gt;As to why it's sound - why does it really prove that the Prover knows
\(x\), see the same doc, but in brief: if we can convince the prover
to re-run the third step with a modified second step (but the same first
step!), then he'll be producing a second signature \(s'\) on a
second random \(e'\), but with the same \(k\) and \(R\), thus:&lt;/p&gt;
&lt;p&gt;\(x = \frac{s-s'}{e-e'}\)&lt;/p&gt;
&lt;p&gt;So we say it's "sound" in the specific sense that only a
knower-of-the-secret-key can complete the protocol. But more on this
shortly!&lt;/p&gt;
&lt;p&gt;What about the famous "Schnorr signature"? It's just an
noninteractive version of the above. There is btw a brief summary in
&lt;a href="https://web.archive.org/web/20200428212652/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;this&lt;/a&gt;
earlier blog post, also. Basically replace \(e\) with a hash (we'll
call our hash function \(H\)) of the commitment value \(R\) and the
message we want to sign \(m\):&lt;/p&gt;
&lt;p&gt;\(e = H(m||R)\)&lt;/p&gt;
&lt;p&gt;; as mentioned in the just-linked blog post, it's also possible to add
other stuff to the hash, but these two elements at least are necessary
to make a sound signature.&lt;/p&gt;
&lt;p&gt;As was noted in the 80s by &lt;a href="https://link.springer.com/content/pdf/10.1007%2F3-540-47721-7_12.pdf"&gt;Fiat and
Shamir&lt;/a&gt;,
this transformation is generic to any zero-knowledge identification
protocol of the "three pass" or sigma protocol type - just use a hash
function to replace the challenge with H(message, commitment) to create
the new signature scheme.&lt;/p&gt;
&lt;p&gt;Now, if we want to discuss security, we first have to decide what that
even means, for a signature scheme. Since we're coming at things from a
Bitcoin angle, we're naturally focused on preventing two things:
forgery and key disclosure. But really it's the same for any usage of
signatures. Theorists class security into at least three types (usually
more, these are the most elementary classifications):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Total break&lt;/li&gt;
&lt;li&gt;Universal forgery&lt;/li&gt;
&lt;li&gt;Existential forgery&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Interesting historical note: this taxonomy is due to Goldwasser, Micali
and Rackoff - the same authors who introduced the revolutionary notion
of a "Zero Knowledge Proof" in the 1980s.)&lt;/p&gt;
&lt;p&gt;Total break means key disclosure. To give a silly example: if \(k=0\)
in the above, then \(s = ex\) and, on receipt of \(s\), the verifier
could simply multiply it by the modular inverse of \(e\) to extract
the private key \(x\). A properly random \(k\) value, or 'nonce',
as explained ad nauseam elsewhere, is critical to the security. Since
this is the worst possible security failure, being secure against it is
considered the weakest notion of "security" (note this kind of
"reverse" reasoning, it is very common and important in this field).&lt;/p&gt;
&lt;p&gt;The next weakest notion of security would be security against universal
forgery - the forger should not be able to generate a signature on any
message they are given. We won't mention this too much; we will focus
on the next, stronger notion of "security":&lt;/p&gt;
&lt;p&gt;"Security against existential forgery under adaptive chosen message
attack", often shortened to EUF-CMA for sanity (the 'adaptive(ly)'
sometimes seems to be dropped, i.e. understood), is clearly the
strongest notion out of these three, and papers on this topic generally
focus on proving this. "Chosen message" here refers to the idea that
the attacker even gets to choose &lt;em&gt;what&lt;/em&gt; message he will generate a
verifying forgery for; with the trivial restriction that it can't be a
message that the genuine signer has already signed.&lt;/p&gt;
&lt;p&gt;(A minor point: you can also make this definition more precise with
SUF-CMA (S = "strongly"), where you insist that the finally produced
signature by the attacker is not on the same message as one of the
pre-existing signatures. The famous problem of &lt;strong&gt;signature
malleability&lt;/strong&gt; experienced in ECDSA/Bitcoin relates to this, as noted by
Matt Green
&lt;a href="https://blog.cryptographyengineering.com/euf-cma-and-suf-cma/"&gt;here&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;I believe there are even stronger notions (e.g. involving active
attacks) but I haven't studied this.&lt;/p&gt;
&lt;p&gt;In the next, main section of this post, I want to outline how
cryptographers try to argue that both the SIDP and the Schnorr signature
are secure (in the latter case, with that strongest notion of security).&lt;/p&gt;
&lt;h2&gt;Why the Schnorr signature is secure&lt;/h2&gt;
&lt;h3&gt;Why the SIDP is secure&lt;/h3&gt;
&lt;p&gt;Here, almost by definition, we can see that only the notion of "total
break" makes sense: there is no message, just an assertion of key
ownership. In the context of SIDP this is sometimes called the
"impersonation attack" for obvious reasons - see our reluctant
scammer.&lt;/p&gt;
&lt;p&gt;The justification of this is somehow elegantly and intriguingly short:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The SIDP is secure against impersonation = The SIDP is &lt;em&gt;sound&lt;/em&gt; as a
ZKPOK.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You can see that these are just two ways of saying the same thing. But
what's the justification that either of them are true? Intuitively the
soundness proof tries to isolate the Prover as a machine/algorithm and
screw around with its sequencing, in an attempt to force it to spit out
the secret that we believe it possesses. If we hypothesise an adversary
\(\mathbb{A}\) who &lt;em&gt;doesn't&lt;/em&gt; possess the private key to begin with,
or more specifically, one that can pass the test of knowing the key for
any public key we choose, we can argue that there's only one
circumstance in which that's possible: &lt;strong&gt;if \(\mathbb{A}\) can solve
the general Elliptic Curve Discrete Logarithm Problem(ECDLP) on our
curve.&lt;/strong&gt; That's intuitively &lt;em&gt;very&lt;/em&gt; plausible, but can we prove it?&lt;/p&gt;
&lt;h3&gt;Reduction&lt;/h3&gt;
&lt;p&gt;(One of a billion variants on the web, taken from
&lt;a href="https://jcdverha.home.xs4all.nl/scijokes/6_2.html"&gt;here&lt;/a&gt;
:))&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;``` {.joke}
A mathematician and a physicist were asked the following question:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;    Suppose you walked by a burning house and saw a hydrant and&lt;/span&gt;
&lt;span class="err"&gt;    a hose not connected to the hydrant.  What would you do?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;P: I would attach the hose to the hydrant, turn on the water, and put out
   the fire.&lt;/p&gt;
&lt;p&gt;M: I would attach the hose to the hydrant, turn on the water, and put out
   the fire.&lt;/p&gt;
&lt;p&gt;Then they were asked this question:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;    Suppose you walked by a house and saw a hose connected to&lt;/span&gt;
&lt;span class="err"&gt;    a hydrant.  What would you do?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;P: I would keep walking, as there is no problem to solve.&lt;/p&gt;
&lt;p&gt;M: I would disconnect the hose from the hydrant and set the house on fire,
   reducing the problem to a previously solved form.
```&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The general paradigm here is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A protocol X is "reducible to" a hardness assumption Y if a
hypothetical adversary \(\mathbb{A}\) who can break X can also
violate Y.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the concrete case of X = SIDP and Y = ECDLP we have nothing to do,
since we've already done it. SIDP is intrinsically a test that's
relying on ECDLP; if you can successfully impersonate (i.e. break SIDP)
on any given public key \(P\) then an "Extractor" which we will now
call a &lt;strong&gt;wrapper&lt;/strong&gt;, acting to control the environment of
\(\mathbb{A}\) and running two executions of the second half of the
transcript, as already described above, will be able to extract the
private key/discrete log corresponding to \(P\). So we can think of
that Extractor itself as a machine/algorithm which spits out the \(x\)
after being fed in the \(P\), in the simple case where our
hypothetical adversary \(\mathbb{A}\) is 100% reliable. In this
specific sense:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;SIDP is reducible to ECDLP&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;However, in the real world of cryptographic research, such an analysis
is woefully inadequate; because to begin with ECDLP being "hard" is a
computational statement: if the group of points on the curve is only of
order 101, it is totally useless since it's easy to compute all
discrete logs by brute force. So, if ECDLP is "hard" on a group of
size \(2^k\), let's say its hardness is measured as the probability
of successfully cracking by guessing, i.e. \(2^{-k}\) (here
&lt;strong&gt;deliberately avoiding&lt;/strong&gt; the real measure based on smarter than pure
guesses, because it's detail that doesn't affect the rest). Suppose
\(\mathbb{A}\) has a probability of success \(\epsilon\); what
probability of success does that imply in solving ECDLP, in our
"wrapper" model? Is it \(\epsilon\)?&lt;/p&gt;
&lt;p&gt;No; remember the wrapper had to actually extract &lt;strong&gt;two&lt;/strong&gt; successful
impersonations in the form of valid responses \(s\) to challenge
values \(e\). We can say that the wrapper &lt;strong&gt;forks&lt;/strong&gt; \(\mathbb{A}\):&lt;/p&gt;
&lt;p&gt;&lt;img alt="Fork your sigma protocol if you want
fork" src="https://web.archive.org/web/20200428212652im_/https://joinmarket.me/static/media/uploads/.thumbnails/forking.png/forking-659x466.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Fork your sigma protocol if you want fork&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Crudely, the success probability is \(\epsilon^2\); both of those
impersonations have to be successful, so we multiply the probabilities.
(More exact: by a subtle argument we can see that the size of the
challenge space being reduced by 1 for the second run of the protocol
implies that the probability of success in that second run is reduced,
and the correct formula is \(\epsilon^2 - \frac{\epsilon}{n}\),
where \(n\) is the size of the hash function output space; obviously
this doesn't matter too much).&lt;/p&gt;
&lt;p&gt;How does this factor into a real world decision? We have to go back to
the aforementioned "reverse thinking". The reasoning is something
like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We believe ECDLP is hard for our group, let's say we think you
    can't do better than p = \(p\) (I'll ignore running time and
    just use probability of success as a measure, for simplicity).&lt;/li&gt;
&lt;li&gt;The above reduction implies that &lt;em&gt;if&lt;/em&gt; we can break SIDP with prob
    \(\epsilon\), we can also break ECDLP with prob \(\simeq
    \epsilon^2\).&lt;/li&gt;
&lt;li&gt;This reduction is thus &lt;strong&gt;not tight&lt;/strong&gt; - if it's really the case that
    "the way to break SIDP is only to break ECDLP" then a certain
    hardness \(p\) only implies a hardness \(\sqrt{p}\) for SIDP,
    which we may not consider sufficiently improbable (remember that if
    \(p=2^{-128}\), it means halving the number of bits: \(\sqrt{p}
    =2^{-64}\)). See
    &lt;a href="https://crypto.stackexchange.com/questions/14439/proofs-by-reduction-and-times-of-adversaries"&gt;here&lt;/a&gt;
    for a nice summary on "non-tight reductions".&lt;/li&gt;
&lt;li&gt;And &lt;em&gt;that&lt;/em&gt; implies that if I want 128 bit security for my SIDP, I
    need to use 256 bits for my ECDLP (so my EC group, say). This is all
    handwavy but you get the pattern: these arguments are central to
    deciding what security parameter is used for the underlying hardness
    problem (here ECDLP) when it's applied in practice to a specific
    protocol (here SIDP).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I started this subsection on "reductions" with a lame math joke; but I
hope you can see how delicate this all is ... we start with something
we believe to be hard, but then "solve" it with a purely hypothetical
other thing (here \(\mathbb{A}\) ), and from this we imply a two-way
connection (I don't say &lt;em&gt;equivalence&lt;/em&gt;; it's not quite that) that we
use to make concrete decisions about security. Koblitz (he of the 'k'
in secp256k1) had some interesting thoughts about 'reductionist'
security arguments in Section 2.2 and elsewhere in
&lt;a href="https://cr.yp.to/bib/2004/koblitz.pdf"&gt;this&lt;/a&gt;
paper. More from that later.&lt;/p&gt;
&lt;p&gt;So we have sketched out how to think about "proving our particular SIDP
instance is/isn't secure based on the intractability of ECDLP in the
underlying group"; but that's only 2 stacks in our jenga tower; we
need MOAR!&lt;/p&gt;
&lt;h2&gt;From SIDP to Schnorr signature&lt;/h2&gt;
&lt;p&gt;So putting together a couple of ideas from previous sections, I hope it
makes sense to you now that we want to prove that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"the (EC) Schnorr signature has existential unforgeability against
chosen message attack (EUFCMA) &lt;strong&gt;if&lt;/strong&gt; the Schnorr Identity Protocol is
secure against impersonation attacks."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;with the understanding that, if we succeed in doing so, we have proven
also:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"the (EC) Schnorr signature has existential unforgeability against
chosen message attack (EUFCMA) &lt;strong&gt;if&lt;/strong&gt; the Elliptic Curve discrete
logarithm problem is hard in our chosen EC group."&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;with the substantial caveat, as per the previous section, that the
reduction involved in making this statement is not tight.&lt;/p&gt;
&lt;p&gt;(there is another caveat though - see the next subsection, &lt;em&gt;The Random
Oracle Model&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;This second (third?) phase is much less obvious and indeed it can be
approached in more than one way.
&lt;a href="https://crypto.stanford.edu/~dabo/cryptobook/"&gt;Boneh-Shoup&lt;/a&gt;
deals with it in a lot more detail; I'll use this as an outline but
dumb it down a fair bit. There is a simpler description
&lt;a href="http://web.stanford.edu/class/cs259c/lectures/schnorr.pdf"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The "CMA" part of "EUFCMA" implies that our adversary
\(\mathbb{A}\), who we are now going to posit has the magical ability
to forge signatures (so it's the black cube of our preamble), should be
able to request signatures on an arbitrarily chosen set of messages
\(m_i\), with \(i\) running from 1 to some defined number \(S\).
But we must also allow him to make queries to the hash function, which
we idealise as a machine called a "random oracle". Brief notes on that
before continuing:&lt;/p&gt;
&lt;h3&gt;Aside: The Random Oracle Model&lt;/h3&gt;
&lt;p&gt;Briefly described
&lt;a href="https://en.wikipedia.org/wiki/Random_oracle"&gt;here&lt;/a&gt;
. It's a simple but powerful idea: we basically idealise how we want a
cryptographic hash function \(f\) to behave. We imagine an output
space for \(f\) of size \(C\). For any given input \(x\) from a
predefined input space of one or more inputs, we will get a
deterministic output \(y\), but it should be unpredictable, so we
imagine that the function is &lt;em&gt;randomly&lt;/em&gt; deterministic. Not a
contradiction - the idea is only that there is no &lt;strong&gt;public&lt;/strong&gt; law or
structure that allows the prediction of the output without actually
passing it through the function \(f\). The randomness should be
uniform.&lt;/p&gt;
&lt;p&gt;In using this in a security proof, we encounter only one problem: we
will usually want to model \(f\) by drawing its output \(y\) from a
uniformly random distribution (you'll see lines like \(y
\stackrel{\$}{\leftarrow} \mathbb{Z}_N\) in papers, indicating
\(y\) is set randomly). But in doing this, we have set the value of
the output for that input \(x\) permanently, so if we call \(f\)
again on the same \(x\), whether by design or accident, we &lt;em&gt;must&lt;/em&gt;
again return the same "random" \(y\).&lt;/p&gt;
&lt;p&gt;We also find sometimes that in the nature of the security game we are
playing, one "wrapper" algorithm wants to "cheat" another, wrapped
algorithm, by using some hidden logic to decide the "random" \(y\)
at a particular \(x\). This &lt;em&gt;can&lt;/em&gt; be fine, because to the "inner"
algorithm it can look entirely random. In this case we sometimes say we
are "&lt;strong&gt;patching the value of the RO at \(x\) to \(y\)"&lt;/strong&gt; to
indicate that this artificial event has occurred; as already mentioned,
it's essential to remember this output and respond with it again, if a
query at \(x\) is repeated.&lt;/p&gt;
&lt;p&gt;Finally, this "perfectly random" behaviour is very idealised. Not all
cryptographic protocols involving hash functions require this behaviour,
but those that do are said to be "secure in the random oracle model
(ROM)" or similar.&lt;/p&gt;
&lt;h3&gt;Wrapping A with B&lt;/h3&gt;
&lt;p&gt;&lt;img alt="B tries to win the impersonation game against C, by wrapping the
signature forger
A" src="https://web.archive.org/web/20200428212652im_/https://joinmarket.me/static/media/uploads/.thumbnails/EUFCMA1.png/EUFCMA1-584x413.png"&gt;&lt;/p&gt;
&lt;p&gt;So we now wrap \(\mathbb{A}\) with \(\mathbb{B}\).
And\(\mathbb{B}\)'s job will be to succeed at winning the SIDP
"game" against a challenger\(\mathbb{C}\) .&lt;/p&gt;
&lt;p&gt;Now \(\mathbb{A}\) is allowed \(S\) signing queries; given his
messages \(m_i\), we can use \(S\) eavesdropped conversations \(R,
e, s\) from the actual signer (or equivalently, just forge transcripts
- see "zero knowledgeness" of the Schnorr signature), and for each,
\(\mathbb{B}\) can patch up the RO to make these transcripts fit
\(\mathbb{A}\)'s requested messages; just do
\(H(m_i||R_i)=e_i\). Notice that this part of the process represents
\(S\) queries to the random oracle.&lt;/p&gt;
&lt;p&gt;Observe that \(\mathbb{B}\) is our real "attacker" here: he's the
one trying to fool/attack \(\mathbb{C}\) 's identification
algorithm; he's just using \(\mathbb{A}\) as a black box (or cube,
as we say). We can say \(\mathbb{A}\) is a "subprotocol" used by
\(\mathbb{B}\).&lt;/p&gt;
&lt;p&gt;It's all getting a bit complicated, but by now you should probably have
a vague intuition that this will work, although of course not reliably,
and as a function of the probability of \(\mathbb{A}\) being able to
forge signatures of course (we'll again call this \(\epsilon\)).&lt;/p&gt;
&lt;h3&gt;Toy version: \(\epsilon = 1\)&lt;/h3&gt;
&lt;p&gt;To aid understanding, imagine the simplest possible case, when
\(\mathbb{A}\) works flawlessly. The key \(P\) is given to him and
he chooses a random \(k, R =kG\), and also chooses his message \(m\)
as is his right in this scenario. The "CMA" part of EUF-CMA is
irrelevant here, since \(\mathbb{A}\) can just forge immediately
without signature queries:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;\(\mathbb{A}\) asks for the value of \(H(m||R)\), by passing
    across \(m,R\) to \(\mathbb{B}\).&lt;/li&gt;
&lt;li&gt;\(\mathbb{B}\) receives this query and passes \(R\) as the
    first message in SIDP to \(\mathbb{C}\) .&lt;/li&gt;
&lt;li&gt;\(\mathbb{C}\) responds with a completely random challenge value
    \(e\).&lt;/li&gt;
&lt;li&gt;\(\mathbb{B}\) "patches" the RO with \(e\) as the output for
    input \(m, R\), and returns \(e\) to \(\mathbb{A}\) .&lt;/li&gt;
&lt;li&gt;\(\mathbb{A}\) takes \(e\) as \(H(m||R)\), and provides a
    valid \(s\) as signature.&lt;/li&gt;
&lt;li&gt;\(\mathbb{B}\) passes \(s\) through to \(\mathbb{C}\) , who
    verifies \(sG = R + eP\); identification passed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can see that nothing here is new except the random oracle patching,
which is trivially non-problematic as we make only one RO query, so
there can't be a conflict. The probability of successful impersonation
is 1.&lt;/p&gt;
&lt;p&gt;Note that this implies the probability of successfully breaking ECDLP is
also \(\simeq 1\). We just use a second-layer wrapper around
\(\mathbb{B}\), and fork its execution after the provision of
\(R\), providing two separate challenges and thus in each run getting
two separate \(s\) values and solving for \(x\), the private
key/discrete log as has already been explained.&lt;/p&gt;
&lt;p&gt;Why \(\simeq\)? As noted on the SIDP to ECDLP reduction above, there
is a tiny probability of a reused challenge value which must be factored
out, but it's of course negligible in practice.&lt;/p&gt;
&lt;p&gt;If we assert that the ECDLP is not trivially broken in reasonable time,
we must also assert that such a powerful \(\mathbb{A}\) does not
exist, given similarly limited time (well; &lt;em&gt;in the random oracle model&lt;/em&gt;,
of course...).&lt;/p&gt;
&lt;h3&gt;Full CMA case, \(\epsilon \&amp;lt;\&amp;lt; 1\)&lt;/h3&gt;
&lt;p&gt;Now we give \(\mathbb{A}\) the opportunity to make \(S\) signing
queries (as already mentioned, this is what we mean by an "adaptive
chosen message attack"). The sequence of events will be a little longer
than the previous subsection, but we must think it through to get a
sense of the "tightness of the reduction" as already discussed.&lt;/p&gt;
&lt;p&gt;The setup is largely as before: \(P\) is given. There will be \(h\)
RO queries allowed (additional to the implicit ones in the signing
queries).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For any signing query from \(\mathbb{A}\), as we covered in
    "Wrapping A with B", a valid response can be generated by patching
    the RO (or using real transcripts). We'll have to account for the
    possibility of a conflict between RO queries (addressed below), but
    it's a minor detail.&lt;/li&gt;
&lt;li&gt;Notice that as per the toy example previously, during
    \(\mathbb{A}\)'s forgery process, his only interaction with his
    wrapper \(\mathbb{B}\) is to request a hash value
    \(H(m||R)\). So it's important to understand that, first
    because of the probabilistic nature of the forgery (\(\epsilon
    \&amp;lt;\&amp;lt; 1\)), and second because \(\mathbb{A}\)'s algorithm is
    unknown, &lt;strong&gt;\(\mathbb{B}\) does not know which hash function query
    (and therefore which RO response) will correspond to a successful
    forgery.&lt;/strong&gt; This isn't just important to the logic of the game; as
    we'll see, it's a critical limitation of the security result we
    arrive at.&lt;/li&gt;
&lt;li&gt;So to address the above, \(\mathbb{B}\) has to make a decision
    upfront: which query should I use as the basis of my impersonation
    attempt with \(\mathbb{C}\)? He chooses an index \(\omega\
    \in 1..h\).&lt;/li&gt;
&lt;li&gt;There will be a total of \(S+h+1\) queries to the random oracle,
    at most (the +1 is a technical detail I'll ignore here). We
    discussed in the first bullet point that if there is a repeated
    \(m, R\) pair in one of the \(S\) signing queries, it causes a
    "conflict" on the RO output. In the very most pessimistic
    scenario, the probability of this causing our algorithm to fail can
    be no more than \(\frac{S+h+1}{n}\) for each individual signing
    query, and \(\frac{S(S+h+1)}{n}\) for all of them (as before we
    use \(n\) for the size of the output space of the hash function).&lt;/li&gt;
&lt;li&gt;So \(\mathbb{B}\) will &lt;strong&gt;fork&lt;/strong&gt; \(\mathbb{A}\)'s execution,
    just as for the SIDP \(\rightarrow\) ECDLP reduction, &lt;strong&gt;at index
    \(\omega\)&lt;/strong&gt;, without knowing in advance whether \(\omega\) is
    indeed the index at the which the hash query corresponds to
    \(\mathbb{A}\)'s final output forgery. There's a \(1/h\)
    chance of this guess being correct. So the "partial success
    probability", if you will, for this first phase, is
    \(\epsilon/h\), rather than purely \(\epsilon\), as we had for
    the SIDP case.&lt;/li&gt;
&lt;li&gt;In order to extract \(x\), though, we need that the execution
    &lt;em&gt;after&lt;/em&gt; the fork, with the new challenge value, at that same index
    \(\omega\), also outputs a valid forgery. What's the probability
    of both succeeding together? Intuitively it's of the order of
    \(\epsilon^2\) as for the SIDP case, but clearly the factor
    \(1/h\), based on accounting for the guessing of the index
    \(\omega\), complicates things, and it turns out that the
    statistical argument is rather subtle; you apply what has been
    called the &lt;strong&gt;Forking Lemma&lt;/strong&gt;, described on
    &lt;a href="https://en.wikipedia.org/wiki/Forking_lemma"&gt;Wikipedia&lt;/a&gt;
    and with the clearest statement and proof in
    &lt;a href="https://cseweb.ucsd.edu/~mihir/papers/multisignatures-ccs.pdf"&gt;this&lt;/a&gt;
    paper of Bellare-Neven '06. The formula for the success probability
    of \(\mathbb{B}\) turns out to be:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;\(\epsilon_{\mathbb{B}} = \epsilon\left(\frac{\epsilon}{h} -
\frac{1}{n}\right)\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://crypto.stanford.edu/~dabo/cryptobook/"&gt;Boneh-Shoup&lt;/a&gt;
    in Section 19.2 bundle this all together (with significantly more
    rigorous arguments!) into a formula taking account of the Forking
    Lemma, the accounting for collisions in the signing queries, to
    produce the more detailed statement, where \(\epsilon\) on the
    left here refers to the probability of success of \(\mathbb{B}\),
    and "DLADv" on the right refers to the probability of success in
    solving the discrete log. The square root term of course corresponds
    to the "reduction" from Schnorr sig. to ECDLP being roughly a
    square:&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;\(\epsilon \le \frac{S(S+h+1)}{n} + \frac{h+1}{n} +
\sqrt{(h+1)\ \times \ \textrm{DLAdv}}\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So in summary: we see that analysing the full CMA case in detail is
pretty complicated, but by far the biggest take away should be: &lt;strong&gt;The
security reduction for Schnorr sig to ECDLP has the same
\(\epsilon^2\) dependency, but is nevertheless far less tight,
because the success probability is also reduced by a factor \(\simeq
h\) due to having to guess which RO query corresponds to the successful
forgery.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;Minor clarification: basically ignoring the first two terms on the RHS
of the preceding as "minor corrections", you can see that DLAdv is
very roughly \(\epsilon^2/h\)&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;The above bolded caveat is, arguably, very practically important, not
just a matter of theory - because querying a hash function is something
that it's very easy for an attacker to do. If the reduction loses
\(h\) in tightness, and the attacker is allowed \(2^{60}\) hash
function queries (note - they can be offline), then we (crudely!) need
60 bits more of security in our underlying cryptographic hardness
problem (here ECDLP); at least, &lt;em&gt;if&lt;/em&gt; we are basing our security model on
the above argument.&lt;/p&gt;
&lt;p&gt;Although I haven't studied it, &lt;a href="https://eprint.iacr.org/2012/029"&gt;the 2012 paper by Yannick
Seurin&lt;/a&gt;
makes an argument (as far as I understand) that we cannot do better than
this, in the random oracle model, i.e. the factor of \(h\) cannot be
removed from this security reduction by some better kind of argument.&lt;/p&gt;
&lt;h2&gt;Summary - is Schnorr secure?&lt;/h2&gt;
&lt;p&gt;For all that this technical discussion has exposed the non-trivial guts
of this machine, it's still true that the argument provides some pretty
nice guarantees. We can say something like "Schnorr is secure if:"&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The hash function behaves to all intents and purposes like an ideal
    random oracle as discussed&lt;/li&gt;
&lt;li&gt;The ECDLP on our chosen curve (secp256k1 in Bitcoin) is hard to the
    extent we reasonably expect, given the size of the curve and any
    other features it has (in secp256k1, we hope, no features at all!)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This naturally raises the question "well, but how hard &lt;em&gt;is&lt;/em&gt; the
Elliptic Curve discrete logarithm problem, on secp256k1?" Nobody really
knows; there are known, standard ways of attacking it, which are better
than brute force unintelligent search, but their "advantage" is a
roughly known quantity (see e.g. &lt;a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm"&gt;Pollard's
rho&lt;/a&gt;).
What there isn't, is some kind of proof "we know that \(\nexists\)
algorithm solving ECDLP on (insert curve) faster than \(X\)".&lt;/p&gt;
&lt;p&gt;Not only don't we know this, but it's even rather difficult to make
statements about analogies. I recently raised the point on
#bitcoin-wizards (freenode) that I thought there must be a relationship
between problems like RSA/factoring and discrete log finding on prime
order curves, prompting a couple of interesting responses, agreeing that
indirect evidence points to the two hardness problems being to some
extent or other connected. Madars Virza kindly pointed out a
&lt;a href="https://wstein.org/projects/john_gregg_thesis.pdf#page=43"&gt;document&lt;/a&gt;
that details some ideas about the connection (obviously this is some
pretty highbrow mathematics, but some may be interested to investigate
further).&lt;/p&gt;
&lt;h2&gt;What about ECDSA?&lt;/h2&gt;
&lt;p&gt;ECDSA (and more specifically, DSA) were inspired by Schnorr, but have
design decisions embedded in them that make them &lt;em&gt;very&lt;/em&gt; different when
it comes to security analysis. ECDSA looks like this:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;\(s = k^{-1}\left(H(m) + rx\right), \quad r=R.x, \ R = kG\)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The first problem with trying to analyse this is that it doesn't
conform to the
three-move-sigma-protocol-identification-scheme-converts-to-signature-scheme-via-Fiat-Shamir-transform.
Why? Because the hash value is \(H(m)\) and doesn't include the
commitment to the nonce, \(R\). This means that the standard
"attack" on Schnorr, via rewinding and resetting the random oracle
doesn't work. This doesn't of course mean, that it's insecure -
there's another kind of "fixing" of the nonce, in the setting
of\(R.x\). This latter "conversion function" kind of a random
function, but really not much like a hash function; it's trivially
"semi-invertible" in as much as given an output x-coordinate one can
easily extract the two possible input R-values.&lt;/p&gt;
&lt;p&gt;Some serious analysis has been done on this, for the obvious reason that
(EC)DSA is &lt;strong&gt;very widely used in practice.&lt;/strong&gt; There is work by
&lt;a href="https://www.iacr.org/archive/pkc2003/25670309/25670309.pdf"&gt;Vaudenay&lt;/a&gt;
and
&lt;a href="https://www.cambridge.org/core/books/advances-in-elliptic-curve-cryptography/on-the-provable-security-of-ecdsa/69827A20CC94C54BBCBC8A51DBAF075A"&gt;Brown&lt;/a&gt;
(actually a few papers but I think most behind academic paywalls) and
most recently &lt;a href="https://dl.acm.org/citation.cfm?doid=2976749.2978413"&gt;Fersch et
al&lt;/a&gt;.
Fersch gave a talk on this work
&lt;a href="https://www.youtube.com/watch?v=5aUPBT4Rdr8"&gt;here&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;The general consensus seems to be "it's very likely secure - but
attempting to get a remotely "clean" security reduction is very
difficult compared to Schnorr".&lt;/p&gt;
&lt;p&gt;But wait; before we trail off with an inaudible mumble of "well, not
really sure..." - there's a crucial logical implication you may not
have noticed. Very obviously, ECDSA is not secure if ECDLP is not secure
(because you just get the private key; game over for any signature
scheme). Meanwhile, in the long argument above we &lt;strong&gt;reduced&lt;/strong&gt; Schnorr to
ECDLP. This means:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;If ECDSA is secure, Schnorr is secure, but we have no security
reduction to indicate the contrary.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The aforementioned Koblitz paper tells an interesting historical
anecdote about all this, when the new DSA proposal was first put forth
in '92 (emphasis mine):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"At the time, the proposed standard --- which soon after became the
first digital signature algorithm ever approved by the industrial
standards bodies --- encountered stiff opposition, especially from
advocates of RSA signatures and from people who mistrusted the NSA's
motives. Some of the leading cryptographers of the day tried hard to
find weaknesses in the NIST proposal. A summary of the most important
objections and the responses to them was published in the Crypto'92
proceedings[17]. The opposition was unable to find any significant
defects in the system. [In retrospect, it is amazing that none of the
DSA opponents noticed that when the Schnorr signature was modified,
the equivalence with discrete logarithms was
lost.]{style="text-decoration: underline;"}"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;More exotic constructions&lt;/h2&gt;
&lt;p&gt;In a future blog post, I hope to extend this discussion to other
constructions, which are based on Schnorr in some way or other, in
particular:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The AOS ring signature&lt;/li&gt;
&lt;li&gt;The Fujisaki-Suzuki, and the cryptonote ringsig&lt;/li&gt;
&lt;li&gt;the Liu-Wei-Wong, and the Monero MLSAG (via Adam Back) ringsig&lt;/li&gt;
&lt;li&gt;The MuSig multisignature&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While these are all quite complicated (to say the least!), so no
guarantee of covering all that, the security arguments follow similar
lines to the discussion in this post. Of course ring signatures have
their own unique features and foibles, so I will hopefully cover that a
bit, as well as the security question.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="cryptography"></category></entry><entry><title>Finessing commitments</title><link href="https://joinmarket.me/blog/blog/finessing-commitments/" rel="alternate"></link><published>2019-01-15T00:00:00+01:00</published><updated>2019-01-15T00:00:00+01:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2019-01-15:/blog/blog/finessing-commitments/</id><summary type="html">&lt;p&gt;discussion of properties of commitment schemes as applied to Bitcoin&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Finessing commitments&lt;/h3&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This post was mostly prompted by a long series of discussions had online
and in person with many people, including in particular Adam Back and
Tim Ruffing (but lots of others!) - and certainly not restricted to
discussions I took part in - about the tradeoffs in a version of Bitcoin
that does actually use Confidential Transactions.&lt;/p&gt;
&lt;p&gt;The topic that keeps recurring is: exactly what level of safety against
&lt;em&gt;hidden inflation&lt;/em&gt; does CT offer, in principle and in practice; this is
closely related to what level of privacy it offers, too, but the hidden
inflation is what gets people thinking, first and foremost.&lt;/p&gt;
&lt;p&gt;My goal here is to explain to people who are not completely up to speed
with what causes this discussion; to explain, in detail but without
assuming &lt;em&gt;too&lt;/em&gt; much pre-knowledge, what the heart of the tradeoff is,
and in the last couple of sections, how we might get around it. How we
might "have our cake and eat it" so to speak.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;You'll find a lot of the ideas in first three sections of this blog
post, although not all of them, in my write up on
&lt;a href="https://github.com/AdamISZ/from0k2bp"&gt;Bulletproofs&lt;/a&gt;
section 3, and I also went over the basics in the early part of my
London talk on the &lt;a href="https://www.youtube.com/watch?v=mLZ7qVwKalE"&gt;Schnorr
signature&lt;/a&gt;
(since they're not visible, you'd want to see the
&lt;a href="https://web.archive.org/web/20200428225915/https://joinmarket.me/static/schnorrplus.pdf"&gt;slides&lt;/a&gt;
for that talk if you watch it).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;You should have &lt;/em&gt;&lt;em&gt;some&lt;/em&gt;&lt;em&gt; general idea about what Confidential
Transactions is, in order to understand the second half - in particular
you should understand that amounts are hidden under Pedersen
commitments, although we'll go through some of it here in the early
sections.&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Commitments - the basic ideas&lt;/h2&gt;
&lt;p&gt;A commitment fixes a value in advance, without revealing it. Think of
flipping a coin and covering it with your hand as part of a gamble or
game. Covering it with your hand means it's invisible. The visibility of
your hand not moving, and pressed against a surface over the coin, on
the other hand, ensures you can't cheat, because you can't flip the coin
under your hand. This is the physical representation of the two ideas of
a commitment; everything that cryptographers call a commitment has those
two properties, but defended by very strong mathematical "guarantees"
(more on those quote marks shortly!), instead of by a crappy physical
analogue like a pressed-down hand:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Hiding&lt;/code&gt; - nobody but the committer can see or infer the actual
    value being committed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Binding&lt;/code&gt; - the committer can't change the value after the
    commitment is published.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The most "vanilla" way to implement this primitive is to use a
cryptographically secure hash function, say \(\mathbb{H}\). You'd
make up a random number \(r\) and combine it with your secret value
\(x\), and the commitment would just be something like
\(\mathbb{H}(x||r)\), where || indicates just concatenating the
data together.&lt;/p&gt;
&lt;p&gt;For background, commitments are usually defined in the literature as a
tuple of three algorithms: Setup, Commit and Verify/Open, where the last
one needs the committing party to give what's called the "opening" of
the commitment as input. It should be clear what is meant when I say
that the "opening" of the above commitment is just literally the two
values \(x\) and \(r\). (It's like taking your hand off the coin in
our analogue).&lt;/p&gt;
&lt;p&gt;Because (cryptographically secure) hash-functions are
collision-resistant (avoiding technical definitions for brevity here),
you can't open a commitment you already made to \(x\), with a
different value \(x'\), i.e. as committer you can't cheat, because
even though you're free to make your cheating opening operation with any
\(r'\) you like (it wasn't published in advance), you just can't find
any combination \(x',r'\) such that
\(\mathbb{H}(x||r)=\mathbb{H}(x'||r')\). That's why you need a
proper, strong hash function - to make that computationally infeasible.&lt;/p&gt;
&lt;h2&gt;Homomorphic commitments&lt;/h2&gt;
&lt;p&gt;The strict definition of homomorphism requires going into group theory a
bit, which isn't needed here, but basically a homomorphism should be
thought of as a function that takes you from one group into another
while keeping the group operation intact (so it's closely related to
symmetry). A toy example would be the homomorphism from the group of
integers under addition (\(\mathbb{Z},+)\) to the group of integers
modulo two \(\mathbb{Z}_2\) (a very simple group!: two members: 0,
1; each is self-inverse; 0+1=1+0 = 1, 0+0=1+1 =0). What is that
homomorphism? It's just a function that returns 0 if the input integer
is even, and 1 if the input integer is odd. We lost everything about the
integers except their evenness/oddness but we kept the group operation.
Call that function \(f()\) and we clearly have \(f(a+b)=f(a)+f(b)\)
because even + odd = odd, odd + even = odd, even + even = odd + odd =
even.&lt;/p&gt;
&lt;p&gt;But homomorphisms need not collapse a larger group into a smaller one,
the "throw away everything except X" can still conceivably mean throwing
away nothing, i.e. mapping from one group to another with the same order
- and the homomorphism that's relevant to this discussion fits that
description: it translates members of the group of integers modulo
\(N\) under addition, to the group of elliptic curve points of order
\(N\), under elliptic curve point addition: \(a \in \mathbb{Z}_N
\ ; a \rightarrow aG\), where \(G\) is the so-called generator
point of the elliptic curve (exactly which point on the curve is taken
for this role is irrelevant, but the definition has to include one, and
we call it \(G\)), and implicit in the notation \(aG\) is the fact
that it means a &lt;em&gt;scalar multiplication&lt;/em&gt; of \(G\) by \(a\), i.e.
\(G\) added to itself \(a\) times.&lt;/p&gt;
&lt;p&gt;In Bitcoin, the curve in question is secp256k1, but that's not important
here (except perhaps the fact that \(N\) is prime, meaning both groups
are isomorphic to the cyclic group of order \(N\)).&lt;/p&gt;
&lt;p&gt;So this is all getting technical, but all it really boils down to is
\((a+b)G = aG + bG\) is an equation that holds, here.&lt;/p&gt;
&lt;p&gt;What about commitments? We can treat the above homomorphism as &lt;em&gt;similar&lt;/em&gt;
to a cryptographic hash function, in that we can &lt;em&gt;assume&lt;/em&gt; that it's not
possible to derive the integer \(a\) given only the curve point
\(aG\) - this assumes that the "elliptic curve discrete logarithm
problem" is hard (ECDLP for short; also, that's kind of the definition
of that problem).&lt;/p&gt;
&lt;p&gt;In making that assumption, we can go ahead and apply the same paradigm:
take a random \(r\) for hiding, then take a second generator point
\(H\) and write our commitment as \(xG + rH\) (addition not
concatenation; publishing the two curve points separately would defeat
the purpose; \(r\) is supposed to be helping to hide \(x\)!).&lt;/p&gt;
&lt;p&gt;And we note how the homomorphism between an integer and the scalar
multiple of \(G\) by that integer carries over to this composite case
of the sum of two points: \(x_{1}G + r_{1}H + x_{2}G + r_{2}H =
(x_{1}+x_{2})G + (r_{1}+r_{2})H\).&lt;/p&gt;
&lt;p&gt;So it means the commitments, which we can denote \(C(x, r)\) for
brevity, &lt;strong&gt;are homomorphic&lt;/strong&gt; too. The sum of two commitments is equal to
the commitment to the sum (in this sentence, notice how "sum" refers to
the sum of two integers; but the homomorphism allows that to "carry
over" to "sum" as in elliptic curve point addition). Algebraically we
can condense it to: \(C(x_1,r_1)+C(x_2,r_2) =
C(x_{1}+x_{2},r_{1}+r_{2})\).&lt;/p&gt;
&lt;p&gt;This specific form of commitment is known as the &lt;strong&gt;Pedersen
commitment&lt;/strong&gt;. It is most commonly referred to in the finite field, non
elliptic curve form (where \(C=g^{x}h^{r}\) rather than \(C=xG +
rH\)), but it's the same thing.&lt;/p&gt;
&lt;p&gt;And to re-emphasise what at this point should be obvious - &lt;strong&gt;none&lt;/strong&gt; of
the above applies to commitments built with cryptographic hash
functions.&lt;/p&gt;
&lt;h2&gt;Imperfect commitments&lt;/h2&gt;
&lt;p&gt;The first imperfection in the idea above of the Pedersen commitment: the
second generator point \(H\). In practice it has been calculated in a
&lt;a href="https://en.wikipedia.org/wiki/Nothing_up_my_sleeve_number"&gt;NUMS&lt;/a&gt;
way, using some kind of hash of the defined generator point \(G\). The
idea is that if this hash function \(\mathbb{H}\) is secure as
described above, \(H\) cannot be reverse-engineered such that its
discrete log (that's to say, \(\gamma\) s.t. \(H=\gamma G\)). And
while this seems like a side-note, we can use this to lead in to the
subtleties which are the main topic of this blog post.&lt;/p&gt;
&lt;p&gt;Consider (and this is an excellent exercise for those &lt;em&gt;somewhat&lt;/em&gt;
familiar with basic elliptic curve operations as used in Bitcoin and
similar, but not yet seasoned in it): if you secretly knew that
\(\gamma\) and no one else did, and Pedersen commitments were being
used, how could you use this knowledge to gain advantage?&lt;/p&gt;
&lt;p&gt;(Spoiler space)&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;The answer is that the a commitment would lose its &lt;strong&gt;binding&lt;/strong&gt; property.
Remember: the binding property is the defence the receiver/verifier of
the commitment has against the creator/committer. So you would be able
to make a commitment randomly - just take any random "private key", call
it \(y\), and publish its "public key" point \(yG\) as \(C\). Then
when asked to verify later, you could pretend that you had bound this
commitment to any \(x\) as follows: Take your newly chosen \(x\),
and calculate what \(r\) has to be for that to work:&lt;/p&gt;
&lt;p&gt;\(xG + rH = C\)
\(xG + r\gamma G = yG\)
\(\therefore\)
\(r = \gamma^{-1}(y-x)\)&lt;/p&gt;
&lt;p&gt;There are two thoughts that may spring out of this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Pedersen commitment then, is only sound in as much as the relative
    discrete log between \(H\) and \(G\) is unknown. And as is often
    discussed, the aforementioned ECDLP is almost certainly broken by a
    sufficiently powerful quantum computer (although there might
    conceivably other ways to compute a discrete log quickly, as yet
    unknown to mathematicians). We say that Pedersen commitments are
    only &lt;span style="text-decoration: underline;"&gt;computationally
    binding&lt;/span&gt; - this means, only binding inasmuch as breaking their
    binding requires an unrealistic amount of computational power - to
    an adversary with infinite computing power, they are &lt;strong&gt;not&lt;/strong&gt;
    binding, at all.&lt;/li&gt;
&lt;li&gt;You may think - what about hiding? Surely knowing this "secret
    unlocking key" \(\gamma\) can break that as well. The answer is
    an emphatic &lt;strong&gt;no&lt;/strong&gt; - but what might be really surprising is: &lt;em&gt;the
    answer is no in the case of hiding for exactly the same reason that
    the answer is yes, in the case of binding!&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I'm first going to explain that formally, but then we'll take a step
back, and use a picture and perhaps some examples to flesh out what's
really going on here, because it's the heart of the story we're telling.&lt;/p&gt;
&lt;p&gt;The reason hiding is not lost is because an adversary on the
receiving/verifying side who wants to "sneak peek" inside \(C\) to
find out the real \(x\) faces an insurmountable problem: &lt;span
style="text-decoration: underline;"&gt;there isn't only one answer!&lt;/span&gt;.
If the answer is \(x\) then the \(r\) value is, as already
explained, \(\gamma^{-1}(y-x)\). Remember, a computationally unbound
attacker can find those discrete logs - can get \(y\) from \(C\),
and can get \(\gamma\) from \(H\). So &lt;em&gt;any&lt;/em&gt; \(x\) will have a
corresponding \(r\). And of course you can flip it backwards - if he
fixes a particular \(r\) he can get the corresponding \(x\). Where
is this slipperiness coming from? What's it's fundamental cause?&lt;/p&gt;
&lt;p&gt;Think about functions. They take inputs to outputs of course, and we
generalise by talking about input spaces and output spaces (by "space"
here I mean something like "the set of all..."). The technical terms
used are domain/range and sometimes preimage space and image space. The
input space for the private-&amp;gt;public key "function" in Bitcoin is of
course the set of all integers modulo \(N\). And then output space is
the set of all public keys, which is the set of all points on the curve
secp256k1. Here we have what's called a "one-one" mapping (technically
it's both "one-one" and also "onto", since all points in the output
space are mapped to). But only "nice" functions are like that, not all
are. Some, in particular, have &lt;strong&gt;more than one input corresponding to
the same output&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;And that's exactly what's happening with the Pedersen commitment;
moreover, there's a very concrete reason &lt;em&gt;why&lt;/em&gt; the Pedersen commitment
has that property of having multiple inputs for the same output - it
logically has to! Consider this diagram:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://web.archive.org/web/20200428225915im_/https://joinmarket.me/static/media/uploads/.thumbnails/InputOutput1.png/InputOutput1-689x487.png" width="689" height="487" alt="Input space larger than output space" /&gt;&lt;/p&gt;
&lt;p&gt;By the &lt;a href="https://en.wikipedia.org/wiki/Pigeonhole_principle"&gt;pigeonhole
principle&lt;/a&gt;,
because there are more inputs than outputs, it's impossible for it &lt;em&gt;not&lt;/em&gt;
to be the case that at least some outputs have more than one
corresponding input - they wouldn't all "fit" otherwise. And it's for
this reason that &lt;span style="text-decoration: underline;"&gt;a commitment
scheme where the input space is larger than the output space can have
perfect hiding.&lt;/span&gt; (notice "can", not "will" - for the hiding to be
*perfect* we need to be leaking zero information about which element
of the input space is being hidden; that needs it to be the case that we
can demonstrate that *any* element of some very large subset of the
input space is part of a valid opening of a given commitment \(C\);
that's true here in Pedersen, but certainly not for some other
commitment schemes).&lt;/p&gt;
&lt;p&gt;And for the exact same reason, the binding is only computational - there
are bound to be at least some outputs with more than one input, and so
if nothing else, by exhaustive search, the computationally unbounded
attacker can simply search and find the other input corresponding to the
same output (as per the diagram, if the attacker had the value \(k\)
as commitment, he could find \(x_2, r_2\) even if the commitment was
originally to \(x_1, r_1\). At least that'll be true for &lt;em&gt;some&lt;/em&gt;
outputs (in Pedersen, for every output, in fact).&lt;/p&gt;
&lt;p&gt;So the Pedersen commitment falls neatly into this category; it has an
input space of 512 bits if the message \(x\) and randomness \(r\)
are both the same size as the group elements and an output space of 256
bits (almost exactly); the outputs \(C\) are the points on the
secp256k1 curve.&lt;/p&gt;
&lt;p&gt;(You'll notice how technically "exhaustive search" may not be the actual
process - there can be shortcuts depending on how the commitment is
structured; in the case of Pedersen, because it hinges on the unknown
discrete log \(\gamma\), the attacker can leverage that - he can use
that knowledge to find these "other inputs" directly instead of by
exhaustive search).&lt;/p&gt;
&lt;p&gt;What if the input space is &lt;em&gt;smaller&lt;/em&gt; than the output space? It takes a
moment of reflection to realise that this idea doesn't make sense. A
function has a single output by definition (note that doesn't mean the
output can't be multiple "things", e.g. it could be 4 integers or 6
curve points or 5 triangles, whatever - but each of them is a single
output). So a function with 10 inputs can't have more than 10 outputs.
Which means we have one case remaining:&lt;/p&gt;
&lt;p&gt;What if the input space is &lt;em&gt;the same size as &lt;/em&gt;the output space?&lt;/p&gt;
&lt;p&gt;&lt;img src="https://web.archive.org/web/20200428225915im_/https://joinmarket.me/static/media/uploads/.thumbnails/InputOutput2.png/InputOutput2-688x487.png" width="688" height="487" alt="Input and output space equal size" /&gt;&lt;/p&gt;
&lt;p&gt;In this case we must have a one-one mapping - again by the pigeonhole
principle (Remember, we are defining the output space as the space of
actual possible outputs, not some larger set; this will usually require
justification - you can justify it here by first considering the second
commitment point \(C_2=rG\) - note that the lines are horizontal for
a reason!). And by the same reasoning as above, but in reverse, we see
that this gives &lt;strong&gt;perfect&lt;/strong&gt; binding, and &lt;strong&gt;at best
computational(imperfect) hiding.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;What's neat about this reasoning is that none of it is specific to
anything elliptic curve, or discrete log related, or anything - it
applies to &lt;em&gt;any&lt;/em&gt; commitment scheme, including the hash-based one we
introduced right at the start. The only difference between the Pedersen
and hash-based case is because of the messiness mathematically of hash
functions, we can't really talk about perfection; it's only the
limitations, the negative parts of the above logic, that are the same:&lt;/p&gt;
&lt;p&gt;If your output space is the space of SHA256 outputs, then it's 256 bits.
Now according to specification, that hash function can take extremely
large input (I forget exactly, but vastly larger than 256 bits), which
means it is in the first category - its input space is vastly larger
than its output space, so it &lt;strong&gt;cannot&lt;/strong&gt; be perfectly binding. But that
&lt;em&gt;doesn't&lt;/em&gt; mean that it's perfectly hiding, unfortunately - that would
require that a given output leaks precisely zero information about the
corresponding input. But it's certainly not the case that we have some
theorem about SHA256 that ensures that every input is equiprobable,
given an arbitrary output. So at &lt;em&gt;best&lt;/em&gt; we have computational hiding,
and that's based on the idea tha the hash function is well designed. See
&lt;a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function"&gt;Wikipedia&lt;/a&gt;
for a reminder on the key properties of cryptographic hash functions.
These properties are also what provides the argument for at least a
computational binding. But again, it's certainly not perfectly either
hiding &lt;em&gt;or&lt;/em&gt; binding.&lt;/p&gt;
&lt;p&gt;So let's summarize the key insight:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;It's LOGICALLY impossible for a commitment scheme to be both perfectly
hiding and perfectly binding, no matter what algorithm or mathematical
architecture is used to construct it.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Why "logically"? Because we've demonstrated the two ideas are
fundamental contradictions of each other; it is only confusion to think
you can get both at the same time. Another way to say it (slightly more
dynamic description):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A commitment scheme which has been constructed to have perfect binding
will at BEST achieve computational hiding, while a scheme constructed to
achieve perfect hiding will at BEST achieve computational binding.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here we're emphasizing that these are the limits, only achieved by well
designed algorithms; a badly designed or not-fit-for-purpose commitment
scheme may not be perfect in &lt;em&gt;either&lt;/em&gt; sense, and for example may not
even manage to be computationally hiding, e.g. an adversary may very
feasibly be able to break the hiding property without excessive
computational resources. This is just a description of the &lt;em&gt;best&lt;/em&gt; we can
do.&lt;/p&gt;
&lt;h2&gt;From hidden to bound&lt;/h2&gt;
&lt;p&gt;We'll get into the Bitcoin-related application shortly, but for now note
that is not unreasonable to prefer binding over hiding in the trade-off.
Since clearly Pedersen doesn't fit there, what does?&lt;/p&gt;
&lt;p&gt;Let's start with an almost-obvious idea: suppose I want to commit to a
value \(x\) and have it be perfectly binding. Can I just use
\(C=xG\) as the commitment?&lt;/p&gt;
&lt;p&gt;If you've been following along, you'll probably be a little uncertain,
because .. the "hiding" part doesn't seem to have been implemented.
You're right to be uncertain, because the answer is really "formally no,
but it kinda depends".&lt;/p&gt;
&lt;p&gt;There are two scenarios: if the set of values you might commit to is
restricted in some way, e.g. a number between 1 and \(2^{25}\) then
the lack of hiding makes the commitment a complete failure, because a
computer could just find it by brute force guessing. And if your \(x\)
was a random value in the entire range \(2^{256}\) of elements of the
group - this kind of construction &lt;em&gt;is&lt;/em&gt; sometimes used as a commitment,
but it doesn't count as a proper, generic commitment &lt;em&gt;scheme&lt;/em&gt;, because
it doesn't have even computational hiding in the general case; if I
&lt;em&gt;think&lt;/em&gt; I know what your \(x\) is (or know the range of it), I can
just check if I'm right; there is no blinding value \(r\) to prevent
that.&lt;/p&gt;
&lt;p&gt;This naturally leads us to the &lt;a href="https://en.wikipedia.org/wiki/ElGamal_encryption"&gt;ElGamal encryption
scheme&lt;/a&gt;,
re-purposed as a commitment scheme (this can be done with any
cryptosystem, by the way):&lt;/p&gt;
&lt;p&gt;Take our usual suspects \((x, r)\) and construct &lt;strong&gt;two&lt;/strong&gt; elliptic
curve points: \((xG+rH, rG)\). This is the ElGamal commitment (with
all notation as for Pedersen). Wait, I hear you cry - you're just
regurgitating the Pedersen commitment, but adding \(rG\)? What does
that mean? Well, we're taking the slightly broken idea above and
applying it &lt;em&gt;in conjunction with&lt;/em&gt; the idea of the Pedersen commitment.
We "commit" to the value \(r\) using \(rG\), and that's OK
specifically because \(r\) is a random number in the range (a bit like
a "nonce") used just for this commitment, so there is no guessing it
outside the standard brute force or breaking ECDLP; by doing so we've
increased the &lt;strong&gt;output space&lt;/strong&gt; from Pedersen's set of single curve
points to the Cartesian product of 2 sets of curve points. And we by
doing so arrive at the second of the two scenarios described in the two
diagrams above; now, for each input tuple \((x, r)\), there is an
output tuple \((C_1,C_2) = (xG+rH,rG)\) - guaranteed distinct
because the mapping from \(r\) to \(rG\) is one-one - so the mapping
is one-one and is perfectly binding. More simply: the task of the
adversary who wants to break the commmitment by opening it to a
different value than originally chosen is now impossible: for \(rG\)
there is precisely one and only one \(r\), and once \(r\) is set,
there is only one \(x\): it's the discrete log of \(C_1 -rH\) which
is now uniquely defined, once \(r\) is.&lt;/p&gt;
&lt;p&gt;And, following our insights above, it is now decidely unsurprising to
learn that the described ElGamal commitment is only computationally
hiding: because \(rG\) is published as a separate curve point
\(C_2\) and not folded into the single curve point as with Pedersen,
an attacker with the ability to solve the discrete log problem can
extract, from that, \(r\) and then follow up by extracting from
\(C_1 - rH=xG\), the supposedly hidden committed value \(x\).&lt;/p&gt;
&lt;p&gt;But let's be clear: it &lt;em&gt;is&lt;/em&gt; computationally hiding, unlike our toy
"quasi-commitment" \(xG\) which fails at that task (imagine committing
to the value "2"). And that can be expressed formally with what's called
a "reduction proof"; a rather weird but also very clever concept often
used in cryptography:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;The ElGamal commitment is hiding if the DDH problem is hard,&lt;/span&gt;
&lt;span class="err"&gt;because an adversary who can violate the hiding property of the ElGamal&lt;/span&gt;
&lt;span class="err"&gt;commitment can use that algorithm to solve the DDH problem.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;DDH refers to the &lt;a href="https://en.wikipedia.org/wiki/Decisional_Diffie%E2%80%93Hellman_assumption"&gt;Decisional Diffie Hellman
problem&lt;/a&gt;
- in words, it's that you can't distinguish \(abG\) from a random
curve point, even if you already know the values of \(A,B\) where
\(A=aG, B=bG\).&lt;/p&gt;
&lt;p&gt;The intended consequence of this reasoning (and notice how slippery this
logic is!) is to say: DDH is &lt;em&gt;actually&lt;/em&gt; hard, therefore ElGamal is
computationally hiding. Or: since it&lt;em&gt;is&lt;/em&gt; believed that DDH is hard, it
follows that "we" (some undefined group of cryptographers) believe that
ElGamal, as a commitment scheme, is computationally hiding.&lt;/p&gt;
&lt;h3&gt;Brief observation: ElGamal is homomorphic&lt;/h3&gt;
&lt;p&gt;Notice how the description of the homomorphic (with respect to addition)
property of the Pedersen commitment cross applies here; even though we
have two curve points here, not one, the same linearity exists:&lt;/p&gt;
&lt;p&gt;\(C_{EG}(x_1, r_1) + C_{EG}(x_2, r_2) = \)&lt;/p&gt;
&lt;p&gt;\((x_1G + r_1H, r_1G) + (x_2G + r_2H, r_2G)\)&lt;/p&gt;
&lt;p&gt;\( = ((x_1 + x_2)G + (r_1+r_2)H, (r_1+r_2)G)\)&lt;/p&gt;
&lt;p&gt;\( = C_{EG}(x_1+x_2, r_1+r_2)\)&lt;/p&gt;
&lt;h2&gt;An unpalatable tradeoff?&lt;/h2&gt;
&lt;p&gt;So all of the above is the "behind the scenes" of the discussion you'll
often see in public about &lt;a href="https://elementsproject.org/features/confidential-transactions/investigation"&gt;Confidential
Transactions&lt;/a&gt;
in Bitcoin, specifically (not that the tradeoff doesn't apply in other
systems like Monero of course).&lt;/p&gt;
&lt;p&gt;We naturally choose the Pedersen commitment for Confidential
Transactions, because it's more compact (remember - size of output
space!). It's only one curve point as output. Confidential Transactions
take up a non-trivial amount of extra space in a transaction, so it's
natural to prefer Pedersen to ElGamal for that reason, even though,
importantly, &lt;span style="text-decoration: underline;"&gt;both have the
necessary homomorphic property&lt;/span&gt; as already outlined.&lt;/p&gt;
&lt;p&gt;Moreover (and more importantly, actually), a CT output needs a &lt;em&gt;range
proof&lt;/em&gt; (as explained in great detail e.g.
&lt;a href="https://github.com/AdamISZ/ConfidentialTransactionsDoc/"&gt;here&lt;/a&gt;,
see also bulletproofs e.g.
&lt;a href="https://eprint.iacr.org/2017/1066.pdf"&gt;here&lt;/a&gt;
and
&lt;a href="https://github.com/AdamISZ/from0k2bp"&gt;here&lt;/a&gt;),
which itself requires a &lt;em&gt;lot&lt;/em&gt; of space - the range proofs described in
the link, especially bulletproofs, go to a lot of trouble to condense
this data to the greatest extent possible, since it must be published on
the blockchain for all to verify, but that space usage is a serious
issue.&lt;/p&gt;
&lt;p&gt;The previous links point to all the work done on space optimisation for
Pedersen; if we switched to ElGamal we'd lose that (I'm not exactly sure
&lt;em&gt;where&lt;/em&gt; we'd be in terms of how much space a CT style output would take
up, but it would definitely be considerably more. While writing this
I've noticed Andreev has written up an ElGamal range proof
&lt;a href="https://blog.chain.com/preparing-for-a-quantum-future-45535b316314"&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Hence the title of the subsection; our choice in CT for something like
Bitcoin seems to be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Continue on the existing path - highly space optimised Pedersen
    commitments with perfect hiding and computational binding under the
    ECDLP assumption.&lt;/li&gt;
&lt;li&gt;Switch to ElGamal commitments, with much more bloaty range proofs
    and commitments, which however have perfect binding and
    computational hiding (under DDH assumption).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some people might argue that there is just too much fuss and worry about
this. Computational is good enough, if our crypto hardness assumptions
are good enough, and they are kind of industry standard already. However
there's a big problem with this reasoning, and it was explained in the
"tradeoffs" section of
&lt;a href="https://joinmarket.me/blog/blog/the-steganographic-principle"&gt;this&lt;/a&gt;
earlier blog post. To avoid getting sidetracked on that now, let me
summarize simply:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;A break in the binding assumption of Confidential Transactions can
result in the attacker being able to print money in arbitrary amounts
at any time, with absolutely no knowledge by the outside world.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As I was at pains to point out in the linked blog post, this problem is
not CT-specific; it's generic to any blinding mechanism relying on
cryptographic hardness assumptions (i.e. without &lt;strong&gt;perfect binding&lt;/strong&gt; or
something analogous where even an infinitely powerful adversary cannot
violate the binding of the blinded amount).&lt;/p&gt;
&lt;p&gt;But here (for the rest of this blog post) we'll focus specifically on
the CT version of the problem.&lt;/p&gt;
&lt;h2&gt;The unexcluded middle&lt;/h2&gt;
&lt;p&gt;If perfect binding and hiding are logically incompatible in a
commitment, our only choice to violate the principle of the excluded
middle is to step outside the boundaries of the problem described, and
the most natural way to do that is to use two different commitments.&lt;/p&gt;
&lt;p&gt;Using both Pedersen and ElGamal concurrently makes so little sense as to
be incoherent, not least because an ElGamal commitment &lt;em&gt;contains&lt;/em&gt; a
Pedersen commitment. But the key word you could have skipped over in
that sentence was &lt;strong&gt;concurrently&lt;/strong&gt;. Ruffing and Malavolta in &lt;a href="https://eprint.iacr.org/2017/237.pdf"&gt;this
paper&lt;/a&gt;
suggest spreading the problem over time:&lt;/p&gt;
&lt;h2&gt;Switch commitments&lt;/h2&gt;
&lt;p&gt;The idea here is deceptively simple: what if you use an ElGamal
commitment, but don't verify the non-Pedersen component (the second
point \(rG\) to use consistent notation) initially. If there is some
time \(T\) at which all participants in the system agree that the
ECDLP has "fallen" to quantum computing (the most well discussed failure
vector of elliptic curve crypto), it could be required that after that
flag day, spending of coins (presumably into some safer new cryptosystem
defined by consensus; spending into current-style Bitcoin outputs would
probably not make sense, here) is only valid if the verification/opening
(and the range proof) were applied to the full ElGamal commitment
\(xG+rH, rG\) and not just \(xG+rH\) as was allowed before \(T\).&lt;/p&gt;
&lt;p&gt;There are two critiques that may immediately spring to mind, one obvious
and one not:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Not necessarily a realistic scenario - the break may be very public
    or not, it may be very gradual or not. Declaring a flag day is
    mostly assuming it being public. So it's not a panacea.&lt;/li&gt;
&lt;li&gt;If you've been reading closely all this time, you'll be alert to a
    serious drawback: publishing an ElGamal commitment will not actually
    be hiding, if ECDLP is "cracked" (you remember that it requires DDH
    hardness, but it's easy to see that if you "crack" ECDLP you also
    crack DDH).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Taking a more positive perspective, though: it's not as if \(T\) has
to be a "panic stations day". Just as hash functions and TLS versions
are sometimes retired because they &lt;em&gt;start&lt;/em&gt; to show just a &lt;em&gt;tiny&lt;/em&gt; bit of
weakness, it would similarly make perfect sense for Bitcoin to be
similarly prompt in making a switch to a post-quantum cryptosystem once
EC came into question, and not wait to be attacked. Not to say it would
be easy!&lt;/p&gt;
&lt;p&gt;This approach is sometimes called "cryptographic agility" - awkward as
it seems, we do kinda want the ability to upgrade cryptographic
protocols "in-flight", while they are being used.&lt;/p&gt;
&lt;p&gt;So at this point we have an ingenious and smart &lt;em&gt;amelioration&lt;/em&gt; to the
problem, but it can't be called a complete solution, I think - and
principally because of the (admittedly tiny) possibility of a private
break by some lone genius or similar.&lt;/p&gt;
&lt;h3&gt;We put a commitment inside your commitment, so ...&lt;/h3&gt;
&lt;p&gt;The authors and collaborators of the switch commitment paper and idea
(Ruffing, Malavolta, Wuille, Poelstra, others .. I'm not actually sure)
found a way to slightly improve the properties of such switch
commitments: a structure they call the &lt;strong&gt;opt-in switch commitment&lt;/strong&gt;
which looks something like this:&lt;/p&gt;
&lt;p&gt;\(xG + (r+\mathbb{H}(xG+rH || rG))H = xG + r'H\)&lt;/p&gt;
&lt;p&gt;The idea is to tweak the blinding component of a standard Pedersen
commitment with the hash of an ElGamal commitment to the same value
(insert old meme as appropriate). Those of you aware of such things may
instantly recognize a close parallel with ideas like pay-to-contract and
&lt;a href="https://bitcoinmagazine.com/articles/taproot-coming-what-it-and-how-it-will-benefit-bitcoin/"&gt;taproot&lt;/a&gt;
(the latter was inspired by the former, so no surprise there). We're
effectively committing to a "contract" which here is a promise to open
to an ElGamal commitment &lt;em&gt;later,&lt;/em&gt; if the consensus calls for it, while
for now not revealing that contract, as it's hidden/blinded with the
value \(r\).&lt;/p&gt;
&lt;p&gt;As noted &lt;a href="https://lists.launchpad.net/mimblewimble/msg00479.html"&gt;on the mimblewimble mailing
list&lt;/a&gt;
by Ruffing, this has a couple of very important advantages over the
non-opt-in version:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It preserves the perfect hiding of the Pedersen commitment for as
    long as the flag day \(T\) isn't reached (it's exactly a Pedersen
    commitment until then).&lt;/li&gt;
&lt;li&gt;It doesn't use up another curve point on the blockchain - you only
    publish the single curve point as per Pedersen, and not two as per
    ElGamal.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(Another useful feature - you can derive the value of \(r\) from your
private key deterministically to make it more practical).&lt;/p&gt;
&lt;p&gt;Of course one must prove it's secure (under the random oracle model) but
for now I'll take that as a given (it's too much detail for here). But
clearly this is a neat way to encapsulate that "switch" idea; modulo
security proofs, it's an unqualified and very substantial improvement
over the "naked ElGamal" version.&lt;/p&gt;
&lt;h3&gt;A hard decision for the sleepy or lazy&lt;/h3&gt;
&lt;p&gt;There is still an area of imperfection even in this souped-up "opt-in"
switch commitment case. After the flag day \(T\) if you still have not
moved coins from existing outputs, you can publish the ElGamal
"contract" (commitment) inside the hash, thus keeping the binding
property, so that the envisioned attacker-possessing-a-quantum-computer
will still not be able to print money, but in so doing, you give up the
hiding (the value is revealed &lt;em&gt;at least to such attackers&lt;/em&gt; because they
can break the DDH problem). So thus a person failing to take action
before said deadline \(T\) has at least to risk, and probably lose,
one of those two: their privacy of amount or their money.&lt;/p&gt;
&lt;h2&gt;Have your cake and eat it?&lt;/h2&gt;
&lt;p&gt;Is it possible to do better than such a transition approach, as
envisaged in the switch commitments paradigm?&lt;/p&gt;
&lt;p&gt;As was earlier discussed, it suffers from not covering every threat
scenario, in particular, it does not cover the scenario of a private and
unexpected break.&lt;/p&gt;
&lt;p&gt;Unfortunately this is where this very long blog post trails off ...
because I don't know, and currently I don't think anyone else does.&lt;/p&gt;
&lt;p&gt;My personal feeling was that the switch commitment paradigm suggests
there might be a way to finesse this tradeoff about using commitments.
And it also seems to be something which Adam Back seems to have gone
some way to thinking through - the fact that a single commitment scheme
can't provide perfect hiding and binding for a single value doesn't
imply that it is impossible to get this property, &lt;strong&gt;as long you're not
working with the same value&lt;/strong&gt;. For example, what if you could provide an
ElGamal commitment for the money created in a Bitcoin &lt;em&gt;block&lt;/em&gt;, while
providing Pedersen commitments as in the current design of CT for the
individual transactions? This means that a quantum or ECDLP breaking
attacker can "snoop" into the overall value created in a block, but this
should either be already known or uninteresting, while although he could
in theory violate the binding property of individual transactions, this
would in turn violate the binding of the block-level commitment which is
supposed to be impossible?&lt;/p&gt;
&lt;p&gt;I suspect my original line of thinking is somehow incoherent (how,
mathematically, are the block-level and transaction-level commitments
related?), but Dr Back seems to have in mind something involving
coinjoin-like interactivity. I am leaving it here without attempting to
describe further, because the question seems to continue to be
interesting and if there &lt;em&gt;is&lt;/em&gt; a solution (even perhaps if it involves
interactivity), it would be a hugely important fact, making CT a much
more plausible technology for a global money.&lt;/p&gt;
&lt;h3&gt;Build the wall?&lt;/h3&gt;
&lt;p&gt;We could also take the Trumpian approach - it's far from infeasible to
imagine that there is a mechanism that prevents CT coins arriving back
into plaintext area without allowing any hidden inflation that &lt;em&gt;might&lt;/em&gt;
occur to "infect". This is essentially the sidechain model, except it
could be implemented in a variety of different ways. In fact, this
&lt;strong&gt;model already does exist&lt;/strong&gt; in the sidechain
&lt;a href="https://blockstream.com/liquid/"&gt;Liquid&lt;/a&gt;,
which uses CT. But there have also been proposals to implement CT as a
kind of extension block (which has slightly different tradeoffs to a
sidechain), for example see ZmnSCPxj's note
&lt;a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-January/016605.html"&gt;here&lt;/a&gt;&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="cryptography"></category><category term="bitcoin"></category></entry><entry><title>Payjoin</title><link href="https://joinmarket.me/blog/blog/payjoin/" rel="alternate"></link><published>2018-12-15T00:00:00+01:00</published><updated>2018-12-15T00:00:00+01:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2018-12-15:/blog/blog/payjoin/</id><summary type="html">&lt;p&gt;coinjoins in payments&lt;/p&gt;</summary><content type="html">&lt;h3&gt;PayJoin&lt;/h3&gt;
&lt;h2&gt;PayJoin.&lt;/h2&gt;
&lt;p&gt;You haven't read any other blog posts here? No worries, here's what
you need to know (&lt;em&gt;unless you're an expert, read them anyway...&lt;/em&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A utxo is an "unspent transaction output" - a Bitcoin transaction
    creates one or more of these, and each contains a specific amount of
    Bitcoin. Those outputs get "used up" in the transaction that
    spends them (somewhat like physical coins, someone gives you them in
    a payment to you, then you give them to someone else when you spend
    them; bitcoins aren't coins, utxos are coins; only difference is
    physical coins don't get destroyed in transactions).&lt;/li&gt;
&lt;li&gt;The fees you have to pay for a Bitcoin transaction depend on how
    many bytes it takes up; this is *somewhat* dominated by how many
    inputs you provide, although there are other factors.&lt;/li&gt;
&lt;li&gt;CoinJoin basically means - two or more people provide inputs (utxos)
    to a transaction and co-sign without needing trust, because when
    they sign that the output amounts and addresses are what they
    expect. &lt;strong&gt;Note that CoinJoin requires interaction, almost always.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Traditional "equal-sized" CoinJoin means a bunch of people paying
    &lt;em&gt;themselves&lt;/em&gt; the same fixed amount in a single transaction
    (according to the process just mentioned), with the intention that
    nobody can tell which of the equal sized outputs belong to who
    (basically!).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;The drawbacks of CoinJoin as implemented&lt;/h2&gt;
&lt;p&gt;Current implementations of CoinJoin are of the "equal-sized" variety
(see above). This requires coordination, but it's possible to get a
decent number of people to come together and agree to do a CoinJoin of a
certain fixed amount. The negative is that this kind of transaction is
trivially distinguishable from an "ordinary" transaction, in
particular a payment from one counterparty to another. Here's a typical
Joinmarket CoinJoin (and other implementations are just as, or more,
distinguishable):&lt;/p&gt;
&lt;p&gt;&lt;img alt="Equal-outs-coinjoin-example" src="/web/20200803124759im_/https://joinmarket.me/static/media/uploads/.thumbnails/screenshot_from_2019-01-18_15-00-33.png/screenshot_from_2019-01-18_15-00-33-807x433.png"&gt;{width="807"
height="433"}&lt;/p&gt;
&lt;p&gt;The biggest flag of "this is CoinJoin" is exactly the multiple
equal-value (0.18875417 here) outputs that are the core premise of the
idea, that give the anonymity. Here, you get anonymity in an "anonymity
set" of all participants of &lt;em&gt;this&lt;/em&gt; transaction, first, but through
repeated rounds, you &lt;em&gt;kind of&lt;/em&gt; get a much bigger anonymity set,
ultimately of all participants of that CoinJoin implementation in the
absolute best scenario. But it's still only a small chunk of Bitcoin
usage generally.&lt;/p&gt;
&lt;p&gt;And while this obviously gets better if more people use it, there is a
limit to that thinking: because &lt;strong&gt;all participants are forced to use the
same denomination for any single round&lt;/strong&gt;, it isn't possible to fold in
the payments you're doing using Bitcoin as a currency (don't laugh!)
into these CoinJoin rounds (notice: this problem mostly disappears with
blinded amounts).&lt;/p&gt;
&lt;p&gt;So a world where "basically everyone uses CoinJoin" is cool for
privacy, but could end up pretty bad for scalability, because these
transactions are &lt;em&gt;in addition to&lt;/em&gt; the normal payments.&lt;/p&gt;
&lt;p&gt;Also, the fact that these transactions are trivially watermarked means
that, if the blockchain analyst is not able to "crack" and unmix such
transactions, he can at least isolate them in analysis. That's
something; "these coins went from Exchange A to wallet B and then into
this mixset" may be a somewhat negative result, but it's still a
result. There are even noises made occasionally that coins might be
blocked from being sent to certain exchange-type entities if they're
seen to have come from a "mixer" (doesn't matter that CoinJoin is
&lt;em&gt;trustless&lt;/em&gt; mixing here; just that it's an activity specific for
obfuscation).&lt;/p&gt;
&lt;p&gt;I don't mean to scaremonger - I have used such CoinJoin for years
(measured in the thousands) and will continue to do so, and never had
payments blocked because of it. But this is another angle that must be
borne in mind.&lt;/p&gt;
&lt;p&gt;So let's say our primary goal is to minimize the negative privacy
effects of blockchain analysis; can we do better? It's debatable, but
we &lt;em&gt;do&lt;/em&gt; have another angle of attack.&lt;/p&gt;
&lt;h2&gt;Hiding in a much bigger crowd ... ?&lt;/h2&gt;
&lt;p&gt;[One angle is to make your behaviour look more like other, non-coinjoin
transactions]{style="text-decoration: underline;"}. (For the
philosophically/abstract inclined people, &lt;a href="https://web.archive.org/web/20200803124759/https://joinmarket.me/blog/blog/the-steganographic-principle/"&gt;this post might be of
interest&lt;/a&gt;,
but it sidetracks us here, so - later!). Let's think of the naive way
to do that. Suppose just Alice and Bob make a 2 party CoinJoin:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.05 BTC ---&amp;gt;| 0.05 BTC 3AliceSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.05 BTC ---&amp;gt;| 0.05 BTC 3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This first attempt is a clear failure - it "looks like an ordinary
payment" &lt;em&gt;only&lt;/em&gt; in the sense that it has two outputs (one change, one
payment). But the failure is not &lt;em&gt;just&lt;/em&gt; the obvious, that the output
amounts are equal and so "obviously CoinJoin". There's another aspect
of that failure, illustrated here:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.01 BTC ---&amp;gt;| 0.05 BTC 3AliceSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.04 BTC ---&amp;gt;| 0.06 BTC 3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.03 BTC ---&amp;gt;|&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.03 BTC ---&amp;gt;|&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This at least is &lt;em&gt;more&lt;/em&gt; plausible as a payment, but it shows the
&lt;strong&gt;subset sum&lt;/strong&gt; problem that I was describing in my &lt;a href="https://web.archive.org/web/20200803124759/https://joinmarket.me/blog/blog/coinjoinxt/"&gt;CoinJoinXT
post&lt;/a&gt;
- and trying to solve with CoinJoinUnlimited (i.e. using a Lightning
channel to break the subset sum problem and feed-back the LN privacy
onto the main chain). While the blockchain analyst &lt;em&gt;could&lt;/em&gt; interpret
this as a payment, semi-reasonably, of 0.05 btc by one participant, he
could also notice that there are two subsets of the inputs that add up
to 0.05, 0.06. And also splitting the outputs doesn't fundamentally
solve that problem, notice (they'd also have to split into subsets),
and it would anyway break the idea of "looking like a normal payment"
(one payment, one change):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.01 BTC ---&amp;gt;| 0.011 BTC 3AliceSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.04 BTC ---&amp;gt;| 0.022 BTC 3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.03 BTC ---&amp;gt;| 0.039 BTC 3Alice2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.03 BTC ---&amp;gt;| 0.038 BTC 3Bob2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;After you think about this problem for a while you come to the
conclusion - only if there's actually a transfer of coins from one
party to the other is it solved. Hence
&lt;a href="https://web.archive.org/web/20200803124759/https://joinmarket.me/blog/blog/coinjoinxt/"&gt;CoinJoinXT&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But also, hence &lt;strong&gt;PayJoin&lt;/strong&gt; - why not actually do a CoinJoin [while you
are making a payment?]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;[]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;h2&gt;PayJoin advantages&lt;/h2&gt;
&lt;p&gt;I'm not sure who first thought of doing CoinJoins (see bullet point at
start) of this particular flavour, but a &lt;a href="https://blockstream.com/2018/08/08/improving-privacy-using-pay-to-endpoint/"&gt;blogpost from Matthew
Haywood&lt;/a&gt;
last summer detailed an implementation approach which came out of a
technical workshop in London shortly before, and a little later a
&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki"&gt;BIP&lt;/a&gt;
was put out by Ryan Havar.&lt;/p&gt;
&lt;p&gt;The central idea is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Let Bob do a CoinJoin with his customer Alice - he'll provide at
    least one utxo as input, and that/those utxos will be consumed,
    meaning that in net, he will have no more utxos after the
    transaction than before, and an obfuscation of ownership of the
    inputs will have happened [without it looking different from an
    ordinary payment.]{style="text-decoration: underline;"}&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Before we look in detail at the advantages, it's worth answering my
earlier question ("Why not actually do a CoinJoin while you are making
a payment?") in the negative: it's not easy to coordinate that. It
means that either (a) all wallets support it and have a way for
*anyone* to connect to *anyone* to negotiate this (2-party) CoinJoin
or (b) it's only limited to peer to peer payments between owners of a
specific wallet that has a method for them to communicate. So let's be
clear: this is not going to suddently take over the world, but
incremental increases in usage could be tremendously valuable (I'll
explain that statement shortly; but you probably already get
it).[]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Advantage 1: Hiding the payment amount&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is what will immediately stand out from looking at the idea. Bob
"chips in" a utxo (or sometimes more than one). So the payment
&lt;em&gt;output&lt;/em&gt; will be more than the actual payment, and it will be profoundly
unobvious what the true payment amount was. Here's an example:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.05 BTC ---&amp;gt;| 0.04 BTC 3AliceSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.09 BTC ---&amp;gt;| 0.18 BTC 3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.08 BTC ---&amp;gt;|&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Now, actually, Alice paid Bob 0.1 BTC using 0.09 and 0.05, getting back
0.04 change. But what does a blockchain analyst think? His first
interpretation will certainly be that there is a payment &lt;em&gt;either&lt;/em&gt; of
0.04 BTC or 0.18 BTC, by the owner of the wallet containing all the
inputs. Now, it probably seems very unlikely that the &lt;em&gt;payment&lt;/em&gt; was 0.04
and the &lt;em&gt;change&lt;/em&gt; 0.18. Why? Because, if the payment output were 0.04,
why would you use all three of those utxos, and not just the first, say?
(0.05). This line of reasoning we have called "UIH1" in the comments
to &lt;a href="https://gist.github.com/AdamISZ/4551b947789d3216bacfcb7af25e029e"&gt;this
gist&lt;/a&gt;
(h/t Chris Belcher for the nomenclature - "unnecessary input
heuristic") for the details. To be fair, this kind of deduction by a
blockchain analyst is unreliable, as it depends on wallet selection
algorithms; many are not nearly so simplistic that this deduction would
be correct. But possibly combined with wallet fingerprinting and
detailed knowledge of wallet selection algorithms, it's one very
reasonable line of attack to finding the change output and hence the
payment output.&lt;/p&gt;
&lt;p&gt;For those interested in the "weeds" I've reproduced the key points
about this UIH1 and UIH2 (probably more important) including stats
collected by LaurentMT of oxt.me, in an "Appendix" section at the end
of this post.&lt;/p&gt;
&lt;p&gt;Anyway, what else &lt;em&gt;could&lt;/em&gt; the payment amount be, in the transaction
above? As well as 0.04 and 0.18, there is 0.09 and 0.01. Do you see the
reasoning? &lt;em&gt;If&lt;/em&gt; we assume that PayJoin is a possibility, then one party
could be consuming 0.09 and 0.08 and getting back 0.01. And similarly
for other contributions of inputs. In the simplest case, I would claim
there are 4 potential payment amounts if there are only two inputs and
we assume that one of the two is owned by the receiver. For the
blockchain analyst, this is a huge mess.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Advantage 2 - breaking Heuristic 1&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I discussed Heuristic 1 in the &lt;a href="%22https://joinmarket.me/blog/blog/coinjoinxt/"&gt;CoinJoinXT
post&lt;/a&gt;. Simple
description: people (analysts) assume that all the inputs to any
particular transaction are owned by one wallet/owner; i.e. they assume
coinjoin is not used, usually. Following the overall logic of our
narrative here, it's obvious what the main point is with PayJoin - we
break the heuristic &lt;em&gt;without flagging to the external observer that the
breakage has occurred. &lt;/em&gt;This is enormously important, even if the
breakage of the assumption of common input ownership on its own seems
rather trivial (especially if PayJoin is used by only few people), with
only 2 counterparties in each transaction.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Advantage 3 - Utxo sanitization&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This one might not occur to you immediately, at all, but is actually
really nice. Consider the plight of the merchant who sells 1,000 widgest
per day for Bitcoin. At the end of the day he has 1,000 utxos that he
has to spend. Perhaps the next day he pays his supplier with 80% of the
money; he'll have to construct a transaction (crudest scenario) with
800 inputs. It's not just that that costs a lot in fees (it does!); we
can't really directly solve that problem (well - use layer 2! - but
that's another blog post); but we can solve something else about it -
the privacy. The merchant immediately links &lt;em&gt;almost&lt;/em&gt; &lt;em&gt;all&lt;/em&gt; of his
payments in the 800-input payout transaction - horrible!&lt;/p&gt;
&lt;p&gt;But PayJoin really helps this; each payment that comes in can consume
the utxo of the last payment. Here are two fictitious widget payments in
sequence to illustrate; Bob's utxos are bolded for clarity:&lt;/p&gt;
&lt;p&gt;[PayJoin 1 - Alice pays Bob 0.1 for a
widget:]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.05 BTC ---&amp;gt;| 0.04 BTC 3AliceSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.09 BTC ---&amp;gt;| 0.18 BTC 3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.08 BTC ---&amp;gt;|&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;(notice: Bob used up one utxo and created one utxo - no net change)&lt;/p&gt;
&lt;p&gt;[PayJoin2 - Carol pays Bob 0.05 for a discount
widget:]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.01 BTC ---&amp;gt;| 0.02 BTC 3CarolSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.06 BTC ---&amp;gt;| 0.23 BTC 3BobSAddReSs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0.18 BTC ---&amp;gt;|&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This would be a kind of snowball utxo in the naive interpretation, that
gets bigger and bigger with each payment. In the fantasy case of every
payment being PayJoin, the merchant has a particularly easy wallet to
deal with - a wallet that only ever has 1 coin/utxo! (I know it's quite
dubious to think that nobody could trace this sequence, there are other
potential giveaways &lt;em&gt;in this case&lt;/em&gt; than just Heuristic 1; but with
Heuristic 1 gone, you have a lot more room to breathe, privacy-wise).&lt;/p&gt;
&lt;p&gt;It's worth mentioning though that the full snowball effect can damage
the anonymity set: after several such transactions, Bob's utxo is
starting to get big, and may dwarf other utxos used in the transaction.
In this case, the transaction will violate "UIH2" (you may remember
UIH1 - again, see the Appendix for more details on this) because a
wallet &lt;em&gt;probably&lt;/em&gt; wouldn't choose other utxos if it can fulfil the
payment with only one. So this may create a dynamic where it's better
to mix PayJoin with non-PayJoin payments.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Advantage 4 - hiding in (and being helpful to) the large crowd&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;"...but incremental increases in usage could be tremendously
valuable..." - let's be explicit about that now. If you're even
reasonably careful, these PayJoin transactions will be basically
indistinguishable from ordinary payments (see earlier comments about
UIH1 and UIH2 here, which don't contradict this statement). It's a
good idea to use decide on a specific locktime and sequence value that
fits in with commonly used wallets (transaction version 2 makes the most
sense). Now, here's the cool thing: suppose a small-ish uptake of this
was publically observed. Let's say 5% of payments used this method.
&lt;strong&gt;The point is that nobody will know which 5% of payments are PayJoin&lt;/strong&gt;.
That is a great achievement (one that we're not yet ready to achieve
for some other privacy techniques which use custom scripts, for example;
that may happen after Schnorr/taproot but not yet), because &lt;em&gt;it means
that all payments, including ones that don't use PayJoin, gain a
privacy advantage!&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;Merchants? Automation?&lt;/h2&gt;
&lt;p&gt;The aforementioned
&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki"&gt;BIP79&lt;/a&gt;
tries to address how this might work in a standardized protocol;
there's probably still significant work to do before the becomes
actualized. As it stands, it may be enough to have the following
features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some kind of "endpoint" (hence "pay to endpoint"/p2ep) that a
    customer/payer can connect to encoded as some kind of URL. A Tor
    hidden service would be ideal, in some cases. It could be encoded in
    the payment request similar to BIP21 for example.&lt;/li&gt;
&lt;li&gt;Some safety measures on the server side (the merchant/receiver) to
    make sure that an attacker doesn't use the service to connect,
    request, and block: thus enumerating the server's (merchant's)
    utxos. BIP79 has given one defensive measure against this that may
    be sufficient, Haywood's blog post discussed some more advanced
    ideas on that score.&lt;/li&gt;
&lt;li&gt;To state the obvious friction point - wallets would have to
    implement such a thing, and it is not trivial compared to features
    like RBF which are pure Bitcoin.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Who pays the fees?&lt;/h2&gt;
&lt;p&gt;The "snowball effect" described above, where the merchant always has
one utxo, may lead you to think that we are saving a lot of fees (no 800
input transactions). But not true except because of some second/third
order effect: every payment to the merchant creates a utxo, and every
one of those must be paid for in fees when consumed in some transaction.
The effect here is to pay those fees slowly over time. And it's left
open to the implementation how to distribute the bitcoin transaction
fees of the CoinJoin. Most logically, each participant pays according to
the amount of utxos they consume; I leave the question open here.&lt;/p&gt;
&lt;h2&gt;Implementation in practice&lt;/h2&gt;
&lt;p&gt;As far as I know as of this writing (mid-January 2019), there are two
implementations of this idea in the wild. One is from Samourai Wallet,
called
&lt;a href="https://samouraiwallet.com/stowaway"&gt;Stowaway&lt;/a&gt;
and the other is in
&lt;a href="https://github.com/Joinmarket-Org/joinmarket-clientserver/blob/master/docs/PAYJOIN.md"&gt;Joinmarket&lt;/a&gt;
as of version 0.5.2 (just released).&lt;/p&gt;
&lt;p&gt;I gave a demo of the latter in my last &lt;a href="https://web.archive.org/web/20200803124759/https://joinmarket.me/blog/blog/payjoin-basic-demo/"&gt;post on this
blog&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In both cases this is intended for peers to pay each other, i.e. it's
not something for large scale merchant automation (as per discussion in
previous section).&lt;/p&gt;
&lt;p&gt;It requires communication between parties, as does any CoinJoin, except
arguably
&lt;a href="https://web.archive.org/web/20200803124759/https://joinmarket.me/blog/blog/snicker/"&gt;SNICKER&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The sender of the payment always sends a non-CoinJoin payment
transaction to start with; it's a convenient/sane thing to do, because
if connection problems occur, or software problems, the receiver can
simply broadcast this "fallback" payment instead.&lt;/p&gt;
&lt;p&gt;In Joinmarket specifically, the implementation looks crudely like this:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Sender Receiver&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pubkey+versionrange --&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;-- pubkey and version&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(ECDH e2e encryption set up)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fallback tx ---&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;--- PayJoin tx partial-signed&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;co-signs and broadcasts&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Before starting that interchange of course, the receiver must "send"
(somehow) the sender the payment amount and destination address, as well
as (in Joinmarket) an ephemeral "nick" to communicate over the message
channel. Details here of course will vary, but bear in mind that as any
normal payment, there&lt;em&gt;must&lt;/em&gt;be some mechanism for receiver to
communicate payment information to the sender.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This is another nail in the coffin of blockchain analysis. If 5% of us
do this, it will &lt;em&gt;not&lt;/em&gt; be safe to assume that a totally ordinary looking
payment is not a CoinJoin. That's basically it.&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------&lt;/p&gt;
&lt;h3&gt;Appendix: Unnecessary Input Heuristics&lt;/h3&gt;
&lt;p&gt;The health warning to this reasoning has already been given: wallets
will definitely not &lt;em&gt;always&lt;/em&gt; respect the logic given below - I know of
at least one such case (h/t David Harding). However I think it's worth
paying attention to (this is slightly edited from the comment section of
the referenced gist):&lt;/p&gt;
&lt;p&gt;[Definitions:]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;"UIH1" : one output is smaller than any input. This heuristically
implies that &lt;em&gt;that&lt;/em&gt; output is not a payment, and must therefore be a
change output.&lt;/p&gt;
&lt;p&gt;"UIH2": one input is larger than any output. This heuristically
implies that &lt;em&gt;no output&lt;/em&gt; is a payment, or, to say it better, it implies
that this is not a normal wallet-created payment, it's something
strange/exotic.&lt;/p&gt;
&lt;p&gt;Note: UIH2 does not necessarily imply UIH1.&lt;/p&gt;
&lt;p&gt;~~~~&lt;/p&gt;
&lt;p&gt;So we just have to focus on UIH2. Avoiding UIH1 condition is nice,
because it means that both outputs could be the payment; but in any case
the normal blockchain analysis will be wrong about the payment amount.
If we don't avoid the UIH2 condition, though, we lose the
steganographic aspect which is at least 50% of the appeal of this
technique.&lt;/p&gt;
&lt;p&gt;Joinmarket's current implementation does its best to avoid UIH2, but
proceeds with PayJoin anyway even if it can't. The reasoning is
partially as already discussed: not all wallets follow this logic; the
other part of the reasoning is the actual data, as we see next:&lt;/p&gt;
&lt;p&gt;[Data collection from LaurentMT:]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;From block 552084 to block 552207 (One day: 01/12/2018)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Txs with 2 outputs and more than 1 input = 35,349&lt;ul&gt;
&lt;li&gt;UIH1 Txs (identifiable change output) = 19,020 (0.54)&lt;/li&gt;
&lt;li&gt;!UIH1 Txs = 16,203 (0.46)&lt;/li&gt;
&lt;li&gt;Ambiguous Txs = 126 (0.00)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From block 552322 to block 553207 (One week: 03/12/2018 - 09/12/2018)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Txs with 2 outputs and more than 1 input = 268,092&lt;ul&gt;
&lt;li&gt;UIH1 Txs (identifiable change output) = 145,264 (0.54)&lt;/li&gt;
&lt;li&gt;!UIH1 Txs = 121,820 (0.45)&lt;/li&gt;
&lt;li&gt;Ambiguous Txs = 1,008 (0.00)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And here are a few stats for UIH2:&lt;/p&gt;
&lt;p&gt;Stats from block 552084 to block 552207 (One day: 01/12/2018)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Txs with 2 outputs and more than 1 input = 35,349&lt;ul&gt;
&lt;li&gt;UIH2 Txs = 10,986 (0.31)&lt;/li&gt;
&lt;li&gt;!UIH2 Txs = 23,596 (0.67)&lt;/li&gt;
&lt;li&gt;Ambiguous Txs = 767 (0.02)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From block 552322 to block 553207 (One week: 03/12/2018 - 09/12/2018)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Txs with 2 outputs and more than 1 input = 268,092&lt;ul&gt;
&lt;li&gt;UIH2 Txs = 83,513 (0.31)&lt;/li&gt;
&lt;li&gt;!UIH2 Txs = 178,638 (0.67)&lt;/li&gt;
&lt;li&gt;Ambiguous Txs = 5,941 (0.02)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="waxwings Blog"></category><category term="coinjoin"></category><category term="bitcoin"></category></entry><entry><title>CoinjoinXT</title><link href="https://joinmarket.me/blog/blog/coinjoinxt/" rel="alternate"></link><published>2018-09-15T00:00:00+02:00</published><updated>2018-09-15T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2018-09-15:/blog/blog/coinjoinxt/</id><summary type="html">&lt;p&gt;a proposal for multi-transaction coinjoins.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;CoinJoinXT&lt;/h3&gt;
&lt;h1&gt;CoinJoinXT - a more flexible, extended approach to CoinJoin&lt;/h1&gt;
&lt;p&gt;*Ideas were first discussed
&lt;a href="https://gist.github.com/AdamISZ/a5b3fcdd8de4575dbb8e5fba8a9bd88c"&gt;here&lt;/a&gt;.
Thanks again to arubi on IRC for helping me flesh them out.\
*&lt;/p&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;We assume that the reader is familiar with CoinJoin as a basic idea -
collaboratively providing inputs to a transactions so that it may be
made difficult or impossible to distinguish ownership/control of the
outputs.&lt;/p&gt;
&lt;p&gt;The way that CoinJoin is used in practice is (today mainly using
JoinMarket, but others over Bitcoin's history) is to create large-ish
transactions with multiple outputs of exactly the same amount. This can
be called an "intrinsic fungibility" model - since, although the
transactions created are unambiguously recognizable as CoinJoins, the
indistinguishability of said equal outputs is kind of "absolute".&lt;/p&gt;
&lt;p&gt;However, as partially discussed in the earlier blog post &lt;a href="https://web.archive.org/web/20200603010653/https://joinmarket.me/blog/blog/the-steganographic-principle/"&gt;"the
steganographic
principle"&lt;/a&gt;,
there's at least an argument for creating fungibility in a less
explicit way - that is to say, creating transactions that have a
fungibility effect but aren't &lt;em&gt;necessarily&lt;/em&gt; visible as such - they
&lt;em&gt;may&lt;/em&gt; look like ordinary payments. I'll call this the &lt;em&gt;deniability&lt;/em&gt;
model vs the &lt;em&gt;intrinsic fungibility&lt;/em&gt; model. It's harder to make this
work, but it has the possibility of being much more effective than the
&lt;em&gt;intrinsic fungibility model&lt;/em&gt;, since it gives the adversary (who we'll
talk about in a minute) an additional, huge problem: he doesn't even
know where to start.&lt;/p&gt;
&lt;h2&gt;The adversary's assumptions&lt;/h2&gt;
&lt;p&gt;In trying to create privacy, we treat the "blockchain analyst" as our
adversary (henceforth just "A").&lt;/p&gt;
&lt;p&gt;Blockchain analysis consists, perhaps, of two broad areas (not sure
there is any canonical definition); we can call the first one
"metadata", vaguely, and think of it is every kind of data that is not
directly recorded on the blockchain, such as personally identifying
information, exchange records etc, network info etc. In practice, it's
probably the most important. The second is stuff recorded directly on
the blockchain - pseudonyms (scriptPubKeys/addresses) and amount
information (on non-amount-blinded blockchains as Bitcoin's is
currently; for a discussion about that see this earlier &lt;a href="https://web.archive.org/web/20200603010653/https://joinmarket.me/blog/blog/the-steganographic-principle/"&gt;blog
post&lt;/a&gt;);
note that amount information includes the implicit amount - network fee.&lt;/p&gt;
&lt;p&gt;Timing information perhaps straddles the two categories, because while
transactions are (loosely) timestamped, there is also the business of
trying to pick up timing and perhaps geographic information from
snooping the P2P network.&lt;/p&gt;
&lt;p&gt;With regard to that second category, the main goal of A is to correlate
ownership of different utxos. An old
&lt;a href="https://cseweb.ucsd.edu/~smeiklejohn/files/imc13.pdf"&gt;paper&lt;/a&gt;
of Meiklejohn et al 2013 identified two Heuristics (let's call them
probabilistic assumptions), of which the first was by far the most
important:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Heuristic 1 - All inputs to a transaction are owned by the same
    party&lt;/li&gt;
&lt;li&gt;Heuristic 2 - One-time change addresses are owned by the same party
    as the inputs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The second is less important mainly because it had to be caveat-ed quite
a bit and wasn't reliable in naive form; but, identification of change
addresses generally is a plausible angle for A. The first has been, as
far as I know, the bedrock of blockchain analysis and has been referred
to in many other papers, was mentioned in Satoshi's whitepaper, and you
can see one functional example at the long-existent website
&lt;a href="https://www.walletexplorer.com/"&gt;walletexplorer&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[But I think it's important to observe that this list is
incomplete.]{style="text-decoration: underline;"}[]{style="text-decoration: underline;"}&lt;/p&gt;
&lt;p&gt;I'll now add two more items to the list; the first is omitted because
it's elementary, the other, because it's subtle (and indeed you might
find it a bit dumb at first sight):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Heuristic/Assumption 0&lt;/code&gt;: All inputs controlled by only one pubkey
    are unilaterally controlled&lt;/li&gt;
&lt;li&gt;Heuristic/Assumption 1: All inputs to a transaction are owned by the
    same party&lt;/li&gt;
&lt;li&gt;Heuristic/Assumption 2(?): One-time change addresses are owned by
    the same party as the inputs&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Heuristic/Assumption 3&lt;/code&gt;: Transfer of ownership between parties in
    one transaction implies payment&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, "Heuristic/Assumption" because assumption is probably a better
word for all of these generally, but I want to keep the existing
nomenclature, the "?" for 2 is simply because, as mentioned, this one
is problematic (although still worthy of consideration).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assumption 0&lt;/strong&gt;: basically, that if it's not multisig, was never fully
safe; there was always &lt;a href="https://en.wikipedia.org/wiki/Shamir's_Secret_Sharing"&gt;Shamir's secret
sharing&lt;/a&gt;
to share shards of a key, albeit that's very rarely used, and you can
argue pedantically that full reconstruction means unilateral control.
But Assumption 0 is a lot less safe now due to the recent
&lt;a href="https://eprint.iacr.org/2018/472"&gt;work&lt;/a&gt;
by Moreno-Sanchez et al. which means, at the very least, that 2 parties
can easily use a 2-party computation based on the Paillier encryption
system to effectively use a single ECDSA pubkey as a 2-2 multisig. So
this assumption is generally unspoken, but in my opinion is now
generally important (i.e. not necessarily correct!).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assumption 3&lt;/strong&gt;: this is rather strange and looks tautological; I could
have even written "transfer of ownership between parties in one
transaction implies transfer of ownership" to be cheeky. The point, if
it is not clear to you, will become clear when I explain what
"CoinJoinXT" means.&lt;/p&gt;
&lt;p&gt;Our purpose, now, is to make A's job harder &lt;strong&gt;by trying to invalidate
all of the above assumptions at once&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Quick refresher: BIP141&lt;/h2&gt;
&lt;p&gt;This has been discussed in other blog posts about various types of
"CoinSwap", so I won't dwell on it.&lt;/p&gt;
&lt;p&gt;Segwit fixes transaction malleability
(&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki"&gt;BIP141&lt;/a&gt;,
along with BIP143,144 were the BIPs that specified segwit). One of the
most important implications of this is explained directly in BIP 141
itself, to
&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#Trustfree_unconfirmed_transaction_dependency_chain"&gt;quote&lt;/a&gt;
from it:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Two parties, Alice and Bob, may agree to send certain amount of
Bitcoin to a 2-of-2 multisig output (the "funding transaction").
Without signing the funding transaction, they may create another
transaction, time-locked in the future, spending the 2-of-2 multisig
output to third account(s) (the "spending transaction"). Alice and
Bob will sign the spending transaction and exchange the signatures.
After examining the signatures, they will sign and commit the funding
transaction to the blockchain. Without further action, the spending
transaction will be confirmed after the lock-time and release the
funding according to the original contract.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In short, if we agree a transaction, then we can fix its txid and sign
transactions which use its output(s). The BIP specifically references
the Lightning Network as an example of the application of this pattern,
but of course it's not restricted to it. We can have Alice and Bob
agree to any arbitrary set of transactions and pre-sign them, in
advance, with all of them having the funding transaction as the root.&lt;/p&gt;
&lt;h2&gt;CoinJoinXT - the basic case&lt;/h2&gt;
&lt;p&gt;CoinJoin involves 2 or more parties contributing their utxos into 1
transaction, but using the above model they can do the same to a funding
transaction, but then pre-sign a set of more than one spending
transaction. Here's a simple schematic:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;A 1btc ---&amp;gt;&lt;/span&gt;
&lt;span class="err"&gt;              F (2,2,A,B) --+&lt;/span&gt;
&lt;span class="err"&gt;B 1btc ---&amp;gt;                 |&lt;/span&gt;
&lt;span class="err"&gt;                            |&lt;/span&gt;
&lt;span class="err"&gt;                            +--&amp;gt;[Proposed transaction graph (PTG) e.g. -&amp;gt;TX1-&amp;gt;TX2-&amp;gt;TX3 ..]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In human terms, you can envisage that: Alice and Bob would like to start
to negotiate a set of conditional contracts about what happens to their
money. Then they go through these steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;One side proposes F (the funding transaction) and a full graph of
    unsigned transactions to fill out the PTG above; e.g. Alice
    proposes, Bob and Alice share data (pubkeys, destination addresses).
    Note that the set doesn't have to be a chain (TX1-&gt;TX2-&gt;TX3...),
    it can be a tree, but each transaction must require sign-off of both
    parties (either, at least one 2-2 multisig utxo, or at least one
    utxo whose key is owned by each party).&lt;/li&gt;
&lt;li&gt;They exchange signatures on all transactions in the PTG, in either
    order. Of course, they abort if signatures don't validate.&lt;/li&gt;
&lt;li&gt;With this in place (i.e. &lt;strong&gt;only&lt;/strong&gt; after valid completion of (2)),
    they both sign (in either order) F.&lt;/li&gt;
&lt;li&gt;Now both sides have a valid transaction set, starting with F. Either
    or both can broadcast them. [The transactions are &lt;em&gt;all&lt;/em&gt; guaranteed
    to occur as long as at least one of them wants
    it]{style="text-decoration: underline;"}. Contrariwise, &lt;strong&gt;none&lt;/strong&gt; of
    them is valid without F being broadcast.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This does achieve one significant thing: &lt;strong&gt;one transaction such as TX2
can transfer coins to, say, Bob's wallet, giving Alice nothing; and yet
we can still get the overall effect of a CoinJoin. In other words,
we've opened up the possibility to violate Heuristic 3 as well as
Heuristic 1, in the same (short) interaction.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;This construction works fine if &lt;em&gt;all&lt;/em&gt; inputs used in transactions in the
PTG are descendants of F; but this makes the construction very limited.
So we'll immediately add more details to allow a more general use-case,
in the next section.&lt;/p&gt;
&lt;h2&gt;Introducing Promises&lt;/h2&gt;
&lt;p&gt;If we allowed any of the transactions (TX1, TX2, ...) in the PTG in our
previous example to have an input which did &lt;em&gt;not&lt;/em&gt; come from the funding
transaction F, then we would have introduced a risk; if Alice added utxo
UA to, say, TX2, then, before Bob attempted to broadcast TX2, she could
double spend it. This would break the atomicity of the graph, which was
what allowed the crucial additional interesting feature (in bold,
above): that an individual transaction could transfer funds to one
party, without risks to the other. To address this problem, we call
these additional inputs &lt;strong&gt;promise utxos&lt;/strong&gt; and make use of &lt;strong&gt;refund
transactions&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;A 1btc ---&amp;gt;&lt;/span&gt;
&lt;span class="err"&gt;              F (2,2,A,B) ---&lt;/span&gt;
&lt;span class="err"&gt;B 1btc ---&amp;gt;                 |       +--&amp;gt; external payout 0.5 btc to Bob&lt;/span&gt;
&lt;span class="err"&gt;                            |       |&lt;/span&gt;
&lt;span class="err"&gt;                            +-&amp;gt;[TX1 --&amp;gt; TX2 --&amp;gt; TX3 --&amp;gt; TX4]&lt;/span&gt;
&lt;span class="err"&gt;                                         |       ^&lt;/span&gt;
&lt;span class="err"&gt;                                         |       |&lt;/span&gt;
&lt;span class="err"&gt;                                         |       |&lt;/span&gt;
&lt;span class="err"&gt;                                         |       +--- utxo A1&lt;/span&gt;
&lt;span class="err"&gt;                                         |&lt;/span&gt;
&lt;span class="err"&gt;                                         +--&amp;gt; refund locktime M, pay out *remaining* funds to A: 1btc, B: 0.5btc&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In words: if, between the negotiation time and the time of broadcast of
TX3, Alice spends A1 in some other transaction, Bob will still be safe;
after block M he can simply broadcast the presigned refund transaction
to claim the exact number of coins he is owed at that point in the
graph.&lt;/p&gt;
&lt;p&gt;The above addresses the case of a single external input being included
in a chain of transactions in the PTG (here, TX1,2,3,4). Extending this,
and generalising to allowing external inputs in many transactions, is
straightforward; we can add such in-PTG backouts at every step,
redeeming all remaining funds to parties according to what they're
owed.&lt;/p&gt;
&lt;p&gt;To summarize this section and how it differs from the original, simpler
construction:&lt;/p&gt;
&lt;p&gt;Alice and Bob have a choice:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;They can set up a fully trustless PTG, without promises. They are
    then guaranteed to achieve "all or nothing": either all
    cooperative signing works, then all transactions can be broadcast
    (as long as &lt;em&gt;at least one&lt;/em&gt; of them wants to), or nothing
    (including F) is broadcast at all.&lt;/li&gt;
&lt;li&gt;They can set up a PTG including promises from one or both parties.
    Now they don't get "all or nothing" but only ensure that the
    transactions that complete are a subset, in order, from the start F.
    To achieve this they add presigned backouts at (probably every)
    step, so that if the chain "breaks" somewhere along, they will
    recover all the funds remaining that are owed to them.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The tradeoff is: (2) is not perfectly atomic, but it allows the
transaction graph to include utxos from outside of F's ancestory,
particularly useful for privacy applications. In a sequence of 10
coinjoins, you may be happy to risk that TXs 6-10 don't end up
happening, if it doesn't cost you money. Case (2) is more likely to be
of interest.&lt;/p&gt;
&lt;h2&gt;Interlude - overview of features of CoinJoinXT&lt;/h2&gt;
&lt;p&gt;There's a large design space here.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We can have N parties, not just 2.&lt;/li&gt;
&lt;li&gt;We can have as many transactions as we like.&lt;/li&gt;
&lt;li&gt;We can have a tree with F as root, rather than a chain.&lt;/li&gt;
&lt;li&gt;We can have as many promise utxos from any of the N parties as we
    like.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A mixture of these features may give different tradeoffs in terms of
&lt;em&gt;intrinsic fungibility&lt;/em&gt; vs &lt;em&gt;deniability&lt;/em&gt; vs &lt;em&gt;cost&lt;/em&gt;; the tradeoff
discussed in the introduction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Interactivity&lt;/strong&gt; - unlike either a CoinSwap of types discussed earlier
in this blog, or doing multiple CoinJoins (to get a better fungibility
effect than just a single one), this only requires one "phase" of
interactivity (in terms of rounds, it may be 3). The two parties
connect, exchange data and signatures, and then immediately disconnect.
(This is what I called no-XBI in the previous &lt;a href="https://web.archive.org/web/20200603010653/https://joinmarket.me/blog/blog/the-half-scriptless-swap/"&gt;blog
post&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Boundary&lt;/strong&gt; - the adversary A, as was hinted at in the introduction, in
this model, will not necessarily be able to easily see on the blockchain
where the start and end points of this flow of transactions was. To the
extent that this is true, it's an enormous win, but more on this later.&lt;/p&gt;
&lt;h2&gt;Example&lt;/h2&gt;
&lt;p&gt;&lt;img alt="ExampleCJXT" src="../../../../../../20200603010653im_/https:/joinmarket.me/static/media/uploads/.thumbnails/onchaincontract3.png/onchaincontract3-614x422.png"&gt;{width="614"
height="422"}&lt;/p&gt;
&lt;p&gt;Here we are still restricting to 2 parties for simplicity of the
diagram. There is still a chain of 4 TXs, but here we flesh out the
inputs and outputs. About colors:&lt;/p&gt;
&lt;p&gt;Blue txos are co-owned by the two parties, envisioned as 2 of 2 multisig
(although as originally mentioned, the technical requirement is only
that each transaction is signed by both parties).&lt;/p&gt;
&lt;p&gt;Red inputs are &lt;strong&gt;promise utxos&lt;/strong&gt; as described in the earlier section.&lt;/p&gt;
&lt;p&gt;Each promise has a corresponding backout transaction pre-signed as
output consuming the bitcoins of the
[previous]{style="text-decoration: underline;"} transaction to the one
consuming that promise.&lt;/p&gt;
&lt;p&gt;Notice that this example contains two possible setups for each
individual transaction in the chain; it can pay out only to one party
(like TX3 which pays bob 0.6btc), or it can pay "CoinJoin-style"
equal-sized outputs to 2 (or N) parties. Choosing this latter option
means you are consciously deciding to blur the line between the
&lt;em&gt;intrinsic-fungibility&lt;/em&gt; model and the &lt;em&gt;deniability&lt;/em&gt; &lt;em&gt;model,&lt;/em&gt; which, by
the way, is not necessarily a bad idea.&lt;/p&gt;
&lt;h2&gt;The return of A - amounts leak.&lt;/h2&gt;
&lt;p&gt;As mentioned, our adversary A has a very important problem - he may not
know that the above negotiation has happened, unlike a simple CoinJoin
where the transactions are watermarked as such (and this is particularly
true if Alice and Bob do &lt;em&gt;not&lt;/em&gt; use equal-sized outputs). The boundary
may be unclear to A.&lt;/p&gt;
&lt;p&gt;So, what strategy &lt;em&gt;can&lt;/em&gt; A use to find the transaction graph/set? He can
do &lt;a href="https://en.wikipedia.org/wiki/Subset_sum_problem"&gt;subset
sum&lt;/a&gt;
analysis.&lt;/p&gt;
&lt;p&gt;If Alice and Bob are just 'mixing' coins, so that they are paid out
the same amount that they paid in, I'll assert that subset sum is
likely to work. It's true that A's job is quite hard, since in
general, he would have to do such subset-sum analysis on a huge array of
different possible sets of (inputs, outputs) on chain; but nevertheless
it's the kind of thing that can be done by a professional adversary,
over time. The fact that subset sum analysis is theoretically
exponential time and therefore not feasible for very large sets may not
be relevant in practice.&lt;/p&gt;
&lt;p&gt;In our example above it may not be hard to identify the two inputs from
Alice (1btc, 0.3btc) as corresponding to 3 outputs (0.8btc, 0.2btc,
0.3btc), albeit that the latter two - 0.2, 0.3 were part of CoinJoins.
Remember that this was a tradeoff - if we &lt;em&gt;didn't&lt;/em&gt; make equal sized
outputs, to improve deniability/hiding, we'd no longer have any
ambiguity there.&lt;/p&gt;
&lt;h2&gt;Breaking subset-sum with Lightning&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="../../../../../../20200603010653im_/https:/joinmarket.me/static/media/uploads/.thumbnails/amtdecorr2.png/amtdecorr2-711x392.png"&gt;{width="711"
height="392"}&lt;/p&gt;
&lt;p&gt;Here's one way of addressing the fact that A can do subset-sum on such
a privacy-enhancing CoinJoinXT instantiation. The PTG is unspecified but
you can imagine it as something similar to the previous example.&lt;/p&gt;
&lt;p&gt;Marked in blue is what the adversary A doesn't know, even if he has
identified the specific transaction/graph set (as we've said, that in
itself is already hard). Subset-sum analysis won't work here to
identify which output belongs to Alice and which to Bob; since 5.5 + 1.5
!= 6.6, nor does 5.4 fit, nor does such an equation fit with Alice's
input 5.8 on the right hand side of the equation.&lt;/p&gt;
&lt;p&gt;The trick is that the 1.5 output is actually a &lt;strong&gt;dual funded Lightning
channel&lt;/strong&gt; between Alice and Bob. The actual channel balance is shown in
blue again because hidden from A: (0.3, 1.2). If the channel is then
immediately closed we have fallen back to a case where subset sum works,
as the reader can easily verify.&lt;/p&gt;
&lt;p&gt;But if, as is usually the intent, the channel gets used, the balance
will shift over time, due to payments over HTLC hops to other
participants in the Lightning network. This will mean that the final
closing balance of the channel will be something else; for example,
(0.1, 1.4), and then subset-sum will still not reveal which of the 2
outputs (5.4, 5.5) belong to Alice or Bob.&lt;/p&gt;
&lt;p&gt;At a high level, you can understand this as a &lt;strong&gt;bleed-through and
amplification of off-chain privacy to on-chain.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;It's worth noting that you clearly get a significant part of this
effect from just the dual-funded Lightning channel; if you consider
change outputs in such a single funding transaction, you see the same
effect:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Alice&lt;/span&gt;
&lt;span class="err"&gt;2.46&lt;/span&gt;
&lt;span class="err"&gt;       -&amp;gt; Lightning funding 0.1&lt;/span&gt;
&lt;span class="err"&gt;       -&amp;gt; Change 2.41&lt;/span&gt;
&lt;span class="err"&gt;       -&amp;gt; Change 2.37&lt;/span&gt;
&lt;span class="err"&gt;2.42&lt;/span&gt;
&lt;span class="err"&gt;Bob&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;It's easy to see that there is no delinking effect on the change-outs
&lt;em&gt;if&lt;/em&gt; we know that the funding is equal on both sides. However, there's
no need for that to be the case; if the initial channel balance is
(Alice: 0.09, Bob: 0.01) then the change-outs are going to the opposite
parties compared to if the channel funding is (Alice: 0.05, Bob: 0.05).
So this concrete example should help you to understand a crucial aspect
of this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Such a fungibility effect is only achieved if the difference between
    the two parties' initial inputs is small enough compared to the
    size of the dual-funded Lightning channel&lt;/li&gt;
&lt;li&gt;If the size of the inputs is very large compared to the Lightning
    channel overall size, which currently at maximum is 2**24 satoshis
    (about 0.16btc), then, in order to achieve this obfuscation effect,
    we "converge" to the case of something like a 2-in and 2-out
    equal-sized coinjoin. It's hard for 2 parties to arrange to have
    inputs of equal sizes, and it somewhat loses the deniability feature
    we were going for. (You can easily confirm for yourself that there
    will be no ambiguity if Alice and Bob's inputs are of completely
    different sizes).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So how does the picture change if instead of just doing a single
dual-funded Lightning channel, we include it as an output in a
CoinJoinXT structure?&lt;/p&gt;
&lt;p&gt;The answer again is deniability. Any contiguous subset of the entire
blockchain has the property of sum preservation, modulo fees: the input
total is \~= the output total. So no particular contiguous subset on the
blockchain flags itself as being such a CoinJoinXT structure - unless
subset sum works for some N subsets (2, as in our examples, or higher).
But with the dual funded Lightning output of the type shown here, at
least for the 2 of 2 case, this doesn't work.&lt;/p&gt;
&lt;h2&gt;Remove all traces?&lt;/h2&gt;
&lt;p&gt;What's been described up to now doesn't quite achieve the desired goal
of "deniability"; there are still what we might call "fingerprints"
in such a CoinJoinXT structure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Timing correlation: if we don't use nLockTime on these
    transactions, then one party might choose to broadcast them all at
    once. This is at the least a big clue, although not unambiguous. To
    avoid it, have the pre-signed transactions in the PTG all be given
    specific timelocks.&lt;/li&gt;
&lt;li&gt;Shared control utxos. If we use 2 of 2, or N of N, multisig outputs,
    of the current normal p2sh type, then they are observable as such,
    and this could easily help A to find the "skeleton" of such a
    CoinJoinXT structure. Of course, let's not forget that we can do
    CoinJoinXT with various equal sized outputs too, mixing the
    "intrinsic fungibility" and "deniability" approaches together,
    as discussed, so it's not that CoinJoinXT with p2sh multisig
    connecting utxos is useless. But we may want to focus on less
    detectable forms, like Schnorr/MuSig based multisig with key
    aggregation so that N of N is indistinguishable from 1 of 1, or the
    new
    &lt;a href="https://eprint.iacr.org/2018/472"&gt;construction&lt;/a&gt;
    that allows an ECDSA pubkey to be effectively a 2 of 2 multisig.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Proof of Concept&lt;/strong&gt; - I put together a some very simple &lt;a href="https://github.com/AdamISZ/CoinJoinXT-POC"&gt;PoC
code&lt;/a&gt;;
it only covers something like the above first "Example" with 2
parties. Going through such an exercise in practice at least allows one
to see concretely that (a) the interaction between the parties is very
minimal (sub-second) which is great of course, but it gets a little
hairy when you think about how to set up a template of such a
transaction chain that 2 parties can agree on using whatever utxos they
have available as inputs. A substantial chunk of that PoC code was
devoted to that - there is a general &lt;code&gt;Template&lt;/code&gt; class for specifying a
graph of transactions, with parametrized input/output sizes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Practicality today&lt;/strong&gt; - Although it can be done today (see previous),
there are barriers to making this work well. Ideally we'd have Schnorr
key aggregation for multisig, and support for dual funded Lightning
channels for the amount decorrelation trick mentioned. Without either of
those, such a transaction graph on the blockchain will be &lt;em&gt;somewhat&lt;/em&gt;
identifiable, but I still think there can be a lot of use doing it as an
alternative to large sets of clearly identifiable CoinJoins.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cost tradeoffs&lt;/strong&gt; - left open here is the tradeoffs in terms of
blockchain space usage for each "unit of fungibility", i.e. how much
it costs to gain privacy/fungibility this way. I think it's almost
impossible to come up with definitive mathematical models of such
things, but my feeling is that, exactly to the extent any
"deniability" is achieved, it's cost-effective, and to the extent
it's not, it's not cost-effective.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Coordination model&lt;/strong&gt; - Currently we have "in play" at least two
models of coordination for CoinJoin - Joinmarket's market-based model,
and the Chaumian server model currently championed by
&lt;a href="https://github.com/nopara73/ZeroLink"&gt;ZeroLink&lt;/a&gt;.
&lt;strong&gt;CoinJoinXT as an idea is orthogonal to the coordination mechanism&lt;/strong&gt;.
The only "non-orthogonal" aspect, perhaps, is that I think the
CoinJoinXT approach may still be pretty useful with only 2 parties (or
3), more so that CoinJoin with only 2/3.&lt;/p&gt;
&lt;p&gt;Finally, where should this fit in one's fungibility "toolchest"?
Lightning is &lt;em&gt;hopefully&lt;/em&gt; going to emerge as a principal way that people
gain fungibility for their everyday payments. The area it can't help
with now, and probably not in the future due to its properties, is with
larger amounts of money. So you might naturally want to ensure that in,
say, sending funds to an exchange, making a large-ish payment, or
perhaps funding a channel, you don't reveal the size of your cold
storage wallet. I would see the technique described on this blog post as
fitting into that medium-large sized funds transfer situation. CoinJoin
of the pure "intrinsic fungibility" type, done in repeated rounds or
at least in very large anonymity sets, is the other alternative (and
perhaps the best) for large sizes.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="coinjoin"></category><category term="bitcoin"></category></entry><entry><title>The Steganographic Principle</title><link href="https://joinmarket.me/blog/blog/the-steganographic-principle/" rel="alternate"></link><published>2018-04-15T00:00:00+02:00</published><updated>2018-04-15T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2018-04-15:/blog/blog/the-steganographic-principle/</id><summary type="html">&lt;p&gt;a framework for thinking about blockchain privacy issues&lt;/p&gt;</summary><content type="html">&lt;h3&gt;The steganographic principle&lt;/h3&gt;
&lt;h1&gt;The Steganographic Principle&lt;/h1&gt;
&lt;p&gt;Some time ago I wrote
&lt;a href="https://gist.github.com/AdamISZ/83a17befd84992a7ad74"&gt;this&lt;/a&gt;
gist, which is an ill-formed technical concept about a way you could do
steganography leveraging randomness in existing network protocols; but I
also called it a "manifesto", jokingly, because I realised the thinking
behind it is inherently political.&lt;/p&gt;
&lt;h2&gt;Cryptography is for terrorists, too&lt;/h2&gt;
&lt;p&gt;There are a few reasons why the phrase "If you have nothing to hide, you
have nothing to fear" is wrong and insidiously so. One of the main ones
is simply this: my threat model is &lt;strong&gt;not only my government&lt;/strong&gt;, even if
my government is perfect and totally legitimate (to me). But no
government is perfect, and some of them are literally monstrous.&lt;/p&gt;
&lt;p&gt;So while it's true that there are uses of cryptography harmonious with a
PG13 version of the world - simply protecting obviously sensitive data
&lt;em&gt;within&lt;/em&gt; the control of authorities - there are plenty where it is
entirely ethically right and necessary to make that protection
&lt;strong&gt;absolute&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The question then arises, as was raised in the above gist, what are the
properties of algorithms that satisfy the requirement of defence even
against hostile authorities?&lt;/p&gt;
&lt;p&gt;The modern tradition of cryptography uses Kerckhoff's Law as one of its
axioms, and steganography does not fit into this model. But that's
because the tradition is built by people in industry who are fine with
people &lt;strong&gt;knowing they are using cryptography&lt;/strong&gt;. In an environment where
that is not acceptable, steganography is not on a list of options - it's
more like the sine qua non.&lt;/p&gt;
&lt;h2&gt;Steganography on blockchains&lt;/h2&gt;
&lt;p&gt;On a blockchain, we have already understood this "freedom fighter"
model. It's an essential part of how the thing was even created, and why
it exists. And there are essentially two principal complaints about
Bitcoin and its blockchain, both of which are somewhat related to this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Privacy&lt;/li&gt;
&lt;li&gt;Scalability&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first is obvious - if we don't create "steganographic" transactions,
then governments, and everyone else, may get to know at least
&lt;em&gt;something&lt;/em&gt; about our transactions. The second is less so - but in the
absence of scale we have a small anonymity set. Smaller payment network
effects and smaller anonymity sets obviously hamper use of these systems
by a "freedom fighter". But remember the scale limitations come directly
out of the design of the system with censorship resistance and
independent verification in mind.&lt;/p&gt;
&lt;p&gt;Attempts to improve the privacy by altering the &lt;em&gt;way&lt;/em&gt; in which
transactions are done have a tendency to make the scalability worse -
the obvious example being CoinJoin, which with unblinded amounts
inevitably involves larger numbers of outputs and larger numbers of
transactions even.&lt;/p&gt;
&lt;p&gt;A less obvious example is Confidential Transcations; when we blind
outputs we need to use up more space to create the necessary guarantees
about the properties of the amounts - see the range proof, which with
Borromean ring signatures or bulletproofs need a lot of extra space. The
same is true of ring signature approaches generally to confidentiality.&lt;/p&gt;
&lt;p&gt;You can trade off space usage for computation though - e.g. zkSNARKs
which are quite compact in space but take a lot of CPU time to create
(and in a way they take a lot of space in a different sense - memory
usage for proof creation).&lt;/p&gt;
&lt;h2&gt;Localised trust&lt;/h2&gt;
&lt;p&gt;You can improve this situation by localising trust in space or time.
There are obvious models - the bank of the type set up by digicash. See
the concept of &lt;a href="https://en.wikipedia.org/wiki/Blind_signature"&gt;Chaumian
tokens&lt;/a&gt;
generally. One project that looked into creating such things was
&lt;a href="https://github.com/Open-Transactions/"&gt;OpenTransactions&lt;/a&gt;,
another was Loom, also see Truledger.&lt;/p&gt;
&lt;p&gt;Trust can be localised in time as well - and the aforementioned zkSnarks
are an example; they use a trusted setup as a bootstrap. This trust can
be ameliorated with a multiparty computation protocol such that trust is
reduced by requiring all participants to be corrupt for the final result
to be corrupt; but it is still trust.&lt;/p&gt;
&lt;h2&gt;The tension between privacy and security&lt;/h2&gt;
&lt;p&gt;For any attribute which is perfectly (or computationally) hidden, we
have a corresponding security downgrade. If attribute A is required to
satisfy condition C by the rules of protocol P, and attribute A is
blinded to A* by a privacy mechanism M, in such a way that we use the
fact that C* is guaranteed by A*, then we can say that P's security is
"downgraded" by M in the specific sense that the C-guarantee has been
changed to the C*-guarantee, where (inevitably) the C* guarantee is
not as strong, since it requires the soundess of M as well as whatever
assumptions already existed for the soundness of C.&lt;/p&gt;
&lt;p&gt;However, the situation is worse - precisely because M is a privacy
mechanism, it reduces public verifiability, and specifically
verifiability of the condition C, meaning that if the C* guarantee
(which we &lt;em&gt;can&lt;/em&gt; publically verify) fails to provide C, there will be no
public knowledge of that failure.&lt;/p&gt;
&lt;p&gt;To give a concrete example of the above template, consider what happens
to Bitcoin under Confidential Transactions with Pedersen commitments
(set aside the range proof for a moment). Since Pedersen commitments are
perfectly hiding but only computationally binding, we have:&lt;/p&gt;
&lt;p&gt;P = Bitcoin&lt;/p&gt;
&lt;p&gt;A = Bitcoin amounts of outputs&lt;/p&gt;
&lt;p&gt;C = amount balance in transactions&lt;/p&gt;
&lt;p&gt;M = CT with Pedersen commitments&lt;/p&gt;
&lt;p&gt;A* = Pedersen commitments of outputs&lt;/p&gt;
&lt;p&gt;C* = Pedersen commitment balance in transactions&lt;/p&gt;
&lt;p&gt;Here the downgrade in security is specifically the computational binding
of Pedersen commitments (note: that's assuming both ECDLP intractability
*and* NUMS-ness of a curve point). Without Pedersen/CT, there are
*no* assumptions about amount balance, since integers are "perfectly
binding" :) With it, any failure of the computational binding is
catastrophic, since we won't see it.&lt;/p&gt;
&lt;h2&gt;The tension between privacy and scalability&lt;/h2&gt;
&lt;p&gt;For any attribute A which is obfuscated by a privacy mechanism M in
protocol P (note: I'm choosing the word "obfuscation" here to indicate
that the hiding is not perfect - note the contrast with the previous
section), we have a corresponding scalability failure. M may obfuscate
an attribute A by expanding the set of possible values/states from A to
A[N]. To commit to the obfuscation soundly it must publish data of
order \~ N x size(A). Also note that it is &lt;em&gt;possible&lt;/em&gt; for the
obfuscation goal to be achieved without an increase in space usage, if
multiple parties can coordinate their transactions, but here we ignore
this possibility because it requires all parties to agree that all
attributes except A to be identical (example: multiple participants must
accept their newly created outputs are equal value). This is not really
a "transaction" in the normal sense.&lt;/p&gt;
&lt;p&gt;A concrete example: equal-sized Coinjoin in Bitcoin:&lt;/p&gt;
&lt;p&gt;P = Bitcoin&lt;/p&gt;
&lt;p&gt;A = receiver of funds in a transaction&lt;/p&gt;
&lt;p&gt;A[N] = set of N outputs of equal size&lt;/p&gt;
&lt;p&gt;M = Coinjoin&lt;/p&gt;
&lt;p&gt;A less obvious example but fitting the same pattern; ElGamal commitment
based Confidential Transactions (as opposed to Pedersen commitments
based)&lt;/p&gt;
&lt;p&gt;P = Bitcoin&lt;/p&gt;
&lt;p&gt;A = output amount in a transaction&lt;/p&gt;
&lt;p&gt;A[N] = ElGamal commitment to amount, here 2 curve points, N=2&lt;/p&gt;
&lt;p&gt;M = ElGamal commitments&lt;/p&gt;
&lt;p&gt;Here N=2 requires some explaining. An ElGamal commitment is perfectly
binding, and to achieve that goal the commitment must have 2 points, as
the input has two values (scalars), one for blinding and the other for
binding the amount. So we see in this case the expansion in practice is
more than just a single integer, it's from a single bitcoin-encoded
integer to two curve points. But the details obviously vary; the general
concept is to whatever extent we obfuscate, without throwing in extra
security assumptions, we require more data.&lt;/p&gt;
&lt;h2&gt;Verification - public or private?&lt;/h2&gt;
&lt;p&gt;The structure above is trying to make an argument, which I believe is
pretty strong - that this represents searching for privacy, in a
blockchain context, in slightly the wrong way.&lt;/p&gt;
&lt;p&gt;If we try to make the &lt;em&gt;blockchain&lt;/em&gt; itself private, we are slightly
pushing against its inherent nature. Its crucial feature is
&lt;strong&gt;public verifiability&lt;/strong&gt;, and
while it's true that this does not require all attributes properties to
be "unblinded" nor "unobfuscated", we see above that introducing
blinding or obfuscation is problematic; you either degrade security in a
way that's not acceptable because it introduces invisible breaks, or you
degrade scalability (such as using a perfectly binding commitment
requiring no compression, or a zero knowledge proof taking up a lot of
space or computation time), or you degrade trustlessness (see: trusted
setup zkps). I have no absolute theorem that says that you cannot get
rid of all of these problems simultaneously; but it certainly seems
hard!&lt;/p&gt;
&lt;p&gt;This is where the idea of a "steganographic blockchain" comes in; if
instead of trying to hide attributes of transactions, we try to make the
&lt;em&gt;meaning&lt;/em&gt; of transactions be something not explicit to the chain, but
agreed upon by arbitrary participants using mechanisms outside it. This
allows one to leverage the blockchain's principal feature - censorship
resistant proof of state changes, in public, without inheriting its main
bugs - lack of privacy and scalability, and without degrading its own
security.&lt;/p&gt;
&lt;p&gt;Examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Colored coins&lt;/li&gt;
&lt;li&gt;Crude example: atomic swaps&lt;/li&gt;
&lt;li&gt;Lightning and second-layer&lt;/li&gt;
&lt;li&gt;Chaumian tokens&lt;/li&gt;
&lt;li&gt;Client-side validation (single use seals)&lt;/li&gt;
&lt;li&gt;Scriptless scripts&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;High bandwidth steganography&lt;/h2&gt;
&lt;p&gt;The biggest practical problem with steganography has always been
bandwidth; if you use non-random data such as images or videos, which
are often using compression algorithms to maximise their signal to noise
ratio, you have the problem of getting sufficient "cover traffic" over
your hidden message.&lt;/p&gt;
&lt;p&gt;Note that this problem does not occur &lt;strong&gt;at all&lt;/strong&gt; in cases where your
hidden message is embedded into another message which is random. This is
the case with digital signatures; ECDSA and Schnorr for example are both
publish as two random values each of which is about 32 bytes.&lt;/p&gt;
&lt;p&gt;To go back to the previously mentioned example of scriptless scripts, we
can see that the atomic swap protocol based on it as described in my
&lt;a href="https://web.archive.org/web/20200603112526/https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/"&gt;blog
post&lt;/a&gt;,
exploits this directly. On chain we see two (not obviously related)
transactions with Schnorr signatures that are, to the outside observer,
in no way related; the hiding of the connection is perfect, but the
binding/atomicity of the two payments is still secure, just not
perfectly so (it's based on the ECDLP hardness assumption, but then so
are ordinary payments).&lt;/p&gt;
&lt;p&gt;Note how this is a different philosophy/approach to hiding/privacy:
since such a swap leaves no fingerprint on-chain, the concept of
anonymity set blurs; it's strictly all transactions (assuming Schnorr in
future, or ECDSA-2PC now), even if most people do not use the technique.
To get that same effect with an enforced privacy overlay mechanism M for
all participants, we tradeoff the security or scalability issues
mentioned above.&lt;/p&gt;
&lt;p&gt;This is the reason for my slightly click-baity-y subtitle "High
Bandwidth Steganography". A big chunk of the Bitcoin blockchain is
random (as those who've tried to compress it have learned to their
chagrin), and so it's not quite as hard to usual to hide transaction
semantics (the ideal case will be inside signatures using scriptless
script type constructs), so in a sense we can get a very high bandwidth
of data communicated client to client without using any extra space on
chain, and without "polluting" the chain with extra security
assumptions.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="bitcoin"></category><category term="cryptography"></category></entry><entry><title>Flipping the scriptless script on Schnorr</title><link href="https://joinmarket.me/blog/blog/flipping-the-scriptless-script-on-schnorr/" rel="alternate"></link><published>2018-03-15T00:00:00+01:00</published><updated>2018-03-15T00:00:00+01:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2018-03-15:/blog/blog/flipping-the-scriptless-script-on-schnorr/</id><summary type="html">&lt;p&gt;using scriptless scripts for atomic swaps&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Flipping the scriptless script on Schnorr&lt;/h3&gt;
&lt;h2&gt;Outline&lt;/h2&gt;
&lt;p&gt;It's by now very well known in the community of Bitcoin enthusiasts that
the &lt;a href="https://en.wikipedia.org/wiki/Schnorr_signature"&gt;Schnorr
signature&lt;/a&gt;
may have great significance; and "everyone knows" that its significance
is that it will enable signatures to be aggregated, which could be
&lt;strong&gt;great&lt;/strong&gt; for scalability, and nice for privacy too. This has been
elucidated quite nicely in a Bitcoin Core &lt;a href="https://bitcoincore.org/en/2017/03/23/schnorr-signature-aggregation/"&gt;blog
post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is very true.&lt;/p&gt;
&lt;p&gt;There are more fundamental reasons to like Schnorr too; it can be shown
with a simple proof that Schnorr signatures are secure if the elliptic
curve crypto that prevents someone stealing your coins (basically the
"Elliptic Curve Discrete Logarithm Problem" or ECDLP for short) is
secure, and assuming the hash function you're using is secure (see &lt;a href="https://blog.cryptographyengineering.com/2011/09/29/what-is-random-oracle-model-and-why-3/"&gt;this
deep dive into the random oracle
model&lt;/a&gt;
if you're interested in such things). ECDSA doesn't have the same level
of mathematical surety.&lt;/p&gt;
&lt;p&gt;Perhaps most importantly of all Schnorr signatures are &lt;strong&gt;linear&lt;/strong&gt; in the
keys you're using (while ECDSA is not).&lt;/p&gt;
&lt;p&gt;Which brings me to my lame pun-title : another way that Schnorr
signatures may matter is to do with, in a sense, the &lt;strong&gt;opposite&lt;/strong&gt; of
Schnorr aggregation - Schnorr subtraction. The rest of this very long
blog post is intended to lead you through the steps to showing how
clever use of signature subtraction can lead to &lt;span
style="text-decoration: underline;"&gt;one&lt;/span&gt; very excellent outcome
(there are others!) - a private Coinswap that's simpler and better than
the private Coinswap outlined in my &lt;a href="https://web.archive.org/web/20200506162002/https://joinmarket.me/blog/blog/coinswaps"&gt;previous blog
post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The ideas being laid out in the rest of this post are an attempt to
concretize work that, as far as I know, is primarily that of Andrew
Poelstra, who has coined the term "&lt;strong&gt;scriptless scripts&lt;/strong&gt;" to describe a
whole set of applications, usually but not exclusively leveraging the
linearity of Schnorr signatures to achieve goals that otherwise are not
possible without a system like Bitcoin's
&lt;a href="https://en.bitcoin.it/wiki/Script"&gt;Script&lt;/a&gt;.
This was partly motivated by Mimblewimble (another separate, huge
topic), but it certainly isn't limited to that. The broad overview of
these ideas can be found in these
&lt;a href="https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2017-05-milan-meetup/slides.pdf"&gt;slides&lt;/a&gt;
from Poelstra's Milan presentation last May.&lt;/p&gt;
&lt;p&gt;So what follows is a series of constructions, starting with Schnorr
itself, that will (hopefully) achieve a goal: an on-chain atomic
coinswap where the swap of a secret occurs, on chain, inside the
signatures - but the secret remains entirely invisible to outside
observers; only the two parties can see it.&lt;/p&gt;
&lt;p&gt;If you and I agree between ourselves that the number to subtract is 7,
you can publish "100" on the blockchain and nobody except me will know
that our secret is "93". Something similar (but more powerful) is
happening here; remember signatures are actually just numbers; the
reason it's "more powerful" is that we can enforce the revealing of the
secret by the other party if the signature is valid, and coins
successfully spent.&lt;/p&gt;
&lt;p&gt;Before we therefore dive into how it works, I wanted to mention why this
idea struck me as so important; after talking to Andrew and seeing the
slides and talk referenced above, I
&lt;a href="https://twitter.com/waxwing__/status/862724170802761728"&gt;tweeted&lt;/a&gt;
about it:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;If we can take the &lt;em&gt;semantics&lt;/em&gt; of transactions off-chain in this kind
of way, it will more and more improve what Bitcoin (or any other
blockchain) can do - we can transact securely without exposing our
contracts to the world, and we can reduce blockchain bloat by using
secrets embedded in data that is already present. The long term vision
would be to allow the blockchain itself to be a *very* lean contract
enforcement mechanism, with all the "rich statefulness" .. client-side
;)&lt;span style="text-decoration: underline;"&gt;
&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;Preliminaries: the Schnorr signature itself&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;(Notation: We'll use &lt;code&gt;||&lt;/code&gt; for concatenation and capitals for elliptic
curve points and lower case letters for scalars.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you want to understand the construction of a Schnorr signature well,
I can recommend Oleg Andreev's compact and clear
&lt;a href="http://blog.oleganza.com/post/162861219668/eli5-how-digital-signatures-actually-work"&gt;description&lt;/a&gt;
; also nice is Section 1 in the Maxwell/Poelstra Borromean Ring
Signatures
&lt;a href="https://github.com/Blockstream/borromean_paper"&gt;paper&lt;/a&gt;,
although there are of course tons of other descriptions out there. We'll
write it in basic form as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;s = r + e * x&lt;/span&gt;
&lt;span class="err"&gt;e = H(P||R||m)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note: we can hash, as "challenge" a la &lt;a href="https://en.wikipedia.org/wiki/Proof_of_knowledge#Sigma_protocols"&gt;sigma
protocol&lt;/a&gt;,
just &lt;code&gt;R||m&lt;/code&gt; in some cases, and more complex things than just &lt;code&gt;P||R||m&lt;/code&gt;,
too; this is just the most fundamental case, fixing the signature to a
specific pubkey; the nonce point &lt;code&gt;R&lt;/code&gt; is always required).&lt;/p&gt;
&lt;p&gt;For clarity, in the above, &lt;code&gt;x&lt;/code&gt; is the private key, &lt;code&gt;m&lt;/code&gt; is the message,
&lt;code&gt;r&lt;/code&gt; is the "nonce" and &lt;code&gt;s&lt;/code&gt; is the signature. The signature is published
as either &lt;code&gt;(s, R)&lt;/code&gt; or &lt;code&gt;(s, e)&lt;/code&gt;, the former will be used here if
necessary.&lt;/p&gt;
&lt;p&gt;Apologies if people are more used to &lt;code&gt;s = r - ex&lt;/code&gt;, for some reason it's
always &lt;code&gt;+&lt;/code&gt; to me!&lt;/p&gt;
&lt;p&gt;Note the linearity, in hand-wavy terms we can say:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;s_1 = r_1 + e * x_1&lt;/span&gt;
&lt;span class="err"&gt;s_2 = r_2 + e * x_2&lt;/span&gt;
&lt;span class="err"&gt;e = H(P_1 + P2 || R_1 + R_2 || m)&lt;/span&gt;
&lt;span class="err"&gt;=&amp;gt;&lt;/span&gt;
&lt;span class="err"&gt;s_1 + s_2 is a valid signature for public key (P_1 + P_2) on m.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;But this is &lt;strong&gt;NOT&lt;/strong&gt; a useable construction as-is: we'll discuss how
aggregation of signatures is achieved properly later, briefly.&lt;/p&gt;
&lt;h4&gt;Construction of an "adaptor" signature&lt;/h4&gt;
&lt;p&gt;This is the particular aspect of Poelstra's "scriptless script" concept
that gets us started leveraging the Schnorr signature's linearity to do
fun things. In words, an "adaptor signature" is a not a full, valid
signature on a message with your key, but functions as a kind of
"promise" that a signature you agree to publish will reveal a secret, or
equivalently, allows creation of a valid signature on your key for
anyone possessing that secret.&lt;/p&gt;
&lt;p&gt;Since this is the core idea, it's worth taking a step back here to see
how the idea arises: you want to do a similar trick to what's already
been done in atomic swaps: to enforce the atomicity of (spending a coin:
revealing a secret); but without Script, you can't just appeal to
something like &lt;code&gt;OP_HASH160&lt;/code&gt;; if you're stuck in ECC land, all you have
is scalar multiplication of elliptic curve points; but luckily that
function operates similar to a hash function in being one-way; so you
simply share an elliptic curve point (in this case it will be &lt;code&gt;T&lt;/code&gt;), and
the secret will be its corresponding private key. The beatiful thing is,
it &lt;em&gt;is&lt;/em&gt; possible to achieve that goal directly in the ECC Schnorr
signing operation.&lt;/p&gt;
&lt;p&gt;Here's how Alice would give such an adaptor signature to Bob:&lt;/p&gt;
&lt;p&gt;Alice (&lt;code&gt;P = xG&lt;/code&gt;), constructs for Bob:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Calculate &lt;code&gt;T = tG&lt;/code&gt;, &lt;code&gt;R = rG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calculate &lt;code&gt;s = r + t + H(P || R+T || m) * x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Publish (to Bob, others): &lt;code&gt;(s', R, T)&lt;/code&gt; with &lt;code&gt;s' = s - t&lt;/code&gt; (so &lt;code&gt;s'&lt;/code&gt;
    should be "adaptor signature"; this notation is retained for the
    rest of the document).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bob can verify the adaptor sig &lt;code&gt;s'&lt;/code&gt; for &lt;code&gt;T,m&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;s&amp;#39; * G ?= R + H(P || R+T || m) * P&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is not a valid sig: hashed nonce point is &lt;code&gt;R+T&lt;/code&gt; not &lt;code&gt;R&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;Bob cannot retrieve a valid sig : to recover &lt;code&gt;s'+t&lt;/code&gt; requires ECDLP
solving.&lt;/p&gt;
&lt;p&gt;After validation of adaptor sig by Bob, though, he knows:&lt;/p&gt;
&lt;p&gt;Receipt of &lt;code&gt;t&lt;/code&gt; &amp;lt;=&amp;gt; receipt of valid sig &lt;code&gt;s = s' + t&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;Deniability:&lt;/h4&gt;
&lt;p&gt;This is a way of concretizing the concept that all of this will be
indistinguishable to an observer of the blockchain, that is to say, an
observer only of the final fully valid signatures:&lt;/p&gt;
&lt;p&gt;Given any &lt;code&gt;(s, R)&lt;/code&gt; on chain, create &lt;code&gt;(t, T)&lt;/code&gt;, and assert that the
adaptor signature was: &lt;code&gt;s' = s - t&lt;/code&gt;, with &lt;code&gt;R' = R - T&lt;/code&gt;, so adaptor
verify eqn was: &lt;code&gt;s'G = R' + H(P || R'+T || m)P&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4&gt;Moving to the 2-of-2 case, with Schnorr&lt;/h4&gt;
&lt;p&gt;For the remainder, we're considering the matter of signing off
transactions from outpoints jointly owned (2 of 2) by Alice and Bob.&lt;/p&gt;
&lt;p&gt;Start by assuming Alice has keypair &lt;code&gt;(x_A, P_A)&lt;/code&gt;, and Bob &lt;code&gt;(x_B, P_B)&lt;/code&gt;.
Each chooses a random nonce point &lt;code&gt;r_A&lt;/code&gt;, &lt;code&gt;r_B&lt;/code&gt; and exchanges the curve
points with each other (&lt;code&gt;P_A, R_A, P_B, R_B&lt;/code&gt;) to create a
scriptPubKey/destination address.&lt;/p&gt;
&lt;h4&gt;2-of-2 Schnorr without adaptor sig&lt;/h4&gt;
&lt;p&gt;To avoid related-key attacks (if you don't know what that means see e.g.
the "Cancelation" section in
&lt;a href="https://diyhpl.us/wiki/transcripts/scalingbitcoin/milan/schnorr-signatures/"&gt;https://diyhpl.us/wiki/transcripts/scalingbitcoin/milan/schnorr-signatures/&lt;/a&gt;),
the "hash challenge" is made more complex here, as was noted in the
first section on Schnorr signatures. The two parties Alice and Bob,
starting with pubkeys &lt;code&gt;P_A&lt;/code&gt;, &lt;code&gt;P_B&lt;/code&gt;, construct for themselves a "joint
key" thusly:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;P_A&amp;#39; = H(H(P_A||P_B) || P_A) * P_A ,&lt;/span&gt;
&lt;span class="err"&gt;P_B&amp;#39; = H(H(P_A||P_B) || P_B) * P_B ,&lt;/span&gt;
&lt;span class="err"&gt;joint_key = P_A&amp;#39; + P_B&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note that Alice possesses the private key for &lt;code&gt;P_A'&lt;/code&gt; (it's
&lt;code&gt;H(H(P_A||P_B) || P_A) * x_A&lt;/code&gt;, we call it &lt;code&gt;x_A'&lt;/code&gt; for brevity), and
likewise does Bob. From now on, we'll call this "joint_key" &lt;code&gt;J(A, B)&lt;/code&gt;
to save space.&lt;/p&gt;
&lt;p&gt;Common hash challenge:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;H(J(A, B) || R_A + R_B || m) = e&lt;/span&gt;
&lt;span class="err"&gt;s_agg = = r_A + r_B + e(x_A&amp;#39; + x_B&amp;#39;)&lt;/span&gt;
&lt;span class="err"&gt;-&amp;gt; s_agg * G = R_A + R_B + e * J(A, B)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Alice's sig: &lt;code&gt;s_A = r_A + e * x_A'&lt;/code&gt;, Bob's sig: &lt;code&gt;s_B = r_B + e * x_B'&lt;/code&gt;
and of course: &lt;code&gt;s_agg = s_A + s_B&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There is, as I understand it, more to say on this topic, see
e.g.&lt;a href="http://diyhpl.us/wiki/transcripts/bitcoin-core-dev-tech/2017-09-06-signature-aggregation/"&gt;here&lt;/a&gt;,
but it's outside my zone of knowledge, and is somewhat orthogonal to the
topic here.&lt;/p&gt;
&lt;h4&gt;2-of-2 with adaptor sig&lt;/h4&gt;
&lt;p&gt;Now suppose Bob chooses &lt;code&gt;t&lt;/code&gt; s.t. &lt;code&gt;T = t * G&lt;/code&gt;, and Bob is going to
provide an adaptor signature for his half of the 2-of-2.&lt;/p&gt;
&lt;p&gt;Then:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Alice, Bob share &lt;code&gt;P_A, P_B, R_A, R_B&lt;/code&gt; as above; Bob gives &lt;code&gt;T&lt;/code&gt; to
    Alice&lt;/li&gt;
&lt;li&gt;Alice and Bob therefore agree on
    &lt;code&gt;e = H(J(A, B) || R_A + R_B + T || m)&lt;/code&gt; (note difference, &lt;code&gt;T&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Bob provides adaptor &lt;code&gt;s' = r_B + e * x_B'&lt;/code&gt; (as in previous section,
    not a valid signature, but verifiable)&lt;/li&gt;
&lt;li&gt;Alice verifies: &lt;code&gt;s' * G ?= R_B + e * P_B'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If OK, Alice sends to Bob her sig: &lt;code&gt;s_A = r_A + e * x_A'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Bob completes, atomically releasing &lt;code&gt;t&lt;/code&gt;: first, construct
    &lt;code&gt;s_B = r_B + t + e * x_B'&lt;/code&gt;, then combine: &lt;code&gt;s_agg = s_A + s_B&lt;/code&gt; and
    broadcast, then Alice sees &lt;code&gt;s_agg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Alice subtracts:
    &lt;code&gt;s_agg - s_A - s' = (r_B + t + e * x_B') - (r_B + e * x_B') = t&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Thus the desired property is achieved: &lt;code&gt;t&lt;/code&gt; is revealed by a validating
"completion" of the adaptor signature.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;, however that this has no timing control, Bob can jam the
protocol indefinitely at step 6, forcing Alice to wait (assuming that
what we're signing here is a transaction out of a shared-control
outpoint); this is addressed in the fleshed out protocol in the next
section, though.&lt;/p&gt;
&lt;p&gt;For the remainder, we'll call the above 7 steps the 22AS protocol, so
&lt;code&gt;22AS(Bob,t, Alice)&lt;/code&gt; for Bob, secret &lt;code&gt;t&lt;/code&gt;, and Alice. Bob is listed first
because he holds &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since this is the most important part of the construction, we'll
summarize it with a schematic diagram:&lt;/p&gt;
&lt;p&gt;&lt;img src="/web/20200506162002im_/https://joinmarket.me/static/media/uploads/.thumbnails/22AS.jpg/22AS-1056x816.jpg" width="1056" height="816" alt="22AS protocol" /&gt;&lt;/p&gt;
&lt;p&gt;So this &lt;code&gt;22AS&lt;/code&gt; was a protocol to swap a coin for a secret, to do atomic
swaps we need to extend it slightly: have two transactions atomic via
the same secret &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;The Atomic Swap construct, using 2-of-2 schnorr + adaptor signatures&lt;/h3&gt;
&lt;p&gt;This is now &lt;em&gt;fairly&lt;/em&gt; straightforward, inheriting the main design from
the existing "atomic swap" protocol.&lt;/p&gt;
&lt;p&gt;A. Alice and Bob agree on a pair of scriptPubkeys which are based on 2
of 2 pubkeys using Schnorr, let's name them using &lt;code&gt;D&lt;/code&gt; for destination
address (&lt;code&gt;A&lt;/code&gt; is taken by Alice): &lt;code&gt;D_1&lt;/code&gt; being 2-2 on (&lt;code&gt;P_A1&lt;/code&gt;, &lt;code&gt;P_B1&lt;/code&gt;) and
&lt;code&gt;D_2&lt;/code&gt; being 2-2 on (&lt;code&gt;P_A2&lt;/code&gt;, &lt;code&gt;P_B2&lt;/code&gt;). Note that these pubkeys, and
therefore destination addresses, are not dependent in any way on
"adaptor" feature (which is a property only of nonces/sigs, not keys).&lt;/p&gt;
&lt;p&gt;B. Alice prepares a transaction TX1 paying 1 coin into &lt;code&gt;D_1&lt;/code&gt;, shares
txid_1, and requires backout transaction signature from Bob. Backout
transaction pays from txid_1 to Alice's destination but has locktime
&lt;code&gt;L1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;C. Bob does the (nearly) exact mirror image of the above: prepares TX2
paying 1 coin into &lt;code&gt;D_2&lt;/code&gt;, shares txid_2, requires backout transaction
signature from Alice. Backout transaction pays from txid_2 to Bob's
destination with locktime &lt;code&gt;L2&lt;/code&gt; which is &lt;em&gt;significantly later&lt;/em&gt; than &lt;code&gt;L1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;D. Then Alice and Bob broadcast TX1 and TX2 respectively and both sides
wait until both confirmed. If one party fails to broadcast, the other
uses their backout to refund.&lt;/p&gt;
&lt;p&gt;E. If both txs confirmed (N blocks), Alice and Bob follow steps 1-4 of
&lt;code&gt;22AS(Bob, t, Alice)&lt;/code&gt; (described in previous section) for some &lt;code&gt;t&lt;/code&gt;, for
both the scriptPubkeys &lt;code&gt;D_1&lt;/code&gt; and &lt;code&gt;D_2&lt;/code&gt;, in parallel, but with the same
secret &lt;code&gt;t&lt;/code&gt; in each case (a fact which Alice verifies by ensuring use of
same &lt;code&gt;T&lt;/code&gt; in both cases). For the first (&lt;code&gt;D_1&lt;/code&gt;) case, they are signing a
transaction spending 1 coin to Bob. For the second, &lt;code&gt;D_2&lt;/code&gt;, they are
signing a transaction spending 1 coin to Alice. Note that at the end of
these steps Alice will possess a verified adaptor sig &lt;code&gt;s'&lt;/code&gt; for &lt;em&gt;both&lt;/em&gt; of
the spend-outs from &lt;code&gt;D_1, D_2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;E(a). Any communication or verification failure in those 1-4 steps (x2),
both sides must fall back to timelocked refunds.&lt;/p&gt;
&lt;p&gt;F. The parties then complete (steps 5-7) the first &lt;code&gt;22AS(Bob, t, Alice)&lt;/code&gt;
for the first transaction TX1, spending to &lt;code&gt;D_1&lt;/code&gt; to give Bob 1 coin.
Alice receives &lt;code&gt;t&lt;/code&gt; as per step 7.&lt;/p&gt;
&lt;p&gt;F(a). As was mentioned in the previous section, Bob can jam the above
protocol at step 6: if he does, Alice can extract her coins from her
timelocked refund from &lt;code&gt;D_1&lt;/code&gt; in the period between &lt;code&gt;L1&lt;/code&gt; and &lt;code&gt;L2&lt;/code&gt;. The
fact that &lt;code&gt;L2&lt;/code&gt; is (significantly) later is what prevents Bob from
backing out his own spend into &lt;code&gt;D_2&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; claiming Alice's coins from
&lt;code&gt;D_1&lt;/code&gt; using the signature provided in step 5. (Note this time asymmetry
is common to all atomic swap variants).&lt;/p&gt;
&lt;p&gt;G. (Optionally Bob may transmit &lt;code&gt;t&lt;/code&gt; directly over the private channel,
else Alice has to read it from the blockchain (as per above &lt;code&gt;22AS&lt;/code&gt;
protocol) when Bob publishes his spend out of &lt;code&gt;D_1&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;H. Alice can now complete the equivalent of steps 5-7 without Bob's
involvement for the second parallel run for &lt;code&gt;D_2&lt;/code&gt;: she has &lt;code&gt;t&lt;/code&gt;, and adds
it to the already provided &lt;code&gt;s'&lt;/code&gt; adaptor sig for the transaction paying
her 1 coin from &lt;code&gt;D_2&lt;/code&gt; as per first 4 steps. This &lt;code&gt;s' + t&lt;/code&gt; is guaranteed
to be a valid &lt;code&gt;s_B&lt;/code&gt;, so she adds it to her own &lt;code&gt;s_A&lt;/code&gt; to get a valid
&lt;code&gt;s_agg&lt;/code&gt; for this spend to her of 1 coin, and broadcasts.&lt;/p&gt;
&lt;h2&gt;Summing up&lt;/h2&gt;
&lt;h4&gt;Privacy implications&lt;/h4&gt;
&lt;p&gt;In absence of backouts being published (i.e. in cooperative case), these
scriptPubkeys will be the same as any other Schnorr type ones (N of N
multisig will not be distinguishable from 1 of 1). The signatures will
not reveal anything about the shared secret &lt;code&gt;t&lt;/code&gt;, or the protocol carried
out, so the 2 transaction pairs (pay-in to &lt;code&gt;D_1,D_2&lt;/code&gt;, pay out from same)
will not be tied together in that regard.&lt;/p&gt;
&lt;p&gt;This construction, then, will (at least attempt to) gain the anonymity
set of all Schnorr sig based transactions. The nice thing about
Schnorr's aggregation win is, even perhaps more than segwit, the
economic incentive to use it will be strong due to the size compaction,
so this anonymity set should be big (although this is all a bit pie in
the sky for now; we're a way off from it being concrete).&lt;/p&gt;
&lt;p&gt;The issue of amount correlation, however, has &lt;strong&gt;not&lt;/strong&gt; been in any way
addressed by this, of course. It's a sidebar, but one interesting idea
about amount correlation breaking was brought up by Chris Belcher
&lt;a href="https://github.com/AdamISZ/CoinSwapCS/issues/47"&gt;here&lt;/a&gt;
; this may be a fruitful avenue whatever the flavour of Coinswap we're
discussing.&lt;/p&gt;
&lt;h4&gt;Comparison with other swaps&lt;/h4&gt;
&lt;p&gt;Since we've now, in this blog post and the previous, seen 3 distinct
ways to do an atomic coin swap, the reader is forgiven for being
confused. This table summarizes the 3 different cases:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;Type&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Privacy on-chain&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Separate "backout/refund" transactions for non-cooperation&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Requires segwit&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Requires Schnorr&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Number of transactions in cooperative case&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Number of transactions in non-cooperative case&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Space on chain&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Atomic swap&lt;/td&gt;
&lt;td&gt;None; trivially linkable&lt;/td&gt;
&lt;td&gt;None; backout is directly in script&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2 + 2&lt;/td&gt;
&lt;td&gt;2 + 2&lt;/td&gt;
&lt;td&gt;Medium&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CoinSwap&lt;/td&gt;
&lt;td&gt;Anonymity set: 2 of 2 transactions (+2 of 3 depending on setup)&lt;/td&gt;
&lt;td&gt;Presigned backouts using H(X) and CLTV, break privacy if used&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;No&lt;/td&gt;
&lt;td&gt;2 + 2&lt;/td&gt;
&lt;td&gt;3 + 3&lt;/td&gt;
&lt;td&gt;Large-ish&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scriptless script&lt;/td&gt;
&lt;td&gt;Anonymity set: all Schnorr transactions&lt;/td&gt;
&lt;td&gt;Presigned backouts uslng locktime; semi-break privacy (other txs may use locktime)&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;td&gt;2 + 2&lt;/td&gt;
&lt;td&gt;2 + 2&lt;/td&gt;
&lt;td&gt;Small&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The reason that there are "3 + 3" transactions in the non-cooperative
case for CoinSwap is, in that case, both sides pay into a 2-of-2, then
in non-cooperation, they must both spend into the custom "HTLC" (IF
hash, pub, ELSE CLTV, pub), and then redeem *out* of it.&lt;/p&gt;
&lt;p&gt;A fundamental difference for the latter 2 cases, compared with the
first, is they must pay into shared-ownership 2 of 2 outputs in the
pay-in transaction; this is to allow backout transactions to be arranged
(a two-party multi-transaction contract requires this; see e.g.
Lightning for the same thing). The first, bare atomic swap is a single
transaction contract, with the contract condtions embedded entirely in
that one transaction(for each side)'s scriptPubKey.&lt;/p&gt;
&lt;p&gt;Finally, size on-chain of the transactions is boiled down to
hand-waving, because it's a bit of a complex analysis; the first type
always uses a large redeem script but one signature on the pay-out,
whether cooperative or non-cooperative; the second uses 2 or 3
signatures (assuming something about how we attack the anonymity set
problem) but no big redeem script in cooperative case, while takes up a
*lot* of room in the non-cooperative case, the third is always compact
(even non-cooperative backouts take no extra room).
Schnorr-sig-scriptless-scripts are the big winner on space.&lt;/p&gt;
&lt;h4&gt;Extending to multi-hop; Lightning, Mimblewimble&lt;/h4&gt;
&lt;p&gt;The first time I think this was discussed was in the mailing list post
&lt;a href="https://lists.launchpad.net/mimblewimble/msg00086.html%20"&gt;here&lt;/a&gt;,
which discusses how conceivably one could achieve the same setup as HTLC
for Mimblewimble lightning, using this scriptless-script-atomic-swap.
Doubtless these ideas are a long way from being fleshed out, and I
certainly haven't kept up with what's going on there :)&lt;/p&gt;
&lt;h4&gt;Other applications of the scriptless script concept&lt;/h4&gt;
&lt;p&gt;As a reminder, this document was just about fleshing out how the atomic
swap gets done in a Schnorr-signature-scriptless-script world; the
&lt;a href="https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2017-05-milan-meetup/slides.pdf"&gt;slides&lt;/a&gt;
give several other ideas that are related. Multisignature via
aggregation is of course part of it, and is already included even in the
above protocol (for 2 of 2 as a subset of N of N); earlier ideas like
pay-to-contract-hash and sign-to-contract-hash already exist, and don't
require Schnorr, but share a conceptual basis; same for ZKCP, etc.&lt;/p&gt;
&lt;h4&gt;Cross chain swap&lt;/h4&gt;
&lt;p&gt;I admit to not sharing &lt;em&gt;quite&lt;/em&gt; the same breathless excitement about
cross-chain swaps as some people, but it is no doubt very interesting,
if somewhat more challenging (not least because of different "clocks"
(block arrivals) affecting any locktime analysis and confirmation
depth). Poelstra has however also made the very intriguing point that it
is &lt;strong&gt;not&lt;/strong&gt; actually required for the two blockchains to be operating on
the same elliptic curve group for the construction to work.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="cryptography"></category><category term="bitcoin"></category></entry><entry><title>SNICKER</title><link href="https://joinmarket.me/blog/blog/snicker/" rel="alternate"></link><published>2017-09-15T00:00:00+02:00</published><updated>2017-09-15T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2017-09-15:/blog/blog/snicker/</id><summary type="html">&lt;p&gt;a proposal for non-interactive coinjoins.&lt;/p&gt;</summary><content type="html">&lt;h3&gt;SNICKER&lt;/h3&gt;
&lt;h2&gt;SNICKER - Simple Non-Interactive Coinjoin with Keys for Encryption Reused&lt;/h2&gt;
&lt;p&gt;I'm going to do this backwards - start with the end goal user
experience, and then work backwards to the technical design. This way,
those not wanting to get lost in technical details can still get the
gist.&lt;/p&gt;
&lt;h3&gt;&lt;img alt="Me misusing a meme as a symbol and not adding any text." height="330" src="../../../../../../20200510162733im_/https:/joinmarket.me/static/media/uploads/.thumbnails/evilplanbaby.jpg/evilplanbaby-400x330.jpg" width="400"&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Pictured above: me misusing a meme as a symbol and deliberately not
adding any text to it.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Scenario&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Alisa&lt;/strong&gt; lives in Moscow; she is a tech-savvy Bitcoin user, uses Linux
and the command line, and runs a fully verifying Bitcoin Core node. She
doesn't have indexing enabled, but she (sometimes, or long-running)
runs a tool called &lt;code&gt;snicker-scan&lt;/code&gt; on the blocks received by her node. It
scans recent Bitcoin blocks looking for transactions with a particular
pattern, and returns to her in a file a list of candidate transactions.
She pipes this list into another tool which uses her own Bitcoin wallet
and constructs proposals: new transactions involving her own utxos and
utxos from these newly found transactions, which she signs herself.
Then, for each one, she makes up a secret random number and sends (the
proposed transactions + the secrets), encrypted to a certain public key,
in each case, so no one but the owner can read it, to a Tor hidden
service which accepts such submissions. For now, her job is done and she
gets on with her day.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bob&lt;/strong&gt; lives in New York. He's a Bitcoin enthusiast who uses it a lot,
and likes to test out new features, but has never written code and
isn't tech-savvy like that. A few hours after Alisa went to bed he
opens one of his mobile wallets and a message pops up:
&lt;code&gt;New coinjoin proposals found. Check?&lt;/code&gt;. He heard about this, and heard
that you can improve your privacy with this option, and even sometimes
gain a few satoshis in the process. So he clicks &lt;code&gt;Yes&lt;/code&gt;. In the
background his mobile wallet downloads a file of some 5-10MB (more on
this later!). Bob did this once before and was curious about the file;
when he opened it he saw it was text with lots of unintelligible
encrypted stuff like this:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QklFMQOVXvpqgjaJFm00QhuJ1iWsnYYV4yJLjE0LaXa8N8c34Hzg5CeQduV.....&lt;/code&gt;\
&lt;code&gt;QklFMQI2JR50dOGEQdDdmeX0BwMH4c+yEW1v5/IyT900WBGdYRA/T5mqBMc.....&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Now his mobile does some processing on this file; it takes a little
while, some seconds perhaps, processing in the background. At the end it
pops up a new message:
&lt;code&gt;Coinjoin transaction found. Would you like to broadcast it?&lt;/code&gt; and
underneath it shows the transaction spending 0.2433 BTC out of his
wallet and returning 0.2434 BTC in one of the outputs. It shows that the
other inputs and outputs are not his, although one of them is also for
0.2434 BTC. Does he want to accept? Sure! Free money even if it's only
cents. Even with no free money, he knows that coinjoin makes his privacy
better. So he clicks &lt;code&gt;Yes&lt;/code&gt; and it's broadcast. Done.&lt;/p&gt;
&lt;h3&gt;The NIC in SNICKER&lt;/h3&gt;
&lt;p&gt;Non-interactivity is a hugely desirable property in protocols; this is
particularly the case where privacy is a priority. Firstly, it avoids
the need to synchronize (&lt;strong&gt;Alisa&lt;/strong&gt;, and her computer, had gone to sleep
when &lt;strong&gt;Bob&lt;/strong&gt; performed his step). Second, to avoid malicious
interruption of an interactive protocol, it can help to identify the
participants, but that is very damaging to the whole point of a protocol
whose goal is privacy. Non-interactivity cuts this particular Gordian
knot; one side can send the message anonymously and the other
participant simply uses the data, but this has the limitation of the
sender finding the receiver, which means some weak identification of the
latter. Even better is if the request can be sent encrypted to the
receiver, then it can be broadcast anywhere for the receiver to notice.
That latter model is the most powerful, and is used here, but it does
have practicality drawbacks as we'll discuss.&lt;/p&gt;
&lt;p&gt;So, note that in the above scenario &lt;strong&gt;Alisa&lt;/strong&gt; and &lt;strong&gt;Bob&lt;/strong&gt; do not meet,
do not synchronize, and need never meet or find out who each other are
in future either. Their "meeting" is entirely abstracted out to one
side publishing an encrypted message and the other side receiving &lt;em&gt;all&lt;/em&gt;
such encrypted messages and only reading the one(s) encrypted to his
pubkey. The &lt;em&gt;all&lt;/em&gt; part helps preserve Bob's privacy, if he finds a way
to broadcast the final transaction with a reasonable anonymity defence
(see e.g.
&lt;a href="https://github.com/gfanti/bips/blob/master/bip-dandelion.mediawiki"&gt;Dandelion&lt;/a&gt;;
I'm of the opinion that that battle - making Bitcoin transaction
broadcast anonymous - is something we &lt;em&gt;will&lt;/em&gt; win, there is a massive
asymmetry in favour of the privacy defender there).&lt;/p&gt;
&lt;h3&gt;Quick background - how to do a Coinjoin&lt;/h3&gt;
&lt;p&gt;Here's the obligatory
&lt;a href="https://bitcointalk.org/index.php?topic=279249.0"&gt;link&lt;/a&gt;
to the Coinjoin OP. You can skip this section if you know Coinjoin well.&lt;/p&gt;
&lt;p&gt;Otherwise, I'll give you a quick intro here, one that naturally leads
into the SNICKER concept:&lt;/p&gt;
&lt;p&gt;Each input to a transaction requires (for the transaction to be valid) a
signature by the owner of the private key (using singular deliberately,
restricting consideration to p2pkh or segwit equivalent here) over a
message which is \~ the transaction. Each of these signatures can be
constructed separately, by separate parties if indeed the private key
for each input are owned by separate parties. The "normal" coinjoining
process thus involves the following steps (for now, not specifying &lt;em&gt;who&lt;/em&gt;
carries out each step):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gather all of the inputs - the utxos that will be spent&lt;/li&gt;
&lt;li&gt;Gather all of the destination addresses to various parties, and the
    amounts to be paid&lt;/li&gt;
&lt;li&gt;Distribute a "template" of the transaction to all parties (i.e.
    the transaction without any signatures)&lt;/li&gt;
&lt;li&gt;In some order all of the parties sign the transaction; whomever has
    a transaction with all signatures complete, can broadcast it to the
    Bitcoin network&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are different protocols one can choose to get all these steps
done, ranging from simple to complex. A server can be the coordinating
party; blinding can be used to prevent the server knowing input-output
mapping.
&lt;a href="http://crypsys.mmci.uni-saarland.de/projects/CoinShuffle/"&gt;Coinshuffle&lt;/a&gt;
can be used, creating a kind of onion-routing approach to prevent
parties involved knowing the linkages (doesn't require a server to
coordinate, but requires more complex interactivity). One of the parties
in the join can be the "server", thus that party gains privacy that
the others don't (Joinmarket). Etc.&lt;/p&gt;
&lt;p&gt;The difficulties created by any interactivity are considerably
ameliorated in a client-server model (see e.g. the old blockchain.info
&lt;a href="https://en.bitcoin.it/wiki/Shared_coin"&gt;SharedCoin&lt;/a&gt;(link
outdated) model), the serious tradeoff is the server knowing too much,
and/or a coordination/waiting problem (which may be considered
tolerable; see both SharedCoin and
&lt;a href="https://github.com/darkwallet/darkwallet"&gt;DarkWallet&lt;/a&gt;;
with a sufficient liquidity pool the waiting may be acceptable).&lt;/p&gt;
&lt;p&gt;There are a lot of details to discuss here, but there is always &lt;em&gt;some&lt;/em&gt;
interactivity (you can only sign once you know the full transaction,
assuming no custom sighashing^1^), and a model with a server is
basically always going to be more problematic, especially at scale.&lt;/p&gt;
&lt;p&gt;So hence we try to construct a way of doing at least simple Coinjoins,
in at least some scenarios, without any server requirement or
coordination. Now I'll present the basic technical concept of how to do
this in SNICKER, in 2 versions.&lt;/p&gt;
&lt;h3&gt;First version - snicKER = Keys for Encryption Reused&lt;/h3&gt;
&lt;p&gt;To make the Coinjoin non-interactive, we need it to be the case that
Alisa can post a message for Bob, without explicitly requesting to
create a private message channel with him. This requires encrypting a
message that can then be broadcast (e.g. over a p2p network or on a
bulletin board).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(In case it isn't clear that either encryption or a private message
channel is required, consider that Alice must pass to Bob a secret which
identifies Bob's output address (explained below), critically, and also
her signature, which is on only her inputs; if these are seen in public,
the input-output linkages are obvious to anyone watching, defeating the
usual purpose of Coinjoin.)&lt;/em&gt;&lt;/p&gt;
&lt;h5&gt;Encryption&lt;/h5&gt;
&lt;p&gt;To achieve this we need a public key to encrypt a message to Bob. This
is the same kind of idea as is used in tools like PGP/gpg - only the
owner of the public key's private key can read the message.&lt;/p&gt;
&lt;p&gt;In this "First version" we will assume something naughty on Bob's
part: that he has &lt;strong&gt;reused an address&lt;/strong&gt;! Thus, a public key will exist
on the blockchain which we assume (not guaranteed but likely; nothing
dangerous if he doesn't) he still holds the private key for.&lt;/p&gt;
&lt;p&gt;Given this admittedly unfortunate assumption, we can use a simple and
established encryption protocol such as
&lt;a href="https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme"&gt;ECIES&lt;/a&gt;
to encrypt a message to the holder of that public key.&lt;/p&gt;
&lt;p&gt;Alisa, upon finding such a pubkey, call it &lt;code&gt;PB&lt;/code&gt;, and noting the
corresponding utxo &lt;code&gt;UB&lt;/code&gt;, will need to send, ECIES encrypted to &lt;code&gt;PB&lt;/code&gt;,
several items (mostly wrapped up in a transaction) to Bob to give him
enough material to construct a valid coinjoin without any interaction
with herself:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Her own utxos (just &lt;code&gt;UA&lt;/code&gt; for simplicity)&lt;/li&gt;
&lt;li&gt;Her proposed destination address(s)&lt;/li&gt;
&lt;li&gt;Her proposed amounts for output&lt;/li&gt;
&lt;li&gt;Her proposed bitcoin transaction fee&lt;/li&gt;
&lt;li&gt;The full proposed transaction template using &lt;code&gt;UA&lt;/code&gt; and &lt;code&gt;UB&lt;/code&gt; as inputs
    (the above 4 can be implied from this)&lt;/li&gt;
&lt;li&gt;Her own signature on the transaction using the key for &lt;code&gt;UA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Her proposed destination address &lt;strong&gt;for Bob&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Destination&lt;/h4&gt;
&lt;p&gt;The last point in the above list is of course at first glance not
possible, unless you made some ultra dubious assumptions about shared
ownership, i.e. if Alisa somehow tried to deduce other addresses that
Bob already owns (involving &lt;em&gt;more&lt;/em&gt; address reuse). I don't dismiss this
approach &lt;em&gt;completely&lt;/em&gt; but it certainly looks like a bit of an ugly mess
to build a system based on that. Instead, we can use a very well known
construct in ECC; in English something like "you can tweak a
counterparty's pubkey by adding a point that &lt;em&gt;you&lt;/em&gt; know the private key
for, but you still won't know the private key of the sum". Thus in
this case, Alice, given Bob's existing pubkey &lt;code&gt;PB&lt;/code&gt;, which is the one
she is using to encrypt the message, can construct a new pubkey:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;PB2 = PB + k*G&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;for some 32 byte random value &lt;code&gt;k&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Alice will include the value of &lt;code&gt;k&lt;/code&gt; in the encrypted message, so Bob can
verify that the newly proposed destination is under his control (again
we'll just assume a standard p2pkh address based on &lt;code&gt;PB2&lt;/code&gt;, or a segwit
equivalent).&lt;/p&gt;
&lt;p&gt;Assuming Bob somehow finds this message and successfully ECIES-decrypts
it using the private key of &lt;code&gt;PB&lt;/code&gt;, he now has everything he needs to (if
he chooses), sign and broadcast the coinjoin transaction.&lt;/p&gt;
&lt;h4&gt;A protocol for the most naive version, in broad strokes:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Alisa must have the ability to scan the blockchain to some extent;
    she must find scriptSigs or witnesses containing pubkeys which were
    later reused in new addresses/scriptPubKeys.&lt;/li&gt;
&lt;li&gt;Alisa will use some kind of filtering mechanism to decide which are
    interesting. The most obvious two examples are: amounts under
    control in Bob's utxos matching her desired range, and perhaps age
    of utxos (so likely level of activity of user) or some watermarking
    not yet considered.&lt;/li&gt;
&lt;li&gt;Having found a set of potential candidates, for each case &lt;code&gt;PB, UB&lt;/code&gt;:
    Construct a standard formatted message; here is a simple suggestion
    although in no way definitive:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;&amp;lt;!-- --&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;    8(?) magic bytes and 2 version bytes for the message type&lt;/span&gt;
&lt;span class="err"&gt;    k-value 32 bytes&lt;/span&gt;
&lt;span class="err"&gt;    Partially signed transaction in standard Bitcoin serialization&lt;/span&gt;
&lt;span class="err"&gt;    (optionally padding to some fixed length)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We defer discussing how in practice Bob will get access to the message
later; but note that if he has done this, he already knows the value of
&lt;code&gt;P_B&lt;/code&gt; and will thus know also &lt;code&gt;U_B&lt;/code&gt;. He ECIES-decrypts it, and
recognizes it's for him through correct magic bytes (other messages
encrypted to other pubkeys will come out random).&lt;/p&gt;
&lt;p&gt;Then, this format has sufficient information for Bob to evaluate easily.
First, he can verify that &lt;code&gt;U_B&lt;/code&gt; is in the inputs. Then he can verify
that for 1 of the 2 outputs (simple model) has a scriptPubKey
corresponding to &lt;code&gt;PB2 = PB + k*G&lt;/code&gt;. He can then verify the output amounts
fit his requirements. Finally he can verify the ECDSA signature provided
on &lt;code&gt;U_A&lt;/code&gt; (hence "partially signed transaction"). Given this he can, if
he chooses, sign on &lt;code&gt;UB&lt;/code&gt; using &lt;code&gt;PB&lt;/code&gt; and broadcast. He must of course
keep a permanent record of either &lt;code&gt;k&lt;/code&gt; itself or, more likely, the
private key &lt;code&gt;k + x&lt;/code&gt; (assuming &lt;code&gt;P = x * G&lt;/code&gt;).&lt;/p&gt;
&lt;h3&gt;A proof-of-concept&lt;/h3&gt;
&lt;p&gt;Before going further into details, and discussing the second (probably
superior but not as obviously workable) version of SNICKER, I want to
mention that I very quickly put together some proof of concept code in
&lt;a href="https://github.com/AdamISZ/SNICKER-POC"&gt;this github
repo&lt;/a&gt;;
it uses
&lt;a href="https://github.com/Joinmarket-Org/joinmarket-clientserver"&gt;Joinmarket-clientserver&lt;/a&gt;
as a dependency, implements ECIES in a compatible form to that used by
&lt;a href="https://electrum.org/"&gt;Electrum&lt;/a&gt;,
and allows testing on regtest or testnet, admittedly with a bunch of
manual steps, using the python script &lt;code&gt;snicker-tool.py&lt;/code&gt;. The workflow
for testing is in the README. To extend the testing to more wallets
requires some way to do ECIES as well as some way to construct the
destination addresses as per &lt;code&gt;PB2 = PB + kG&lt;/code&gt; above. I did note that,
usefully, the partially signed transactions can be signed directly in
Bitcoin Core using &lt;code&gt;signrawtransaction&lt;/code&gt; and then &lt;code&gt;sendrawtransaction&lt;/code&gt;
for broadcast, but note that somehow you'll have to recover the
destination address, as receiver, too. Note that there was no attempt at
all to construct a scanning tool for any reused-key transactions here,
and I don't intend to do that (at least, in that codebase).&lt;/p&gt;
&lt;h2&gt;Practical issues&lt;/h2&gt;
&lt;p&gt;In this section will be a set of small subsections describing various
issues that will have to be addressed to make this work.&lt;/p&gt;
&lt;h3&gt;Wallet integration&lt;/h3&gt;
&lt;p&gt;One reason this model is interesting is because it's much more
plausible to integrate into an existing wallet than something like
Joinmarket - which requires dealing with long term interactivity with
other participants, communicating on a custom messaging channel,
handling protocol negotiation failures etc. To do SNICKER as a receiver,
a wallet needs the following elements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ECIES - this is really simple if you have the underlying secp256k1
    and HMAC dependencies; see
    &lt;a href="https://github.com/spesmilo/electrum/blob/master/lib/bitcoin.py#L774-L817"&gt;here&lt;/a&gt;
    and
    &lt;a href="https://github.com/AdamISZ/SNICKER-POC/blob/master/ecies/ecies.py#L10-L50"&gt;here&lt;/a&gt;;
    note that the root construction in ECIES is ECDH.&lt;/li&gt;
&lt;li&gt;The ability to calculate &lt;strong&gt;and store&lt;/strong&gt; the newly derived keys of the
    form &lt;code&gt;P' = P + kG&lt;/code&gt; where &lt;code&gt;k&lt;/code&gt; is what is passed to you, and &lt;code&gt;P&lt;/code&gt; is
    the pubkey of your existing key controlling the output to be spent.
    I would presume that you would have to treat &lt;code&gt;k+x&lt;/code&gt;, where &lt;code&gt;P=xG&lt;/code&gt;, as
    a newly imported private key. Note that we &lt;em&gt;cannot&lt;/em&gt; use a
    deterministic scheme for this from &lt;code&gt;P&lt;/code&gt;, since that would be
    calculatable by an external observer; it must be based on a secret
    generated by "Alisa".This could be a bit annoying for a wallet,
    although of course it's easy in a naive sense.&lt;/li&gt;
&lt;li&gt;Ability to parse files containing encrypted coinjoin proposals in
    the format outlined above - this is trivial.&lt;/li&gt;
&lt;li&gt;Ability to finish the signing of a partially signed transaction.
    Most wallets have this out of the box (Core does for example); there
    might be a problem for a wallet if it tacitly assumes complete
    ownership of all inputs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If a wallet only wanted to implement the receiver side (what we called
"Bob" above), that's it.&lt;/p&gt;
&lt;h4&gt;Compatibility/consensus between different wallets&lt;/h4&gt;
&lt;p&gt;The only "consensus" part of the protocol is the format of the
encrypted coinjoin proposals (and the ECIES algorithm used to encrypt
them). We could deal with different transaction types being proposed
(i.e. different templates, e.g. 3 outputs or 4, segwit or not), although
obviously it'll be saner if there are a certain set of templates that
everyone knows is acceptable to others.&lt;/p&gt;
&lt;h3&gt;Notes on scanning for candidates&lt;/h3&gt;
&lt;p&gt;There is no real need for each individual "Alisa" to scan, although
she might wish to if she has a Bitcoin node with indexing enabled. This
is a job that can be done by any public block explorer and anyone can
retrieve the data, albeit there are privacy concerns just from you
choosing to download this data. The data could be replicated on Tor
hidden services for example for better privacy. So for now I'm assuming
that scanning, itself, is not an issue.&lt;/p&gt;
&lt;p&gt;A much bigger issue might be finding &lt;strong&gt;plausible&lt;/strong&gt; candidates. Even in
this version 1 model of looking only for reused keys, which are
hopefully not a huge subset of the total utxo set, there are tons of
potential candidates and, to start with, none of them at all are
plausible. How to filter them?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Filter on amount - if Alisa has X coins to join, she'll want to
    work with outputs \&amp;lt; X.&lt;/li&gt;
&lt;li&gt;Filter on age - this is more debatable, but very old utxos are less
    likely to be candidates for usage.&lt;/li&gt;
&lt;li&gt;An "active" filter - this is more likely to be how things work.
    Are certain transactions intrinsically watermarked in a way that
    indicates that the "Bob" in question is actually interested in
    this function? One way this can happen is if we know that the
    transaction is from a certain type of wallet, which already has this
    feature enabled.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Bootstrapping&lt;/h4&gt;
&lt;p&gt;If a set of users were using a particular wallet or service (preferably
a &lt;em&gt;large&lt;/em&gt; set), it might be possible to identify their transactions
"Acme wallet transactions". Funnily enough, Joinmarket, because it
uses a set and unusual coinjoin pattern, satisfies this property in a
very obvious way; but there might be other cases too. See the notes in
"second version", below, on how Joinmarket might work specifically in
that case.&lt;/p&gt;
&lt;p&gt;Better of course, is if we achieved that goal with a more user-friendly
wallet with a much bigger user-base; I'd ask wallet developers to
consider how this might be achieved.&lt;/p&gt;
&lt;p&gt;Another aspect of bootstrapping is the Joinmarket concept - i.e. make a
financial incentive to help bootstrap. If creators/proposers are
sufficiently motivated they may offer a small financial incentive to
"sweeten the pot", as was suggested in the scenario at the start of
this post. This will help a lot if you want the user-set to grow
reasonably large.&lt;/p&gt;
&lt;h3&gt;Scalability&lt;/h3&gt;
&lt;p&gt;This is of course filed under "problems you really want to have", but
it's nevertheless a very real problem, arguably the biggest one here.&lt;/p&gt;
&lt;p&gt;Imagine 10,000 utxo candidates that are plausible and 1000 active
proposers. Imagine they could all make proposals for a large-ish subset
of the total candidates, we could easily imagine 1,000,000 candidates at
a particular time. Each encrypted record takes 500-800 bytes of space,
let's say. Just the data transfer starts to get huge - hundreds of
megabytes? Perhaps this is not as bad as it looks, &lt;em&gt;if&lt;/em&gt; the data is
being received in small amounts over long periods.&lt;/p&gt;
&lt;p&gt;And let's say we can find a way to get the data out to everybody - they
still have to try to decrypt &lt;strong&gt;every&lt;/strong&gt; proposal with &lt;strong&gt;every&lt;/strong&gt; pubkey
they have that is a valid candidate (in version 1, that's reused keys,
let's say, or some subset of them). The computational requirement of
that is huge, even if some cleverness could reduce it (decrypt only one
AES block; use high performance C code e.g. based on libsecp256k1).
Again, perhaps if this is happening slowly, streamed over time, or in
chunks at regular integrals, it's not as bad. Still.&lt;/p&gt;
&lt;p&gt;It's true that these problems don't arise at small scale, but then the
real value of this would be if it scaled up to large anonymity sets.&lt;/p&gt;
&lt;p&gt;Even if this is addressed, there is another problem arising out of the
anonymous submission - any repository of proposals could be filled with
junk, to waste everyone's time. Apart from a
&lt;a href="https://en.wikipedia.org/wiki/Hashcash"&gt;hashcash&lt;/a&gt;-like
solution (not too implausible but may impose too much cost on the
proposer), I'm not sure how one could address that while keeping
submission anonymity.&lt;/p&gt;
&lt;p&gt;At least we have the nice concept that this kind of protocol can improve
privacy on Bitcoin's blockchain without blowing up bandwidth and
computation for the Bitcoin network itself - it's "off-band", unlike
things like &lt;a href="https://www.elementsproject.org/elements/confidential-transactions/investigation.html"&gt;Confidential
Transactions&lt;/a&gt;
(although, of course, the effect of that is much more powerful). I think
ideas that take semantics and computation off chain are particularly
interesting.&lt;/p&gt;
&lt;h3&gt;Conflicting proposals&lt;/h3&gt;
&lt;p&gt;This is not really a problem: if Alisa proposes a coinjoin to Bob1 and
Bob2, and Bob1 accepts, then when Bob2 checks, he will find one of the
inputs for his proposed coinjoin is already spent, so it's not valid.
Especially in cases where there is a financial incentive, it just
incentives Bobs to be more proactive, or just be out of luck.&lt;/p&gt;
&lt;h3&gt;Transaction structure and 2 party joins&lt;/h3&gt;
&lt;p&gt;We have thus far talked only about 2 party coinjoins, which &lt;em&gt;ceteris
paribus&lt;/em&gt; are an inferior privacy model compared to any larger number
(consider that in a 2 party coinjoin, the &lt;em&gt;other&lt;/em&gt; party necessarily
knows which output is yours). The SNICKER model is not easily extendable
to N parties, although it's not impossible. But DarkWallet used 2 of 2
joins, and it's still in my opinion valuable. Costs are kept lower, and
over time these joins heavily damage blockchain analysis. A larger
number of joins, and larger anonymity set could greatly outweigh the
negatives&lt;em&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Structure: the model used in the aforementioned
&lt;a href="https://github.com/AdamISZ/SNICKER-POC"&gt;POC&lt;/a&gt;,
although stupid simple, is still viable: 2 inputs, one from each party
(easily extendable to 1+N), 3 outputs, with the receiver getting back
exactly one output of \~ the same size as the one he started with. The
proposer then has 1 output of exactly that size (so 2 equal outputs) and
one change. Just as in Joinmarket, the concept is that fungibility is
gained specifically in the equal outputs (the "coinjoin outputs"); the
change output is of course trivially linked back to its originating
input(s).&lt;/p&gt;
&lt;p&gt;But there's no need for us to be limited to just one transaction
structure; we could imagine many, perhaps some templates that various
wallets could choose to support; and it'll always be up to the receiver
to decide if he likes the structure or not. Even the stupid X-&gt;X, Y-&gt;Y
"coinjoin" I mused about in my Milan presentation
&lt;a href="https://youtu.be/IKSSWUBqMCM?t=47m21s"&gt;here&lt;/a&gt;(warning:youtube)
might be fun to do (for some reason!). What a particularly good or
"best" structure is, I'll leave open for others to discuss.&lt;/p&gt;
&lt;h3&gt;Second version - snicKER = Keys Encrypted to R&lt;/h3&gt;
&lt;p&gt;We've been discussing all kinds of weird and whacky "Non-Interactive
Coinjoin" models on IRC for years; and perhaps there will still be
other variants. But arubi was mentioning to me yesterday that he was
looking for a way to achieve this goal &lt;em&gt;without&lt;/em&gt; the nasty requirement
of reused keys, and between us we figured out that it is a fairly
trivial extension, &lt;em&gt;if&lt;/em&gt; you can find a way to get confidence that a
particular existing utxo is co-owned with an input (or any input).
That's because if you have an input, you have not only a pubkey, but
also a &lt;strong&gt;signature&lt;/strong&gt; (both will either be stored in the scriptSig, or in
the case of segwit, in the witness section of the transaction). An
&lt;a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm"&gt;ECDSA&lt;/a&gt;
signature is published on the blockchain as a pair: &lt;code&gt;(r, s)&lt;/code&gt;, where &lt;code&gt;r&lt;/code&gt;
is the x-coordinate of a point &lt;code&gt;R&lt;/code&gt; on the secp256k1 curve. Now, any
elliptic curve point can be treated as a pubkey, assuming someone knows
the private key for it; in the case of ECDSA, we call the private key
for &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, that is: &lt;code&gt;R = kG&lt;/code&gt;. &lt;code&gt;k&lt;/code&gt; is called the nonce (="number used
once"), and is usually today calculated using the algorithm
&lt;a href="https://tools.ietf.org/html/rfc6979"&gt;RFC6979&lt;/a&gt;,
which determines its value deterministically from the private key
you're signing with, and the message. But what matters here is, the
signer either already knows &lt;code&gt;k&lt;/code&gt;, or can calculate it trivially from the
signing key and the transaction. This provides us with exactly the same
scenario as in the first version; Bob knows the private key of &lt;code&gt;R&lt;/code&gt;, so
Alisa can send a proposal encrypted to that public key, and can derive a
new address for Bob's destination using the same formula:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;PB2 = R + k&amp;#39;G&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here I used &lt;code&gt;k'&lt;/code&gt; to disambiguate from the signature nonce &lt;code&gt;k&lt;/code&gt;, but it's
exactly the same as before. As before, Bob, in order to spend the output
from the coinjoin, will need to store the new private key &lt;code&gt;k+k'&lt;/code&gt;. For a
wallet it's a bit more work because you'll have to keep a record of
past transaction &lt;code&gt;k&lt;/code&gt; values, or perhaps keep the transactions and
retrieve &lt;code&gt;k&lt;/code&gt; as and when. Apart from that, the whole protocol is
identical.&lt;/p&gt;
&lt;h4&gt;Finding candidates in the second version&lt;/h4&gt;
&lt;p&gt;In version 2, we no longer need Bob to do something dubious (reusing
addresses). But now the proposer (Alisa) has a different and arguably
harder problem than before; she has to find transactions where she has
some reasonable presumption that a specific output and a specific input
are co-owned. You could argue that this is good, because now Alisa is
proposing coinjoins where linkages &lt;em&gt;are&lt;/em&gt; known, so she's improving
privacy exactly where it's needed :) (only half true, but amusing). In
a typical Bitcoin transaction there are two outputs - one to
destination, one change; if you can unambiguously identify the change,
even with say 90% likelihood not 100%, you could make proposals on this
basis. This vastly expands the set of &lt;em&gt;possible&lt;/em&gt; candidates, if not
necessarily plausible ones (see above on bootstrapping).&lt;/p&gt;
&lt;p&gt;Additionally paradoxical is the fact that Joinmarket transactions &lt;em&gt;do&lt;/em&gt;
have that property! The change outputs are unambiguously linkable to
their corresponding inputs through subset-sum analysis, see e.g.
&lt;a href="https://github.com/AdamISZ/JMPrivacyAnalysis/blob/master/tumbler_privacy.md#jmsudoku-coinjoin-sudoku-for-jmtxs"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thus, Adlai Chandrasekhar's
&lt;a href="http://adlai.uncommon-lisp.org:5000/"&gt;cjhunt&lt;/a&gt;
tool (appears down as of writing),
&lt;a href="https://github.com/adlai/cjhunt"&gt;code&lt;/a&gt;,
identifies all very-likely-to-be Joinmarket transactions through
blockchain scanning, and its output could be used to generate candidates
(the proposed joins could be with those change outputs, using the `R`
values from one of the identified-as-co-owned inputs). See also
&lt;a href="https://citp.github.io/BlockSci/chain/blockchain.html"&gt;BlockSci&lt;/a&gt;.
Then if Joinmarket had both proposer- and receiver- side code
integrated, it would create a scenario where these type of coinjoins
would most likely be quite plausible to achieve.&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;I think this idea might well be viable. It's simple enough that there
aren't likely crypto vulnerabilities. The short version of the pros and
cons:&lt;/p&gt;
&lt;h4&gt;Pros&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;No interactivity (the point), has many positive consequences, and
    high anonymity standard&lt;/li&gt;
&lt;li&gt;Relative ease of wallet integration (esp. compared to e.g.
    Joinmarket), consensus requirement between them is limited.&lt;/li&gt;
&lt;li&gt;Potentially huge anonymity set (different for version 1 vs version
    2, but both very large)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Cons&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;For now only 2 parties and probably stuck there; limited coinjoin
    model (although many transaction patterns possible).&lt;/li&gt;
&lt;li&gt;Finding plausible candidates is hard, needs a bootstrap&lt;/li&gt;
&lt;li&gt;Sybil attack on the encrypted messages; how to avoid the "junk
    mail" problem&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lastly, it should be fine with Schnorr (to investigate: aggregation in
this model), in version 1 and version 2 forms.&lt;/p&gt;
&lt;h3&gt;Footnotes&lt;/h3&gt;
&lt;p&gt;1. Sighashing - attempting a non-interactive coinjoin with some
interesting use of &lt;code&gt;SIGHASH_SINGLE&lt;/code&gt; and &lt;code&gt;SIGHASH_ANYONECANPAY&lt;/code&gt; seems at
least plausible (see
&lt;a href="https://en.bitcoin.it/wiki/OP_CHECKSIG#Procedure_for_Hashtype_SIGHASH_SINGLE"&gt;here&lt;/a&gt;),
although it's not exactly heartening that no one ever uses
&lt;code&gt;SIGHASH_SINGLE&lt;/code&gt; (and its rules are arcane and restrictive), not to even
speak of watermarking. Hopefully the idea expressed here is better.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="coinjoin"></category><category term="bitcoin"></category></entry><entry><title>P(o)ODLE</title><link href="https://joinmarket.me/blog/blog/poodle/" rel="alternate"></link><published>2016-06-15T00:00:00+02:00</published><updated>2016-06-15T00:00:00+02:00</updated><author><name>Adam Gibson</name></author><id>tag:joinmarket.me,2016-06-15:/blog/blog/poodle/</id><summary type="html">&lt;p&gt;DLEQ proofs as tokens for anti-snooping in coinjoin&lt;/p&gt;</summary><content type="html">&lt;h3&gt;P(o)ODLE&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Here is a purse of monies ... which I am not going to give to you.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;- &lt;a href="https://en.wikipedia.org/wiki/Bells_(Blackadder)"&gt;Edmund
Blackadder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="/web/20200712194227im_/https://joinmarket.me/static/media/uploads/.thumbnails/poodle.jpeg/poodle-225x308.jpeg" width="225" height="308" /&gt;&lt;/p&gt;
&lt;h3&gt;P(o)ODLE, not POODLE&lt;/h3&gt;
&lt;p&gt;This post, fortunately, has nothing to do with faintly ridiculous &lt;a href="https://en.wikipedia.org/wiki/POODLE"&gt;SSL 3
downgrade
attacks&lt;/a&gt;.
Irritatingly, our usage here has no made-up need for the parenthetical
(o), but on the other hand "podle" is not actually a word.&lt;/p&gt;
&lt;h3&gt;The problem&lt;/h3&gt;
&lt;p&gt;You're engaging in a protocol (like Joinmarket) where you're using
bitcoin utxos regularly. We want to enforce some scarcity; you can't use
the same utxo more than once, let's say. Utxos can be created all the
time, but at some cost of time and money; so it can be seen as a kind of
rate limiting.&lt;/p&gt;
&lt;p&gt;So: you have a bitcoin utxo. You'd like someone else to know that you
have it,&lt;strong&gt;and that you haven't used it before, with them or anyone
else&lt;/strong&gt;, &lt;strong&gt;in this protocol,&lt;/strong&gt; but you don't want to show it to them. For
that second property (hiding), you want to make a &lt;em&gt;commitment&lt;/em&gt; to the
utxo. Later on in the protocol you will open the commitment and reveal
the utxo.&lt;/p&gt;
&lt;p&gt;Now, a &lt;a href="https://en.wikipedia.org/wiki/Commitment_scheme"&gt;cryptographic
commitment&lt;/a&gt;
is a standard kind of protocol, usually it works something like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;Alice-&amp;gt;Bob: commit: h := hash(secret, nonce)&lt;/span&gt;
&lt;span class="err"&gt;(do stuff)&lt;/span&gt;
&lt;span class="err"&gt;Alice-&amp;gt;Bob: open: reveal secret, nonce&lt;/span&gt;
&lt;span class="c"&gt;Bob: verify: h =?= hash(secret, nonce)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Hashing a secret is &lt;em&gt;not&lt;/em&gt; enough to keep it secret, at least in general:
because the verifier might be able to guess, especially if the data is
from a small-ish set (utxos in bitcoin being certainly a small enough
set; and that list is public). So usually, this protocol, with a
large-enough random nonce, would be enough for the purposes of proving
you own a bitcoin utxo without revealing it.&lt;/p&gt;
&lt;p&gt;But in our case it doesn't suffice - because of the bolded sentence in
the problem description. You could pretend to commit to &lt;em&gt;different&lt;/em&gt;
utxos at different times, simply by using different nonces. If you tried
to do that&lt;em&gt;just with me&lt;/em&gt;, well, no big deal - I'll just block your
second use. But you&lt;em&gt;could&lt;/em&gt;use the same utxos with different
counterparties, and they would be none the wiser, unless they all shared
all private information with each other. Which we certainly don't want.&lt;/p&gt;
&lt;p&gt;Contrariwise, if you ditch the nonce and just use Hash(utxo) every time
to every counterparty, you have the failure-to-hide-the-secret problem
mentioned above.&lt;/p&gt;
&lt;p&gt;In case you didn't get that: Alice wants to prove to Bob and Carol and
... that she owns utxo \(U\), and she never used it before. Bob and
Carol etc. are keeping a public list of all previously used commitments
(which shouldn't give away what the utxo is, for privacy). If she just
makes a commitment: Hash(\(U +\) nonce) and sends it to Bob and Carol,
they will check and see it isn't on the public list of commitments and
if not, OK, she can open the commitment later and prove honest action.
But her conversations with Bob and Carol are separate, on private
messaging channels. How can Bob know she didn't use &lt;em&gt;the same utxo as
previously used with Carol, but with a different nonce&lt;/em&gt;?&lt;/p&gt;
&lt;h3&gt;The solution&lt;/h3&gt;
&lt;p&gt;This is a bit of a headscratcher; after several IRC discussions, Greg
Maxwell suggested the idea of &lt;strong&gt;proof of discrete logarithm
equivalence&lt;/strong&gt; (hence the title), and pointed me at &lt;a href="http://crypto.stackexchange.com/questions/15758/how-can-we-prove-that-two-discrete-logarithms-are-equal"&gt;this
crypo.stackexchange
thread&lt;/a&gt;.
It's a cool idea (although note that that description is based on DL
rather than ECDL seen here): "shift" the EC point to a new
base/generator point, so that nobody else can read (crudely put), then
append a Schnorr signature acting as proof that the two points have the
same discrete logarithm (= private key) with respect to the two base
points. In detail, consider a Bitcoin private, public keypair \((x,
P)\) for the usual base point/generator \(G\), and consider a
&lt;a href="https://en.wikipedia.org/wiki/Nothing_up_my_sleeve_number"&gt;NUMS&lt;/a&gt;
alternative generator \(J\) ( a little more on this later).&lt;/p&gt;
&lt;p&gt;$$P = xG$$&lt;/p&gt;
&lt;p&gt;$$P_2 = xJ$$&lt;/p&gt;
&lt;p&gt;Next, Alice will provide her commitment as \(H(P_2)\) in the
handshake initiation stage of the protocol. Then, when it comes time for
Alice to request private information from Bob, on their private message
channel, she will have to open her commitment with this data:&lt;/p&gt;
&lt;p&gt;$$P, U, P_2, s, e$$&lt;/p&gt;
&lt;p&gt;Here \(s,e\) are a Schnorr signature proving equivalence of the
private key (we called it \(x\) above) with respect to \(G,J\), but
of course without revealing that private key. It is constructed, after
choosing a random nonce \(k\), like this:&lt;/p&gt;
&lt;p&gt;$$K_G = kG$$&lt;/p&gt;
&lt;p&gt;$$K_J = kJ$$&lt;/p&gt;
&lt;p&gt;$$e = H(K_G || K_J || P || P_2)$$&lt;/p&gt;
&lt;p&gt;$$s = k + xe$$&lt;/p&gt;
&lt;p&gt;Then Bob, receiving this authorisation information, proceeds to verify
the commitment before exchanging private information:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Does \(H(P_2)\) equal the previously provided commitment? If yes:&lt;/li&gt;
&lt;li&gt;Check that the commitment is not repeated on the public list (or
    whatever the policy is)&lt;/li&gt;
&lt;li&gt;Verify via the blockchain that \(P\) matches the utxo \(U\)&lt;/li&gt;
&lt;li&gt;\(K_G = sG - eP\)&lt;/li&gt;
&lt;li&gt;\(K_J = sJ - eP_2\)&lt;/li&gt;
&lt;li&gt;Schnorr sig verify operation: Does \(H(K_G || K_J || P ||
    P_2) = e\) ?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Bob now knows that the utxo \(U\) has not been repeated (the simplest
policy) but Alice has not been exposed to a potential public leakage of
information about the utxo. (It should be noted of course! Bob knows the
utxo from now on, but that's for another discussion about Coinjoin
generally...)&lt;/p&gt;
&lt;h3&gt;Why an alternate generator point \(J\)?&lt;/h3&gt;
&lt;p&gt;Publishing \(H(P_2)\) gives no information about \(P\), the actual
Bitcoin pubkey that Alice wants to use; in that sense it's the same as
using a nonce in the commitment. But it also gives her no degree of
freedom, as a nonce does, to create different public values for the same
hidden pubkey. No one not possessing \(x\) can deduce \(P\) from
\(P_2\) (or vice versa, for that matter) - &lt;strong&gt;unless&lt;/strong&gt; they have the
private key/discrete log of \(J\) with respect to \(G\). If anyone
had this number \(x^*\) such that \(J = x^{*}G\), then it would be
easy to make the shift from one to the other:&lt;/p&gt;
&lt;p&gt;$$P_2 = xJ = x(x^{*}G) = x^{*}(xG) = x^{*}P$$&lt;/p&gt;
&lt;p&gt;and apply a modular inverse if necessary.&lt;/p&gt;
&lt;p&gt;This is why the concept of NUMS is critical. The construction of a NUMS
alternate generator is discussed in &lt;a href="https://elementsproject.org/elements/confidential-transactions/"&gt;the same CT doc as
above&lt;/a&gt;,
and also in &lt;a href="https://github.com/AdamISZ/ConfidentialTransactionsDoc/blob/master/essayonCT.pdf"&gt;my CT
overview&lt;/a&gt;,
at the end of section 2.2. Note I use \(J\) here in place of \(H\)
to avoid confusion with hash functions.&lt;/p&gt;
&lt;h3&gt;Code and thoughts on implementation&lt;/h3&gt;
&lt;p&gt;I did an abbreviated write up of the concept of this post in &lt;a href="https://gist.github.com/AdamISZ/9cbba5e9408d23813ca8#defence-2-committing-to-a-utxo-in-publicplaintext-at-the-start-of-the-handshake"&gt;this
gist&lt;/a&gt;,
as one of three possible ways of attacking the problem in Joinmarket:
&lt;a href="https://github.com/JoinMarket-Org/joinmarket/issues/156"&gt;how can we prevent people initiating transactions over and over again
to collect information on
utxos&lt;/a&gt;?
This algorithm is not intended as a &lt;em&gt;complete&lt;/em&gt; solution to that issue,
but it's very interesting in its own right and may have a variety of
applications, perhaps.&lt;/p&gt;
&lt;p&gt;The algorithm was fairly simple to code, at least in a naive way, and I
did it some time ago using Bitcoin's
&lt;a href="https://github.com/bitcoin-core/secp256k1"&gt;libsecp256k1&lt;/a&gt;
with the &lt;a href="https://github.com/ludbb/secp256k1-py"&gt;Python binding by
ludbb&lt;/a&gt;.
An initial version of my Python "podle" module is
&lt;a href="https://github.com/JoinMarket-Org/joinmarket/blob/90ec05329e06beed0fbc09528ef6fb3d2c5d03ba/lib/bitcoin/podle.py"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are lots of tricky things to think about in implementing this; I
think the most obvious issue is how would publishing/maintaining a
public list work? If we just want each utxo to be allowed only one use,
any kind of broadcast mechanism would be fine; other participants can
know as soon as any \(H(P_2)\) is used, or at least to a reasonable
approximation. Even in a multi-party protocol like Joinmarket, the utxo
would be broadcast as "used" only after its first usage by each party,
so it would from then on be on what is effectively a blacklist. But if
the policy were more like "only allow re-use 3 times" this doesn't seem
to work without some kind of unrealistic honesty assumption.&lt;/p&gt;</content><category term="waxwings Blog"></category><category term="bitcoin"></category><category term="cryptography"></category><category term="joinmarket"></category></entry></feed>