<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>From MAC to Wabisabi â€” Joinmarket.me archive</title>
	<meta name="description" content="Title: From MAC to Wabisabi; Date: 2020-11-05; Author: Adam Gibson">
	<meta name="author" content="Adam Gibson">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="https://joinmarket.me/theme/html5.js"></script>
		<![endif]-->
	<link href="https://joinmarket.me/theme/css/ipython.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">
	<link href="//maxcdn.bootstrapcdn.com/bootswatch/3.2.0/simplex/bootstrap.min.css" rel="stylesheet">
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<link href="https://joinmarket.me/theme/css/local.css" rel="stylesheet">
	<link href="https://joinmarket.me/theme/css/pygments.css" rel="stylesheet">
</head>
<body>
<div class="container">
	<div class="page-header">
		<h1><a href="https://joinmarket.me/">Joinmarket.me archive</a>
			<br>	</div>
	<div class="row">
		<div class="col-md-8 col-md-offset-2">
<div class="article" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="text-center article-header">
		<h1 itemprop="name headline" class="article-title">From MAC to Wabisabi</h1>
		<span itemprop="author" itemscope itemtype="http://schema.org/Person">
			<h4 itemprop="name">Adam Gibson</h4>
		</span>
		<time datetime="2020-11-05T00:00:00+01:00" itemprop="datePublished">Thu 05 November 2020</time>
	</div>
	<div>
		Category:
		<span itemprop="articleSection">
			<a href="https://joinmarket.me/category/waxwings-blog.html" rel="category">waxwings Blog</a>
		</span>
	</div>
 
	<div>
		Tags:
		<span itemprop="keywords">
			<a href="https://joinmarket.me/tag/cryptography.html" rel="tag">cryptography</a>
		</span>
		<span itemprop="keywords">
			<a href="https://joinmarket.me/tag/bitcoin.html" rel="tag">bitcoin</a>
		</span>
		<span itemprop="keywords">
			<a href="https://joinmarket.me/tag/coinjoin.html" rel="tag">coinjoin</a>
		</span>
	</div>
	<div itemprop="articleBody" class="article-body"><h2>From MAC to Wabisabi</h2>
<!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#preamble">Preamble - big-and-randomized</a></li>
<li><a href="#wabisabi-from-the-ground-up">Wabisabi, from the ground up.</a><ul>
<li><a href="#do-not-cover">What the Wabisabi paper, and this article, do not cover</a></li>
</ul>
</li>
<li><a href="#signatures-keyed-macs-and-credentials">Signatures, keyed MACs and credentials</a><ul>
<li><a href="#creating-a-mac">Creating a MAC</a></li>
<li><a href="#algebraic-macs">Algebraic MACs</a></li>
<li><a href="#security-notions">Security notions needed for algebraic MACs used for anonymous credentials</a><ul>
<li><a href="#mac-1">Algebraic MAC attempt 1</a></li>
<li><a href="#mac-2">Algebraic MAC attempt 2</a></li>
<li><a href="#mac-3">Algebraic MAC attempt 3</a></li>
<li><a href="#mac-4">Algebraic MAC attempt 4</a></li>
</ul>
</li>
<li><a href="#mac-ggm">MAC-GGM - a vector of messages; different security arguments</a></li>
</ul>
</li>
<li><a href="#key-verified-anonymous-credentials-kvac">Key-Verified Anonymous Credentials (KVAC)</a><ul>
<li><a href="#how-does-issuance-work">How does issuance work?</a><ul>
<li><a href="#without-any-blinding">Without any blinding:</a></li>
<li><a href="#side-note-what-are-these-mysterious-zero-knowledge-proofs">Side note: what are these mysterious "zero knowledge proofs"?</a></li>
<li><a href="#with-blinding-of-attributes">With blinding of attributes:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#chase-perrin-zaverucha-2019">Chase-Perrin-Zaverucha 2019</a></li>
<li><a href="#wabisabi-credentials-on-amounts-with-splitting">Wabisabi: credentials on amounts with splitting</a><ul>
<li><a href="#range-proofs">Range proofs</a></li>
</ul>
</li>
<li><a href="#final-thoughts-on-the-security-and-functionality-proposed-in-wabisabi">Final thoughts on the security and functionality proposed in Wabisabi</a></li>
</ul>
<!-- vim-markdown-toc -->

<p><em>Thanks to nothingmuch for answering several questions about the mechanics of Wabisabi.</em>
<a href="preamble"></a></p>
<h3>Preamble - big-and-randomized</h3>
<p>First, assume we think it's valuable to have big coinjoins with random amounts for all the inputs and outputs, and probably for this one specific reason: we want to make payments <em>from</em> coinjoins and, possibly, to make payments <em>within</em> coinjoins (the latter is literally what is meant by payjoin, so that is part of this discussion, note however we'd be talking about payjoin batched together with other sub-transactions, so a lot of earlier analysis of payjoin doesn't apply).</p>
<p>Second let's <em>partially</em> address why this is, at least superficially, a bad idea, even a terrible one: previous discussion of the subset sum problem pointed out that <em>some of the time</em> (being deliberately vague about how much of the time!) a coinjoin with non-equal amounts can be easily analyzed to find the sub-transactions which are really happening, removing any privacy boost. So that's not good.</p>
<p>Then, let's mention, without writing an essay about it (though it's a fascinating topic), that there are surprising outcomes of scaling the number of inputs and outputs (or just "coins") in such a model. Due the combinatorial nature of the subset sum problem (or more generally the "knapsack problem"), even having numbers like 50-100 on the input and output side (remember: these may be batched payments! not like separately created coinjoins, extra to payment transactions) can lead to a ridiculous combinatorial blowup making calculation of subsets near impossible. To illustrate: he set of subsets of a set is called the "power-set" and its size is \(2^N\) where \(N\) is the number of elements of the set; but the number of <em>partitions</em> of a set is found using Bell's number \(B_n\), which scales (or doesn't!) even faster than exponential (i.e. faster than \(a^N\) where a is constant, here \(a\) is a function of \(N\), although it's pretty complex. \(B_2 = 2, B_10 \simeq 115000\), while \(B_100\) has 116 <em>digits</em>, in decimal. So it's easy to see than even at 50 inputs and 50 outputs, the enumeration process <em>by brute force</em> is not possible.</p>
<p>This point is expanded on in some detail in the <a href="https://github.com/cashshuffle/spec/blob/master/CASHFUSION.md">cashfusion writeup</a>.</p>
<p>However the point is definitely controversial, basically because brute force is not the only way to approach an attempt to deanonymize a coinjoin. A simple thing like a rounded value (0.25000000 BTC) substantially (sort of exponentially) reduces the search space.</p>
<p>Those who completely dismiss this approach based on the idea "well sure, it's worst case impossible to analyze, but not average, typical case!" should notice a really key subtlety though: the claim is not <em>only</em> that such constructions are computationally impractical to analyze - it's also that they have <strong>multiple, and in fact a huge number of mathematically valid solutions</strong>, at least when we scale up to very large numbers of utxos. Moreover <a href="https://www.comsys.rwth-aachen.de/fileadmin/papers/2017/2017-maurer-trustcom-coinjoin.pdf">this</a> paper from 2017 tries to construct a framework for deliberately creating such obfuscation (with the same goal - unequal sized coinjoins, allowing payment).</p>
<p>This deserves more argument and discussion, see e.g. <a href="https://www.mail-archive.com/bitcoin-dev@lists.linuxfoundation.org/msg08575.html">this</a> discussion on the bitcoin mailing list from February this year. But we are going to move on to other elements of this story.
<a href="wabisabi-from-the-ground-up"></a></p>
<h3>Wabisabi, from the ground up.</h3>
<p>The paper is <a href="https://github.com/zkSNACKs/WabiSabi/releases/download/build-70d01424bbce06389d2f0536ba155776eb1d8344/WabiSabi.pdf">here</a> for those who don't need context. I suspect that group is quite small though!</p>
<p>So let's say we buy into the basic idea: a large coinjoin, we'll say for simplicity, 50 inputs and 50 outputs, where the users are not constrained to use specific amounts for any of their inputs, nor crucially, their outputs. Some of them will just be mixing and some will be paying someone for a specific good or service, with the output. Probably rarer, but particularly cool, will be if Alice is paying Bob but Bob also participates in the coinjoin, i.e. he is also contributing input utxos to the coinjoin, but gets more out and Alice gets less, effecting a payjoin.</p>
<p>Scenario #1 : Server as coordinator, meaning a server-defined schedule, and no privacy for users w.r.t. server</p>
<p>If we don't care if the server knows everything, each user can just securely connect and pass (set of inputs, set of outputs); they can be random amounts as per the preamble, and the server will accept if the inputs are verifiable on the blockchain, and if the total payment balances. This would be tricky for the payjoin style payments as that means interaction between the users, but in principle that could work too.</p>
<p>Note how this is hardly a new idea, even the earliest implementation SharedCoin did something similar to this (it's a long story! but let's say).</p>
<p>However this SPOF scenario seems unacceptable to anybody. The server could be keeping a record of <em>every</em> linkage, ever, of the coinjoins created in this system. Ultimately this level of centralization breaks, anyway, via external pressure or otherwise.</p>
<p>Scenario #2: Taker as coordinator, meaning taker chooses time of event, and privacy only for takers, not for makers</p>
<p>The description of what is done is exactly as above, except substitute Taker for server. The outcome is practically different: at least one user (who likely pays for it) gets a privacy guarantee. How is this different from Joinmarket today? First, it hasn't been considered seriously to use randomized amounts; second, 50 party joins have not been at all practical (until recently it was not very practical, due to low participation rate (unless you chose a narrow range of amount), however that has increased; but, the IRC message channel used is not really able to handle the traffic needed for 50 party joins, see <a href="https://joinmarket.me/blog/blog/oct-2020-update/">this</a> earlier blog post for some thoughts on that). But if you take away those issues, this scenario is <em>possible</em>.</p>
<p>But notice something - exactly what makes this new "random payments, large numbers of counterparties" paradigm attractive <strong>is the possibility of multiple payments going on at once</strong> - and that's counter to Joinmarket's original concept of "there is a guy paying for the privilege of controlling everything". More on this later.</p>
<p>Scenario #3: Current Wasabi, Chaumian coinjoin</p>
<p>I have only passing familiarity with the technical underpinnings of Wasabi as is, but essentially it is based on blinded signatures of a coinjoin output (see <a href="https://github.com/nopara73/ZeroLink/#a-simplified-protocol">Chaumian coinjoin</a> for a pretty intuitive diagrammatic explanation). This fairly simple cryptographic primitive (the blinded signature) is in itself enough, because Wasabi currently is only blinding the specific set of outputs (utxos-to-be) which all have equal size and are indistinguishable. As long as the Wasabi coordinating server is prevented from knowing those linkages, due to the blinding, then the later full construction of the transaction will not expose ownership of the equal-sized outputs ("coinjoin outputs").
On the other hand, let's not have <em>too</em> simple of a mental model of Wasabi - it's crucial in this that the users make separate network connections (effectively, have separate pseudonyms) for when they present their cleartext outputs, and when they earlier presented their inputs (and change)); otherwise the cryptography would be sidestepped and the server would know all the mappings.</p>
<p>Can you get the same protection, i.e. keeping the linkages private from the server, in a big-and-randomized model, using current Wasabi blind signatures?</p>
<p>It's easy to see the problem: when the user comes along with a new identity and says "here are my outputs: 0.29511342 BTC and 0.01112222 BTC' the server has no way of knowing that these amounts correspond to anything in the inputs. If the blind signature is being used as a token to say "I am entitled to add outputs to this coinjoin", fine, but in this scenario: a token of <em>what</em>, exactly?</p>
<p>The difference is clear: in equal-output coinjoin there is only one kind of thing you could be entitled to: a single output of the prescribed amount ("denomination"); typically it's things like 0.1BTC.</p>
<p>Here, if we were to preserve the tokenization approach, we'd have to have a more sophisticated object ... something similar to a supermarket gift card : it gives you the right to have a certain amount of stuff, restricted perhaps in time and space, but quantified. It's something that's issued to you, which you can use under the given conditions, but which does not have your name attached. I realise the analogy is a bit of a stretch, but you can see that gift cards have divisibility, which is crucial here in our big-and-randomized model. They usually also have anonymity which is clearly necessary.</p>
<p>What we need here is a homomorphic anonymous credential with attributes:</p>
<ul>
<li>
<p>homomorphic - here it means we could linearly split and combine credentials. Take a credential for 10 and turn it into two credentials for 3 and 7, for example.</p>
</li>
<li>
<p>anonymous - if the credential presented could be linked to the one issued earlier, the coordinating entity can see all the linkages in the coinjoin</p>
</li>
<li>
<p>credential - this term is used in cryptography for any of a number of schemes that give rights to holders. The rights are usually <em>with respect to</em> some centralized entity, usually holding a private key that allows them to create such credentials (modulo a nuance about who is verifying them; we'll get in to that).</p>
</li>
<li>
<p>attributes - a credential could in its simplest form be simply binary: you are allowed to do X if you have the credential, and not otherwise. But sometimes attaching metadata inside the credential (think of e.g. a signature from a server that proved you should have access, but also that you are a level 3 user not a level 1 user, by including the level in the message that was signed).
<a href="do-not-cover"></a></p>
</li>
</ul>
<h4>What the Wabisabi paper, and this article, do not cover</h4>
<p>What follows is a detailed review of the crypto constructions leading to the possibility of building a coinjoin system, with such a credential system. A full protocol however must cover other things:</p>
<ul>
<li>The rules for transaction construction</li>
<li>Valid choices of amounts for inputs and outputs</li>
</ul>
<p>This is not covered here, other than some general thoughts as outlined above.
<a href="signatures-keyed-macs-and-credentials"></a></p>
<h3>Signatures, keyed MACs and credentials</h3>
<p>Digital signatures are probably very familiar to any reader of this blog, and there is a detailed discussion of some fundamentals in <a href="https://joinmarket.me/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/">this</a> post. MACs, or Message Authentication Codes can be thought of as the symmetric crypto equivalent. In symmetric crypto, there is only a secret key, no public key, and that means there is no such thing as "public verification". The owner or owners of such a secret key can create a (probably unique; this is a nuance of the theory) "tag" on a message, which only a holder of the same key can verify.</p>
<p>On its face, such tagging might seem pointless without public verifiability, but the classic use case is for point to point communications over the public internet, in which both endpoints of the communication hold the secret key; by tagging messages in this way, integrity is assured, and the message is authenticated as coming from the intended source. Such secret keys can be pre-shared over a public communication channel using techniques like <a href="https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman">ECDH</a>.
<a href="creating-a-mac"></a></p>
<h4>Creating a MAC</h4>
<p>A simple and currently very common way of making a MAC is to use a cryptographic hash function as a PRF: just hash the key <em>and</em> message together (<a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a> is a bit more complicated than this, but that's the basic idea): H(message || key).</p>
<p>At first sight it may seem weird that I'm talking about this construct - how is this related to credentials?</p>
<p>The most natural way to create a credential of the type described above, is to use a signature, which simply signs the rights of the holder. That's effectively what Wasabi's original design ("Chaumian coinjoin") does, but with the crucial extra feature that the signature is <em>blind</em>, so that the credential's redemption is not linked to its creation. Early ecash designs (indeed, from David Chaum as well as others) were heavily sophisticated variants of that basic idea. Just as original Wasabi uses fixed denominations, so did those ecash designs.</p>
<p>This is where we get some interesting twists, which bring in MAC as an alternative to signatures, here.</p>
<p>First, traditionally, MACs were preferable to signatures for performance reasons: they use hash functions, not expensive crypto math operations like RSA or - less expensive but still a lot more so than hashes - elliptic curve calculations. This is less a consideration today, but still relevant. Second, the more restrictive model of the MAC w.r.t. verification does create a different effect: such MACs are repudiable, whereas digital signatures are not repudiable (if you think about it, this is the same property as transferrability, which is of course a key property of signatures).</p>
<p>This plain vanilla style of MAC though (hash based), trades off functionality in favour of performance - hashes like SHA256 are intrinsically black boxy and not "algebraic". They are functions which do not allow composition; as I've had occasion to remark many times before, there is no such formula as \(H(a+b) = H(a) + H(b)\) for these traditional hash functions.
<a href="algebraic-macs"></a></p>
<h4>Algebraic MACs</h4>
<p>The <em>other</em> approach to building a MAC might be to use discrete log or elliptic curve hardness assumptions, for example in the crudest case take \(\textrm{MAC}_{k}(m) = m^{k} \textrm{mod} p\) for the discrete log case. Comparing the two approaches, Dodis et al in <a href="https://eprint.iacr.org/2012/059">Mesage Authentication, Revisited</a> have this to say:</p>
<blockquote>
<p>The former have the speed advantage, but cannot be reduced to simple number-theoretic hardness assumptions (such as the DDH assumption for NR-PRF), and are not friendly to efficient zero-knowledge proofs about authenticated messages and/or their tags, which are needed in some important applications, such as compact e-cash [12]. On the other hand, the latter are comparably inefficient due to their reliance on number theory.</p>
</blockquote>
<p>Here NR-PRF refers to the <a href="https://en.wikipedia.org/wiki/Naor%E2%80%93Reingold_pseudorandom_function">Naor-Reingold</a>. construction for a pseudorandom function.</p>
<p>The point about zero knowledge proofs is the trump card though: in building something like a <em>anonymous credential with attributes</em>, you are perforce required to be able to make attestations, using such proofs, in zero knowledge.
<a href="security-notions"></a></p>
<h4>Security notions needed for algebraic MACs used for anonymous credentials</h4>
<p>MACs generally want to have something called UF-CMA (unforgeability under chosen message attack) ; something we already discussed for signatures <a href="https://joinmarket.me/blog/blog/liars-cheats-scammers-and-the-schnorr-signature/">here</a>. There are several nuances that are MAC-specific but we won't delve into too much detail (I recommend Section 6.1, 6.2 of <a href="https://toc.cryptobook.us/">Boneh and Shoup</a> for an excellent rigorous description); the bottom line is that MACs must not be forgeable by a non-key holders, just like signatures.</p>
<p>For our use case (and some others), such a MAC will also need to have a kind of "hiding" property : <em>indistinguishability</em> (under chosen message attack, or IND-CMA) - the tags output should not allow an attacker to guess anything about the message being tagged.</p>
<p>So concretely how can we use simple discrete log to build a MAC? Let's use an elliptic curve group of the type we're familiar with, generator \(G\), order \(p\). We'll try the simplest versions first and see what we need to do to make it secure:
<a href="mac-1"></a></p>
<h5>Algebraic MAC attempt 1</h5>
<ul>
<li>Keygen: choose a scalar \(k\) at random</li>
<li>Tag: given a message \(m\), set the tag to \(T = mkG\).</li>
<li>Verify: not a relevant definition for such a deterministic MAC; we didn't add randomness so it's the same calculation as "Tag".</li>
</ul>
<p>Note how this "determinism" is the same for familiar existing MAC functions like <a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a>. Since it's the same information needed (the secret key \(k\)) and the same calculation, the distinction is not interesting. Shortly we'll be looking at probabilistic MACs.</p>
<p>Attempt 1 clearly fails, and here's one reason why: if the attacker gets to query the algorithm and ask for any MAC it likes it can choose to ask for the MAC of the message 1. That MAC is \(kG=K\). It can then take that curve point and create forgeries on any message m' it likes: \(m'K\). Secondly this kind of deterministic MAC clearly can't have the kind of hiding property we want, since it's like a commitment without any blinding factor: if you guess the value of \(m\) correctly, you can verify your guess.
Thirdly, extend the above case of message '1' and we can see that it's non-resistant to forgery more generally: whenever you know the message that was tagged, you can take the output tag given by the signer,  \(T = mkG\) and multiplicatively tweak the message to \(m_2 = a \times m\) by just outputting \(aT\) as the new tag. So this is very insecure.
<a href="mac-2"></a></p>
<h5>Algebraic MAC attempt 2</h5>
<ul>
<li>Keygen: choose a scalar \(k\) at random</li>
<li>Tag: choose a curve point \(U\) at random, and message \(m\), output \((U, T = mkU)\)</li>
<li>Verify: Given \((U, T)\) and message \(m\), check if \(T == mkU\)</li>
</ul>
<p>This addresses the second part of our complaint with Attempt 1, by making the MAC "probabilistic". Each new MAC is generated with a fresh random curve point (or equivalently a scalar \(u\)).</p>
<p>Unfortunately, Attempt 2 fails just as Attempt 1 did, when it comes to preventing forgeries (bearing in mind the previous sentence), because we can still tweak created tags in the same way. Perhaps slightly less obvious is that we can not just tweak \(T\) but also \(U\). (But it's important to bear in mind that our security game is also concerned with whether an attacker can do something clever with re-used values of that U.)
<a href="mac-3"></a></p>
<h5>Algebraic MAC attempt 3</h5>
<ul>
<li>Keygen: choose a scalar \(k\) at random</li>
<li>Tag: choose a curve point \(U\) at random, and message \(m\), output \((U, T = (m+k)U)\)</li>
<li>Verify: Given \((U, T)\) and message \(m\), check if \(T == (m+k)U\)</li>
</ul>
<p>This prevents the multiplicative tweaking which killed our first two attempts; even supposing the attacker has a given \(T\) on a given, known message \(m\), multiplying \(T\) by any constant \(a\), will create \(T^{*} = aT = (am + ak) U\) which is not a tag on any message he can state (it is a tag on \(am + (a-1)k\) but he doesn't know \(k\), so even if he knows, or guesses, \(m\), he is stuck).
However this construction still allows trivial forgery, (and fundamentally for the same reason: the additive homomorphism of the group). Here, because the key is "additively separate" from the message, you can just insert new messages using addition. If you happen to know \(m\) and you want a tag on \(m_2\) instead, just make \(T_2 = T + m_2 U - m U\) (see previous note : reusing \(U\) is in-scope for our attacker).</p>
<p>So if we review these first 3 attempts, it's fairly clear what's going on; it's a paradigm we've seen before in the Schnorr protocol. If you only <em>add</em> a random secret, you allow additive forgery, while if you only <em>multiply</em> a random secret, you allow multiplicative forgery, but if we add both ...
<a href="mac-4"></a></p>
<h5>Algebraic MAC attempt 4</h5>
<ul>
<li>Keygen: choose two scalars \(k_1, k_2\) at random</li>
<li>Tag: choose a curve point \(U\) at random, and message \(m\), output \((U, T = (mk_1+k_2)U)\)</li>
<li>Verify: Given \((U, T)\) and message \(m\), check if \(T == (mk_1+k_2)U\)</li>
</ul>
<p>To expand on the Schnorr analogy, it's as if one of the keys were the randomizing nonce, and the other were the private key (the analogy is not exact, to be clear). Now neither the additive nor the multiplicative tweak gives the attacker a way to forge new tags on messages that the genuine key holder never created.</p>
<p>The construction in attempt 4 is one of several elucidated by Dodis et al in their 2012 paper <a href="https://eprint.iacr.org/2012/059">"Symmetric Key Authorization, revisited"</a>. They identify exponentiation in a group of prime order as an example of a "weak PRF", and moreover, specifically a <em>key-homomorphic weak PRF</em>, and build the above construction in abstract from such a function. Then they prove by quite sophisticated arguments (see 4.3 of the full paper), that this construction has "suf-CMA" (or "suf-CMVA" with a transformation) where the "s" refers to <em>selective</em> security. This is a weaker notion of security; the idea is that we only defend against the attacker who has to choose the message he will forge on, before he gets to query the signer/tagger to see a bunch of other messages. Their proof strategy is basically to show that with clever use of linear transformations you can reduce the security argument to that of the underlying weak PRF; its randomness gives you both the unforgeability and the hiding (indistinguishability) properties that we want.
<a href="mac-ggm"></a></p>
<h4>MAC-GGM - a vector of messages; different security arguments</h4>
<p>In 2013 Zaverucha, Chase and Meiklejohn described, in <a href="https://eprint.iacr.org/2013/516">this paper</a> (which we will sometimes abbreviate to CMZ13), a small but meaningful finesse on the above construction from 2012, which they call "MAC-GGM" (they also describe MAC-DDH in the same paper, which we won't cover here):</p>
<ul>
<li>Instead of a MAC on a single message, the MAC is designed to support multiple distinct messages, and this is specifically to allow the credentials we'll describe next, to support <em>attributes</em>.</li>
<li>The paper gives an argument in the so-called "generic group model" (GGM) that this construction has the full UF-CMVA security property (the original argument for only <em>selective</em> security is not really OK in any scenario where users can query verification on tags).</li>
</ul>
<p>As is probably obvious, in this new construction, the tag is calculated by: \(T = (U, (k_1 m_1 + k_2 m_2 + \ldots + k_n m_n + k_0)U)\); it's easy to see that the "multiplicative and additive" arguments mentioned above still apply (note the presence of \(k_0\)) (although the security argument is very different, see Appendix A of the paper). This looks superficially similar to a vector Pedersen commitment of the form seen in constructions like Bulletproofs (only superficially: here also, the vector is blinded, but at the level of scalars; we don't use different base points).</p>
<p>The main reason this is even interesting is how it naturally supports <strong>selective revelation</strong> - zero knowledge proofs that certain of these messages have particular values or perhaps are in a range.
Other previous MAC constructions couldn't do this in any reasonable way (although there was a big literature of achieving similar properties using (blind) signatures).
<a href="key-verified"></a></p>
<h3>Key-Verified Anonymous Credentials (KVAC)</h3>
<p>Now we have the theoretical basis, we can construct a credential system with two of the properties we want - anonymity, and attributes. And that's what the meat of the Chase et al. paper does. It describes a credential system, using MAC-GGM as a primitive. The functionality of this credential system can be boiled down to:</p>
<ul>
<li>Keygen: generate secret keys and public parameters for the protocol instance (called <em>iparams</em>, short for issuer parameters). These parameters include public commitments to the secret keys.</li>
<li>Blind Issuance: a user can request and the issuer can provide  credentials on a set of attributes (\(m_i\)) in the above, where some of the attributes are allowed to be hidden from the issuer.</li>
<li>Show-Verification: a user can prove to the issuer (or, any other holder of the secret key material), in zero knowledge, that they possess a credential whose attributes satisfy a specific set of constraints.
<a href="how-does-issuance-work"></a></li>
</ul>
<h4>How does issuance work?</h4>
<p>Because we've laid the foundations, this is pretty easy to <em>describe</em>, albeit the concrete steps of mathematically creating the credential, isn't.
<a href="without-any-blinding"></a></p>
<h5>Without any blinding:</h5>
<p>(From here the private key set of the issuer is denoted with \(x\) rather than \(k\).</p>
<p><strong>Issuance</strong> - We issue a credential consisting of a MAC-GGM style of MAC, combined with a proof of its validity. Form, on a set of messages \(m_i\): \((U, (x_1 m_1 + x_2 m_2 + \ldots + x_n m_n + x_0)U, \pi)\) - the proof \(\pi\) exists because the credential must be accompanied by a proof that it is correctly formed with respect to the issuer parameters that were decided at the start of the protocol, but without revealing the issuer's secret key material.</p>
<p><strong>Show/Verify</strong> - this is where it gets interesting. The user does not just "present his MAC" as that would violate our intention to make the credentials anonymous. Instead, he presents <em>commitments to his MAC</em> along with a zero knowledge proof of correct formation. He presents \((U, {C_{m_i}}^{n}<em u_="u^{'">{i=1}, C</em>}, \Pi)\). Taking those elements in order:</p>
<ul>
<li>\(U\) - this is the base point of the MAC which was issued as credential, but it will have been rerandomised as \(U = aU_0\) for some \(a\). (There is a point of confusion in the paper here; in Appendix E the detailed treatment correctly notes that \(U, U'\) must be re-randomised by multiplication with a random scalar, in order to prevent trivial linkability between the Issue and Show/Verify steps, but this is not mentioned in Section 4.2).</li>
<li>\({C_{m_i}}^{n}_{i=1}\) - these are Pedersen commitments to the individual attribute messages (note - the plaintext messages can be sent instead for those messages which are not hidden/encrypted, to save communication - we will talk about hidden attributes next). The blinding value for each commitment is \(z_i\).</li>
<li>\(C_{U'}\) is a single Pedersen commitment to the second element of the tag. The blinding value is \(r\).</li>
<li>\(\Pi\) - as mentioned, we need a zero knowledge proof of correct formation - this consists of a proof that the commitments \(C_{m_i}\) and \(C_{U'}\), when combined with the secret keys that only the verifier holds, will give the same outpoint group element \(V\) from the calculation \(x_0U + \sum_{i} x_i C_{m_i} - C_{U'} = V\) as the prover obtained from the calculation with public issuer parameters \(X_i\), i.e. \(V = \sum_{i} z_i X_i - rG\).</li>
</ul>
<p>That last point is very tricky so I'm going to expand on it. What makes this credential construction special is its requirement to hide something from both sides - the user wants to hide the attributes \(m_i\) (in general if not always) from the issuer, and the issuer of course wants to hide the secret keys from the user.</p>
<p>This is dealt with algebraically by using something similar to ECDH keys, where \(S = pqG = pQ = qP\), i.e. both sides have their own secret they keep from each other, but still create a shared secret. The variable \(V\) represents this, but to keep the following simple we'll imagine \(n=1\), i.e. that there's only one message/attribute.</p>
<p>On the user side, we are summing elements of the form \(z_i X_i = z_i x_i H\), but the blinding terms in the message commitments \(C_{m_i}\) are also \(z_i H\), so that they can be converted into part of a term \(x_i C_{m_i}\) that the issuer can verify using the secret keys. The remaining term in the commitments \(C_{m_i}\) is \(m_i U\) which is converted into part of \(U'\) by the same multiplication by the secret key: \(x_i C_{m_i} = x_i m_i U = U' - x_0 U\). This equality is worked through in detail in the paper, but notice that basically, the group homomorphism can be used to allow the issuer to verify, using his own secret values, what the user constructed as message commitments, with his secret values.
<a href="side-note"></a></p>
<h5>Side note: what are these mysterious "zero knowledge proofs"?</h5>
<p>The proof systems used for these kind of statements are all variants of the basic Schnorr protocol + Fiat-Shamir transform that I explained in great detail <a href="https://github.com/AdamISZ/from0k2bp/blob/master/from0k2bp.pdf">here</a> (Section 3), though I also strongly recommend <a href="https://toc.cryptobook.us/">Boneh and Shoup</a> Chapter 19 for more rigorous treatments. Note that very often we are using the "AND of sigma protocols" paradigm, in which multiple statements are proved concurrently, and this is achieved by committing to all the statements in the first step, including all those commitments in the hash challenge preimage before constructing the response. As well as the aforementioned links, you can see a good simple example of this paradigm in Appendix E of CMZ13, albeit there are two serious errors in the description of the verification algorithm, as I explained on stackexchange <a href="https://crypto.stackexchange.com/a/85952/14985">here</a>.
<a href="with-blinding"></a></p>
<h5>With blinding of attributes:</h5>
<p>These attributes can be encrypted using <a href="https://en.wikipedia.org/wiki/ElGamal_encryption">El Gamal encryption</a> in such a way that a credential can still be issued without revealing (some of) them. The mechanics of El Gamal are about as simple as an encryption scheme gets:</p>
<ul>
<li>Key: a normal public/private key pair from the group, say \(P = pG\)</li>
<li>Encrypt: take as message point \(M\), create new randomness r, output \((rG, rP + M)\) (remember, asymmetric encryption, so not necessarily private key holder)</li>
<li>Decrypt: take ciphertext \(c_1, c_2\) as per above and note \(p(rG) = r(pG) = P\) (the Diffie Hellman shared secret primitive), so that \(c_2 - pc_1 = M\)</li>
</ul>
<p>Note that this system encrypts and decrypts <em>group elements</em> \(M\) rather than scalars, \(m\). In cases where it's the latter that needs to be encrypted, sometimes this hiccup can be circumvented with a ZKP of the underlying message scalar. However the next paper, CPZ19, addresses this point (see next section) along with a lot of other things.</p>
<p>Now, how could this El Gamal scheme be used to aid getting credentials on hidden attributes?</p>
<p>(EC) El Gamal encryption has an additive homomorphism (this was noted in one of my earlier blog posts <a href="https://web.archive.org/web/20200428225915/https://joinmarket.me/blog/blog/finessing-commitments/">here</a>. (additive here means for elliptic curve point <em>addition</em>): \(E(A) + E(B) = E(A+B)\) (the notation is very poor here: encryptions have attached randomness, but anyway). Whenever you have this additive homomorphism, you also have the scalar multiply, trivially: \(aE(A) = E(aA)\). We can leverage this to pass the encryption "through" the MAC procedure.</p>
<p>The user would give the El Gamal encryption of one or more attributes \(m_i\) to the issuer to be tagged. They would give \((P, (r_1 G, m_1 G + r_1 P))\) as the two elements of the ciphertext, where we stick with just one attribute index for simplicity. The issuer would pick \(U\) here as \(bG\) where \(b\) is a random scalar (we'll see why this is needed rather than NUMS in a moment), and create an <em>encrypted</em> tag on the <em>encrypted</em> attribute message: \(E(U') = E(x_0 U + m_1 x_1 U) = E(x_0 U) + x_1 E(m_1 U) = E(x_0 U) + x_1 b E(m_1 G)\) and \(E(m_1 G)\) is exactly what the user gave them. Thus they can easily create an encryption of \(U'\) on the message \(m_1\) *without ever seeing \(m_1\).
This encryption must then be blinded, but that's easy, by adding extra randomness in the form of an encryption of 0. Again a ZKP will need to be attached when the issuer returns this encryption to the user, but if it is valid, the user can know that when he decrypts \(E(U')\) to \(U'\), he will have a valid credential (tag) \((U, U')\) for his attribute/message.</p>
<h3>Chase-Perrin-Zaverucha 2019</h3>
<p>The scope of this paper (CPZ19 for short), which is intended to provide a credential system for the Signal messenger system, is much larger, but part of it is creating a more powerful credential design (albeit an inheritor; the security proof for CPZ19 uses a reduction to CMZ13) than that found in CMZ13. These credentials support <em>both</em> scalar attributes and group elements as attributes - the latter can be appealing for general purposes of creating efficient ZKPs (or a more elementary aspect of the same thing: easier El-Gamal encryption of the type described in the previous section - indeed having attributes encrypted in this way is a fundamental part of their design).</p>
<p>The credential construction looks much more complicated as presented since it uses different <a href="https://en.wikipedia.org/wiki/Nothing-up-my-sleeve_number">NUMS</a> base points for multiple different components: the secret key elements (x_0, x_1) as before for the basic idea of the Dodis et al algebraic MAC, but there are then base points for each of a vector of secret keys, one per attribute (and more, see paper for full setup). Notably the construction of the MAC tag itself, looks quite different:</p>
<p>\((t, U, (W + (x_0 +x_1 t)U + \sum_{i=1}^n y_i M_i )\)</p>
<p>here \(t\) and \(U\) are generated by the issuer at random, while the \(y_i\) are the aforementioned vector of secret keys corresponding to each message/attribute.</p>
<p>While the construction is significantly more complex, the basic principle of how crendentials are issued, and then show/verified, is essentially the same, and that encludes the idea of encrypting credentials using El Gamal. The same construct carries over as was described under "with blinding of attributes", but the authors have a slightly different approach in mind:</p>
<p>Given an existing credential/MAC, you can quite elegantly prove that an ElGamal encryption of a specific attribute is in fact attested to by the MAC, using again a ZKP about a relationship between the MAC and the encryption. However the authors do caution:</p>
<p>"We caveat that this is only a promising direction for a new (public-key) verifiable encryption scheme, since the above basic Elgamal scheme is not CCA secure, and we have not carefully analyzed its security."</p>
<p>(here <a href="https://en.wikipedia.org/wiki/Chosen-ciphertext_attack">CCA</a> means "chosen ciphertext attack"; security under this condition is the main goal of provably secure encryption schemes).</p>
<p>At the beginning of this section I mentioned that the security argument for this flavor of algebraic MAC is based on a reduction to the case of CMZ13 above, which was proven UF-CMVA secure in the generic group model. However this reduction only produces SUF-CMVA, which is to say 'selective security' - here, we only consider an attacker who specifies the message \(m^{*}\) in advance of their message tagging and verification queries. I'm not sure if this is sufficient.</p>
<h3>Wabisabi: credentials on amounts with splitting</h3>
<p>Wabisabi uses basically exactly the CPZ19 construction for its credentials. The main "twist" is a simplification: only 'value' (value in BTC) attributes are needed, and they are of course integer values. These credentials will allow a coinjoin participant to follow the workflow mentioned at the start of this article:</p>
<ul>
<li>As one pseudonym, register 1 or more inputs and request N credentials for the input, with the values of each <em>credential</em> hidden, but accompanied with a zero knowledge proof that the sum of those values is as it should be (the input's value).</li>
<li>As another pseudonym, present the credentials and the intended coinjoin outputs, with a proof that the sum of the redeemed credentials tallies up to the total of the outputs.</li>
</ul>
<p>Serial numbers are also used as part of the credential, to prevent double spend of the same credential (remember, the credentials are specifically designed to be <em>unlinkable</em>).</p>
<p>However the paper is careful to build up to what it calls a "unified registration protocol" where it generalises the whole process of both creating and redeeming these credentials, and makes the interaction more efficient.</p>
<h4>Range proofs</h4>
<p>Any former student of the ideas behind <a href="https://en.bitcoin.it/wiki/Confidential_transactions">Confidential Transactions</a> will find this part obvious. Simply presenting <em>commitments</em> to integer amounts (in satoshis, say) doesn't provide the intended security: since in modular arithmetic, a very large integer is mathematically equivalent to a small negative integer, it would be easy for users to cheat the amounts they get out by requesting commitments on (effectively) negative amounts. The way round this is again a ZKP, of a particular flavor known as a range proof: you prove that the integer \(a\) is between say 1 and \(2^{32}\) or whatever suits. This can be done e.g. with <a href="https://eprint.iacr.org/2017/1066">Bulletproofs</a> but also the range proof can be embedded as another statement in the overall ZKP provided by the user.</p>
<p>A relevant question, though, and one worth pondering: are the range proofs actually necessary? As discussed in the next section, there isn't a risk of funds loss in the basic coinjoin construct, with or without this extra crypto magic of credentials. So a malicious user constructing credentials in invalid negative amounts is not going to be able to claim more money, but this does represent a DOS vector, one that is usually addressed just with the requirement of users to provide and sign off on a valid utxo.</p>
<p>However there still may be further room for thought here; the range proof could be provided as part of a blame phase of a protocol, and avoided in the happy path of correct coinjoins being presented for signing. Apparently ZmnSCPxj has suggested this.</p>
<h3>Final thoughts on the security and functionality proposed in Wabisabi</h3>
<p>This article has just been a survey of some of the technical (cryptographic) underpinnings; the paper itself is specifically more about the theoretical construct, and not a fully fleshed out system spec as would be needed for a full software instantiation.</p>
<ul>
<li>How secure is it?</li>
</ul>
<p>As the paper notes in the final section 5, we should not forget the fundamental security inherent in Coinjoin, however it is coordinated: users only sign what does not rob them of money, and a single transaction does not suffer from anything related to blockchain mechanics (delays, reorgs etc). So what risks exist will be around DOS (inconvenience, lost time) and much more importantly, privacy loss:</p>
<ul>
<li>How strong are the privacy guarantees?</li>
</ul>
<p>First, to state the obvious, there is a dependency on discrete log hardness, but that's just at basis, more exactly, there is a DDH hardness assumption (see 6.2 of CPZ19) underlying the security of this MAC construction. As mentioned in the previous bullet point, this is <em>effectively</em> only relevant to the privacy of the users w.r.t. the issuer (here the coinjoin coordinator) of the credentials, although nominally a breakage of that security (assume in the worst case, ability forge MACs arbitrarily) would "allow the user to forge credentials for arbitrary bitcoin amounts", but that is a DOS vector only as it creates invalid coinjoins that won't be signed.</p>
<ul>
<li>How much defence against the issuer is there, i.e. is trust in the coordinator required for privacy?</li>
</ul>
<p>This is actually a fairly tricky point. Restricting the coordinator's ability to tag (pun intended) or selectively censor is quite critical, and non trivial.</p>
<p>The splitting into multiple credentials helps; it is less easy for the malicious coordinator to figure out how to jam individual participants if they are going through multiple rounds of credential issuance and redemption. From conversations with nothingmuch it appears that quite a lot of thought is being put into this aspect of the protocol; those interested may want to read <a href="https://github.com/zkSNACKs/WabiSabi/blob/master/protocol.md">this</a> protocol spec document for the latest. Also along the same lines, the paper notes:</p>
<blockquote>
<p>A malicious coordinator may also tag users by providing them with different issuer parameters. When
registering inputs a proof of ownership must be provided. If signatures are used, by covering the issuer
parameters and a unique round identifier these proofs allow other participants to verify that everyone was
given the same parameters.</p>
</blockquote>
<p>Basically what is going on here is that there is a kind of "public" aspect to input registration; users sign the issuer parameters for the round, and then these signatures, at a certain point in the negotiation, are broadcast to all participants (with encryption), so that a malicious coordinator can be prevented from tagging users by giving them all different round issuer parameters.</p></div>
	<hr>
	<h2>Comments</h2>
</div>
		</div>
	</div> 	<!-- <hr> -->
</div> <!-- /container -->
<footer class="aw-footer bg-danger">
	<div class="container"> <!-- footer -->
		<div class="row">
			<div class="col-md-10 col-md-offset-1">
				<div class="row">
					<div class="col-md-3">
						<h4>Navigation</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://joinmarket.me">Joinmarket.me archive</a></li>
							<li><a href="https://joinmarket.me/about-me/"><i class="fa fa-About Me "></i> About Me</a></li>
							<li><a href="https://joinmarket.me/blog/"><i class="fa fa-Blog "></i> Blog</a></li>
							<li><a href="https://joinmarket.me/main-page/"><i class="fa fa-Main Page "></i> Main Page</a></li>
							<li><a href="https://joinmarket.me/feeds/all.atom.xml" type="application/atom+xml"><i class="fa fa-rss "></i> atom</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Author</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://x0f.org/web/accounts/41381">waxwing on mastodon</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Categories</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://joinmarket.me/category/waxwings-blog.html">waxwings Blog (14)</a></li>
						</ul>
					</div>
					<div class="col-md-3">
						<h4>Links</h4>
						<ul class="list-unstyled my-list-style">
							<li><a href="https://en.bitcoin.it/wiki/Privacy">Bitcoin Wiki Privacy article</a></li>
							<li><a href="https://old.reddit.com/r/joinmarket">Joinmarket reddit</a></li>
							<li><a href="https://bitcointalk.org/index.php?topic=279249.620">Original description of Coinjoin</a></li>
							<li><a href="https://github.com/AdamISZ/JMPrivacyAnalysis/blob/master/tumbler_privacy.md">My analysis of privacy in Joinmarket's (old) tumbler algorithm</a></li>
							<li><a href="https://www.ndss-symposium.org/wp-content/uploads/2017/09/ndss201701-4RuffingPaper.pdf">Coinshuffle++ and DiceMix paper</a></li>
							<li><a href="https://eprint.iacr.org/2016/575">Tumblebit paper</a></li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</div>
</footer>
<div class="container">
	<div class="row">
		<div class="col-md-12 text-center center-block aw-bottom">
			<p>&copy; Adam Gibson 2016</p>
			<p>Powered by Pelican</p>
		</div>
	</div>
</div>
<!-- JavaScript -->
<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script type="text/javascript">
jQuery(document).ready(function($) {
	$("div.collapseheader").click(function () {
		$header = $(this).children("span").first();
		$codearea = $(this).children(".input_area");
		$codearea.slideToggle(500, function () {
			$header.text(function () {
				return $codearea.is(":visible") ? "Collapse Code" : "Expand Code";
			});
		});
	});
});
</script>
</body>
</html>